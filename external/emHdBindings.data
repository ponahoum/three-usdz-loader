# Portions of this file auto-generated by usdGenSchema.
# Edits will survive regeneration except for comments and
# changes to types with autoGenerated=true.
{
    "Plugins": [
        {
            "Info": {
                "SdfMetadata": {
                    "bindMaterialAs": {
                        "appliesTo": [
                            "relationships"
                        ], 
                        "displayGroup": "Shading", 
                        "documentation": "Metadata authored on collection-based material binding relationship to indicate the strength of the binding relative to bindings authored on descendant prims.", 
                        "type": "token"
                    }, 
                    "connectability": {
                        "appliesTo": [
                            "attributes"
                        ], 
                        "default": "full", 
                        "displayGroup": "Shading", 
                        "documentation": "Metadata authored on UsdShadeInput's to specify what they can be connected to. Can be either \"full\" or \"interfaceOnly\". \"full\" implies that  the input can be connected to any other input or output.  \"interfaceOnly\" implies that the input can only connect to a NodeGraph Input (which represents an interface override, not a render-time dataflow connection), or another Input whose connectability is also \"interfaceOnly\".", 
                        "type": "token"
                    }, 
                    "outputName": {
                        "appliesTo": [
                            "relationships"
                        ], 
                        "displayGroup": "deprecated", 
                        "type": "token"
                    }, 
                    "renderType": {
                        "appliesTo": [
                            "properties"
                        ], 
                        "displayGroup": "Rendering", 
                        "type": "token"
                    }, 
                    "sdrMetadata": {
                        "appliesTo": [
                            "prims", 
                            "attributes"
                        ], 
                        "displayGroup": "Shading", 
                        "type": "dictionary"
                    }
                }, 
                "Types": {
                    "UsdShadeConnectableAPI": {
                        "alias": {
                            "UsdSchemaBase": "ConnectableAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "nonAppliedAPI"
                    }, 
                    "UsdShadeCoordSysAPI": {
                        "alias": {
                            "UsdSchemaBase": "CoordSysAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "nonAppliedAPI"
                    }, 
                    "UsdShadeMaterial": {
                        "alias": {
                            "UsdSchemaBase": "Material"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdShadeNodeGraph"
                        ], 
                        "providesUsdShadeConnectableAPIBehavior": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdShadeMaterialBindingAPI": {
                        "alias": {
                            "UsdSchemaBase": "MaterialBindingAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdShadeNodeDefAPI": {
                        "alias": {
                            "UsdSchemaBase": "NodeDefAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdShadeNodeGraph": {
                        "alias": {
                            "UsdSchemaBase": "NodeGraph"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdTyped"
                        ], 
                        "providesUsdShadeConnectableAPIBehavior": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdShadeShader": {
                        "alias": {
                            "UsdSchemaBase": "Shader"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdTyped"
                        ], 
                        "providesUsdShadeConnectableAPIBehavior": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdShadeShaderDefParserPlugin": {
                        "bases": [
                            "NdrParserPlugin"
                        ], 
                        "displayName": "USD-based shader definition parser plugin"
                    }
                }
            }, 
            "LibraryPath": "", 
            "Name": "usdShade", 
            "ResourcePath": "resources", 
            "Root": "..", 
            "Type": "library"
        }
    ]
}
#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class NodeGraph "NodeGraph" (
    doc = '''A node-graph is a container for shading nodes, as well as other 
    node-graphs. It has a public input interface and provides a list of public 
    outputs.

    <b>Node Graph Interfaces</b>
    
    One of the most important functions of a node-graph is to host the "interface"
    with which clients of already-built shading networks will interact.  Please
    see "Interface Inputs" for a detailed
    explanation of what the interface provides, and how to construct and
    use it, to effectively share/instance shader networks.

    <b>Node Graph Outputs</b>

    These behave like outputs on a shader and are typically connected to an 
    output on a shader inside the node-graph.
    '''
)
{
}

class Material "Material" (
    doc = """A Material provides a container into which multiple \"render targets\"
    can add data that defines a \"shading material\" for a renderer.  Typically
    this consists of one or more UsdRelationship properties that target
    other prims of type Shader - though a target/client is free to add
    any data that is suitable.  We <b>strongly advise</b> that all targets
    adopt the convention that all properties be prefixed with a namespace
    that identifies the target, e.g. \"rel ri:surface = </Shaders/mySurf>\".
    
    ## Binding Materials
    
    In the UsdShading model, geometry expresses a binding to a single Material or
    to a set of Materials partitioned by UsdGeomSubsets defined beneath the
    geometry; it is legal to bind a Material at the root (or other sub-prim) of 
    a model, and then bind a different Material to individual gprims, but the
    meaning of inheritance and \"ancestral overriding\" of Material bindings is 
    left to each render-target to determine.  Since UsdGeom has no concept of 
    shading, we provide the API for binding and unbinding geometry on the API 
    schema UsdShadeMaterialBindingAPI.
    
    ## Material Variation
    
    The entire power of USD VariantSets and all the other composition 
    operators can leveraged when encoding shading variation.  
    UsdShadeMaterial provides facilities for a particular way of building
    \"Material variants\" in which neither the identity of the Materials themselves
    nor the geometry Material-bindings need to change - instead we vary the
    targeted networks, interface values, and even parameter values within
    a single variantSet.  
    See \"Authoring Material Variations\" 
    for more details.

    ## Materials Encapsulate their Networks in Namespace
    
    UsdShade requires that all of the shaders that \"belong\" to the Material 
    live under the Material in namespace. This supports powerful, easy reuse
    of Materials, because it allows us to *reference* a Material from one
    asset (the asset might be a library of Materials) into another asset: USD 
    references compose all descendant prims of the reference target into the 
    referencer's namespace, which means that all of the referenced Material's 
    shader networks will come along with the Material. When referenced in this
    way, Materials can also be [instanced](http://openusd.org/docs/USD-Glossary.html#USDGlossary-Instancing), for ease of deduplication and compactness.
    Finally, Material encapsulation also allows us to 
    \"specialize\" child materials from 
    parent materials.
    
    """
)
{
    token outputs:displacement (
        displayGroup = "Outputs"
        doc = '''Represents the universal "displacement" output terminal of a 
        material.'''
    )
    token outputs:surface (
        displayGroup = "Outputs"
        doc = '''Represents the universal "surface" output terminal of a
        material.'''
    )
    token outputs:volume (
        displayGroup = "Outputs"
        doc = '''Represents the universal "volume" output terminal of a
        material.'''
    )
}

class Shader "Shader" (
    apiSchemas = ["NodeDefAPI"]
    doc = '''Base class for all USD shaders. Shaders are the building blocks
    of shading networks. While UsdShadeShader objects are not target specific,
    each renderer or application target may derive its own renderer-specific 
    shader object types from this base, if needed.
    
    Objects of this class generally represent a single shading object, whether
    it exists in the target renderer or not. For example, a texture, a fractal,
    or a mix node.

    The UsdShadeNodeDefAPI provides attributes to uniquely identify the
    type of this node.  The id resolution into a renderable shader target
    type of this node.  The id resolution into a renderable shader target
    is deferred to the consuming application.

    The purpose of representing them in Usd is two-fold:
    - To represent, via "connections" the topology of the shading network
    that must be reconstructed in the renderer. Facilities for authoring and 
    manipulating connections are encapsulated in the API schema 
    UsdShadeConnectableAPI.
    - To present a (partial or full) interface of typed input parameters 
    whose values can be set and overridden in Usd, to be provided later at 
    render-time as parameter values to the actual render shader objects. Shader 
    input parameters are encapsulated in the property schema UsdShadeInput.
    '''
)
{
}

class "NodeDefAPI" (
    doc = '''UsdShadeNodeDefAPI is an API schema that provides attributes
    for a prim to select a corresponding Shader Node Definition ("Sdr Node"),
    as well as to look up a runtime entry for that shader node in the
    form of an SdrShaderNode.

    UsdShadeNodeDefAPI is intended to be a pre-applied API schema for any
    prim type that wants to refer to the SdrRegistry for further implementation
    details about the behavior of that prim.  The primary use in UsdShade
    itself is as UsdShadeShader, which is a basis for material shading networks
    (UsdShadeMaterial), but this is intended to be used in other domains
    that also use the Sdr node mechanism.

    This schema provides properties that allow a prim to identify an external
    node definition, either by a direct identifier key into the SdrRegistry
    (info:id), an asset to be parsed by a suitable NdrParserPlugin
    (info:sourceAsset), or an inline source code that must also be parsed
    (info:sourceCode); as well as a selector attribute to determine which
    specifier is active (info:implementationSource).
    '''
)
{
    uniform token info:id (
        doc = """The id is an identifier for the type or purpose of the 
        shader. E.g.: Texture or FractalFloat.
        The use of this id will depend on the render target: some will turn it
        into an actual shader path, some will use it to generate shader source 
        code dynamically.
        
        \\sa SetShaderId()
        """
    )
    uniform token info:implementationSource = "id" (
        allowedTokens = ["id", "sourceAsset", "sourceCode"]
        doc = """Specifies the attribute that should be consulted to get the 
        shader's implementation or its source code.

        * If set to \"id\", the \"info:id\" attribute's value is used to 
        determine the shader source from the shader registry.
        * If set to \"sourceAsset\", the resolved value of the \"info:sourceAsset\" 
        attribute corresponding to the desired implementation (or source-type)
        is used to locate the shader source.  A source asset file may also
        specify multiple shader definitions, so there is an optional attribute
        \"info:sourceAsset:subIdentifier\" whose value should be used to indicate
        a particular shader definition from a source asset file.
        * If set to \"sourceCode\", the value of \"info:sourceCode\" attribute 
        corresponding to the desired implementation (or source type) is used as 
        the shader source.
        """
    )
}

class "ConnectableAPI" (
    doc = """UsdShadeConnectableAPI is an API schema that provides a common
    interface for creating outputs and making connections between shading 
    parameters and outputs. The interface is common to all UsdShade schemas
    that support Inputs and Outputs, which currently includes UsdShadeShader,
    UsdShadeNodeGraph, and UsdShadeMaterial .

    One can construct a UsdShadeConnectableAPI directly from a UsdPrim, or
    from objects of any of the schema classes listed above.  If it seems
    onerous to need to construct a secondary schema object to interact with
    Inputs and Outputs, keep in mind that any function whose purpose is either
    to walk material/shader networks via their connections, or to create such
    networks, can typically be written entirely in terms of 
    UsdShadeConnectableAPI objects, without needing to care what the underlying
    prim type is.

    Additionally, the most common UsdShadeConnectableAPI behaviors
    (creating Inputs and Outputs, and making connections) are wrapped as
    convenience methods on the prim schema classes (creation) and 
    UsdShadeInput and UsdShadeOutput.
    """
)
{
}

class "MaterialBindingAPI" (
    doc = """UsdShadeMaterialBindingAPI is an API schema that provides an 
    interface for binding materials to prims or collections of prims 
    (represented by UsdCollectionAPI objects). 
    
    In the USD shading model, each renderable gprim computes a single 
    <b>resolved Material</b> that will be used to shade the gprim (exceptions, 
    of course, for gprims that possess UsdGeomSubsets, as each subset can be 
    shaded by a different Material).  A gprim <b>and each of its ancestor 
    prims</b> can possess, through the MaterialBindingAPI, both a 
    <b>direct</b> binding to a Material, and any number of 
    <b>collection-based</b> bindings to Materials; each binding can be generic 
    or declared for a particular <b>purpose</b>, and given a specific <b>binding 
    strength</b>. It is the process of \"material resolution\" (see 
    that examines all of 
    these bindings, and selects the one Material that best matches the 
    client's needs.

    The intent of <b>purpose</b> is that each gprim should be able to resolve a 
    Material for any given purpose, which implies it can have differently bound 
    materials for different purposes. There are two <i>special</i> values of 
    <b>purpose</b> defined in UsdShade, although the API fully supports 
    specifying arbitrary values for it, for the sake of extensibility:
    <ul><li><b>UsdShadeTokens->full</b>: to be used when the purpose of the 
    render is entirely to visualize the truest representation of a scene, 
    considering all lighting and material information, at highest fidelity.</li>  
    <li><b>UsdShadeTokens->preview</b>: to be used when the render is in 
    service of a goal other than a high fidelity \"full\" render (such as scene
    manipulation, modeling, or realtime playback). Latency and speed are 
    generally of greater concern for preview renders, therefore preview 
    materials are generally designed to be \"lighterweight\" compared to full
    materials.</li></ul>
    A binding can also have no specific purpose at all, in which 
    case, it is considered to be the fallback or all-purpose binding (denoted 
    by the empty-valued token <b>UsdShadeTokens->allPurpose</b>). 

    The <b>purpose</b> of a material binding is encoded in the name of the 
    binding relationship. 
    <ul><li>
    In the case of a direct binding, the <i>allPurpose</i> binding is 
    represented by the relationship named <b>\"material:binding\"</b>. 
    Special-purpose direct bindings are represented by relationships named
    <b>\"material:binding:<i>purpose</i></b>. A direct binding relationship 
    must have a single target path that points to a <b>UsdShadeMaterial</b>.</li>
    <li>
    In the case of a collection-based binding, the <i>allPurpose</i> binding is 
    represented by a relationship named 
    \"material:binding:collection:<i>bindingName</i>\", where 
    <b>bindingName</b> establishes an identity for the binding that is unique 
    on the prim. Attempting to establish two collection bindings of the same 
    name on the same prim will result in the first binding simply being 
    overridden. A special-purpose collection-based binding is represented by a 
    relationship named \"material:binding:collection:<i>purpose:bindingName</i>\".
    A collection-based binding relationship must have exacly two targets, one of 
    which should be a collection-path (see 
    and the other should point to a
    <b>UsdShadeMaterial</b>. In the future, we may allow a single collection 
    binding to target multiple collections, if we can establish a reasonable 
    round-tripping pattern for applications that only allow a single collection 
    to be associated with each Material.
    </li>
    </ul>

    <b>Note:</b> Both <b>bindingName</b> and <b>purpose</b> must be 
    non-namespaced tokens. This allows us to know the role of a binding 
    relationship simply from the number of tokens in it. 
    <ul><li><b>Two tokens</b>: the fallback, \"all purpose\", direct binding, 
    <i>material:binding</i></li>
    <li><b>Three tokens</b>: a purpose-restricted, direct, fallback binding, 
    e.g. material:binding:preview</li>
    <li><b>Four tokens</b>: an all-purpose, collection-based binding, e.g. 
    material:binding:collection:metalBits</li>
    <li><b>Five tokens</b>: a purpose-restricted, collection-based binding, 
    e.g. material:binding:collection:full:metalBits</li>
    </ul>

    A <b>binding-strength</b> value is used to specify whether a binding 
    authored on a prim should be weaker or stronger than bindings that appear 
    lower in namespace. We encode the binding strength with as token-valued 
    metadata <b>'bindMaterialAs'</b> for future flexibility, even though for 
    now, there are only two possible values:
    <i>UsdShadeTokens->weakerThanDescendants</i> and 
    <i>UsdShadeTokens->strongerThanDescendants</i>. When binding-strength is 
    not authored (i.e. empty) on a binding-relationship, the default behavior 
    matches UsdShadeTokens->weakerThanDescendants.

    \\note If a material binding relationship is a built-in property defined as 
    part of a typed prim's schema, a fallback value should not be provided for 
    it. This is because the \"material resolution\" algorithm only conisders 
    <i>authored</i> properties.
    """
)
{
}

class "CoordSysAPI" (
    doc = '''UsdShadeCoordSysAPI provides a way to designate, name,
    and discover coordinate systems.

    Coordinate systems are implicitly established by UsdGeomXformable
    prims, using their local space.  That coordinate system may be
    bound (i.e., named) from another prim.  The binding is encoded
    as a single-target relationship in the "coordSys:" namespace.
    Coordinate system bindings apply to descendants of the prim
    where the binding is expressed, but names may be re-bound by
    descendant prims.

    Named coordinate systems are useful in shading workflows.
    An example is projection paint, which projects a texture
    from a certain view (the paint coordinate system).  Using
    the paint coordinate frame avoids the need to assign a UV
    set to the object, and can be a concise way to project
    paint across a collection of objects with a single shared
    paint coordinate system.

    This is a non-applied API schema.
    '''
)
{
}

#usda 1.0
(
    "This file describes the USD Shader schemata for code generation."
    subLayers = [
        @usd/schema.usda@
    ]
)

over "GLOBAL" (
    customData = {
        string libraryName      = "usdShade"
        string libraryPath      = "pxr/usd/usdShade"
        dictionary libraryTokens = {
            dictionary materialBind = {
                string doc = """The name of the GeomSubset family used to 
                identify face subsets defined for the purpose of binding 
                materials to facesets.
                """
            }
            dictionary full = {
                string doc= """Possible value for 'connectability' metadata on
                a UsdShadeInput. When connectability of an input is set to
                "full", it implies that it can be connected to any input or
                output.
                """
            }
            dictionary interfaceOnly = {
                string doc= """Possible value for 'connectability' metadata on 
                a UsdShadeInput. It implies that the input can only connect to 
                a NodeGraph Input (which represents an interface override, not 
                a render-time dataflow connection), or another Input whose 
                connectability is also 'interfaceOnly'.
                """
            }
            dictionary outputs = {
                string value = "outputs:"
                string doc = """The prefix on shading attributes
                denoting an output.
                """
            }
            dictionary inputs = {
                string value = "inputs:"
                string doc = """The prefix on shading attributes
                denoting an input.
                """
            }
        }
    }
)
{
}

class NodeGraph "NodeGraph" (
    inherits = </Typed>
    doc = """A node-graph is a container for shading nodes, as well as other 
    node-graphs. It has a public input interface and provides a list of public 
    outputs.

    <b>Node Graph Interfaces</b>
    
    One of the most important functions of a node-graph is to host the "interface"
    with which clients of already-built shading networks will interact.  Please
    see \\ref UsdShadeNodeGraph_Interfaces "Interface Inputs" for a detailed
    explanation of what the interface provides, and how to construct and
    use it, to effectively share/instance shader networks.

    <b>Node Graph Outputs</b>

    These behave like outputs on a shader and are typically connected to an 
    output on a shader inside the node-graph.
    """
    customData = {
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
        }
        string extraIncludes = '''
#include <utility>
#include "pxr/usd/usd/editTarget.h"
#include "pxr/usd/usd/relationship.h"
#include "pxr/usd/usdShade/input.h"
#include "pxr/usd/usdShade/output.h"
#include "pxr/usd/usdShade/shader.h"
#include "pxr/usd/usdShade/connectableAPIBehavior.h"'''
    }
) {

}


class Material "Material" (
    inherits = </NodeGraph>
    doc = """A Material provides a container into which multiple "render targets"
    can add data that defines a "shading material" for a renderer.  Typically
    this consists of one or more UsdRelationship properties that target
    other prims of type \\em Shader - though a target/client is free to add
    any data that is suitable.  We <b>strongly advise</b> that all targets
    adopt the convention that all properties be prefixed with a namespace
    that identifies the target, e.g. "rel ri:surface = </Shaders/mySurf>".
    
    ## Binding Materials
    
    In the UsdShading model, geometry expresses a binding to a single Material or
    to a set of Materials partitioned by UsdGeomSubsets defined beneath the
    geometry; it is legal to bind a Material at the root (or other sub-prim) of 
    a model, and then bind a different Material to individual gprims, but the
    meaning of inheritance and "ancestral overriding" of Material bindings is 
    left to each render-target to determine.  Since UsdGeom has no concept of 
    shading, we provide the API for binding and unbinding geometry on the API 
    schema UsdShadeMaterialBindingAPI.
    
    ## Material Variation
    
    The entire power of USD VariantSets and all the other composition 
    operators can leveraged when encoding shading variation.  
    UsdShadeMaterial provides facilities for a particular way of building
    "Material variants" in which neither the identity of the Materials themselves
    nor the geometry Material-bindings need to change - instead we vary the
    targeted networks, interface values, and even parameter values within
    a single variantSet.  
    See \\ref UsdShadeMaterial_Variations "Authoring Material Variations" 
    for more details.

    ## Materials Encapsulate their Networks in Namespace
    
    UsdShade requires that all of the shaders that "belong" to the Material 
    live under the Material in namespace. This supports powerful, easy reuse
    of Materials, because it allows us to *reference* a Material from one
    asset (the asset might be a library of Materials) into another asset: USD 
    references compose all descendant prims of the reference target into the 
    referencer's namespace, which means that all of the referenced Material's 
    shader networks will come along with the Material. When referenced in this
    way, Materials can also be [instanced](http://openusd.org/docs/USD-Glossary.html#USDGlossary-Instancing), for ease of deduplication and compactness.
    Finally, Material encapsulation also allows us to 
    \\ref UsdShadeMaterial_BaseMaterial "specialize" child materials from 
    parent materials.
    
    """
    customData = {
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
        }
        string extraIncludes = '''
#include "pxr/usd/usd/variantSets.h"
#include "pxr/usd/usdGeom/subset.h"
#include "pxr/usd/usdShade/connectableAPI.h"'''
        dictionary schemaTokens = {
            dictionary materialVariant = {
                string doc = """The variant name of material variation
                described on a UsdShadeMaterial.
                """
            }
            dictionary surface = {
                string doc = """Describes the <i>surface</i> output 
                terminal on a UsdShadeMaterial. It is used to define the 
                terminal UsdShadeShader describing the surface of a 
                UsdShadeMaterial.
                """
            }
            dictionary displacement = {
                string doc = """Describes the <i>displacement</i> output 
                terminal on a UsdShadeMaterial. It is used to define the 
                terminal UsdShadeShader describing the displacement of a 
                UsdShadeMaterial.
                """
            }
            dictionary volume = {
                string doc = """Describes the <i>volume</i> output 
                terminal on a UsdShadeMaterial. It is used to define the 
                terminal UsdShadeShader describing the volume of a 
                UsdShadeMaterial.
                """
            }
            dictionary universalRenderContext = {
                string value = ""
                string doc = """Possible value for the "renderContext" parameter
                in \\ref UsdShadeMaterial_Outputs API. Represents the universal
                renderContext. An output with a universal renderContext is 
                applicable to all possible rendering contexts.
                """
            }
        }
    }
) 
{
    token outputs:surface (
        doc = """Represents the universal "surface" output terminal of a
        material."""
        displayGroup = "Outputs"
        customData = {
            string apiName = "surface"
        }
    )
    token outputs:displacement (
        doc = """Represents the universal "displacement" output terminal of a 
        material."""
        displayGroup = "Outputs"
        customData = {
            string apiName = "displacement"
        }
    )
    token outputs:volume (
        doc = """Represents the universal "volume" output terminal of a
        material."""
        displayGroup = "Outputs"
        customData = {
            string apiName = "volume"
        }
    )
}

class Shader "Shader" (
    inherits = </Typed>
    prepend apiSchemas = ["NodeDefAPI"]
    doc = """Base class for all USD shaders. Shaders are the building blocks
    of shading networks. While UsdShadeShader objects are not target specific,
    each renderer or application target may derive its own renderer-specific 
    shader object types from this base, if needed.
    
    Objects of this class generally represent a single shading object, whether
    it exists in the target renderer or not. For example, a texture, a fractal,
    or a mix node.

    The UsdShadeNodeDefAPI provides attributes to uniquely identify the
    type of this node.  The id resolution into a renderable shader target
    type of this node.  The id resolution into a renderable shader target
    is deferred to the consuming application.

    The purpose of representing them in Usd is two-fold:
    \\li To represent, via "connections" the topology of the shading network
    that must be reconstructed in the renderer. Facilities for authoring and 
    manipulating connections are encapsulated in the API schema 
    UsdShadeConnectableAPI.
    \\li To present a (partial or full) interface of typed input parameters 
    whose values can be set and overridden in Usd, to be provided later at 
    render-time as parameter values to the actual render shader objects. Shader 
    input parameters are encapsulated in the property schema UsdShadeInput.
    """ 
    customData = {
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
        }
        string extraIncludes = '''
#include "pxr/usd/usdShade/input.h"
#include "pxr/usd/usdShade/output.h"
#include "pxr/usd/usdShade/tokens.h"
#include "pxr/usd/ndr/declare.h"
#include "pxr/usd/sdr/shaderNode.h"'''
    }
) {
}

class "NodeDefAPI"
(
    inherits = </APISchemaBase>
    doc = """UsdShadeNodeDefAPI is an API schema that provides attributes
    for a prim to select a corresponding Shader Node Definition ("Sdr Node"),
    as well as to look up a runtime entry for that shader node in the
    form of an SdrShaderNode.

    UsdShadeNodeDefAPI is intended to be a pre-applied API schema for any
    prim type that wants to refer to the SdrRegistry for further implementation
    details about the behavior of that prim.  The primary use in UsdShade
    itself is as UsdShadeShader, which is a basis for material shading networks
    (UsdShadeMaterial), but this is intended to be used in other domains
    that also use the Sdr node mechanism.

    This schema provides properties that allow a prim to identify an external
    node definition, either by a direct identifier key into the SdrRegistry
    (info:id), an asset to be parsed by a suitable NdrParserPlugin
    (info:sourceAsset), or an inline source code that must also be parsed
    (info:sourceCode); as well as a selector attribute to determine which
    specifier is active (info:implementationSource).
    """ 
    customData = {
        token apiSchemaType = "singleApply"
        string extraIncludes = """
#include "pxr/usd/ndr/declare.h"
#include "pxr/usd/sdr/shaderNode.h"
    """
        dictionary schemaTokens = {
            dictionary universalSourceType = {
                string value = ""
                string doc = """Possible value for the "sourceType" parameter 
                in \\ref UsdShadeNodeDefAPI_ImplementationSource API. Represents 
                the universal or fallback source type.
                """
            }
            dictionary sdrMetadata = {
                string doc = """Dictionary valued metadata key authored on
                Shader prims with implementationSource value of sourceAsset or 
                sourceCode to pass along metadata to the shader parser or 
                compiler. It is also used to author metadata on shader 
                properties in a UsdShade-based shader definition file.
                """
            }
            dictionary subIdentifier = {
                string doc = """This identifier is used in conjunction with a
                specific source asset to indicate a particular definition within
                the source asset, if the source asset specifies more than one
                shader node definition.
                """
            }
        }
    }
)
{
    uniform token info:implementationSource = "id" (
        allowedTokens = ["id", "sourceAsset", "sourceCode"]
        doc = """Specifies the attribute that should be consulted to get the 
        shader's implementation or its source code.

        * If set to "id", the "info:id" attribute's value is used to 
        determine the shader source from the shader registry.
        * If set to "sourceAsset", the resolved value of the "info:sourceAsset" 
        attribute corresponding to the desired implementation (or source-type)
        is used to locate the shader source.  A source asset file may also
        specify multiple shader definitions, so there is an optional attribute
        "info:sourceAsset:subIdentifier" whose value should be used to indicate
        a particular shader definition from a source asset file.
        * If set to "sourceCode", the value of "info:sourceCode" attribute 
        corresponding to the desired implementation (or source type) is used as 
        the shader source.
        """
        customData = {
            string apiName = "implementationSource"
        }
    )

    uniform token info:id (
        doc = """The id is an identifier for the type or purpose of the 
        shader. E.g.: Texture or FractalFloat.
        The use of this id will depend on the render target: some will turn it
        into an actual shader path, some will use it to generate shader source 
        code dynamically.
        
        \\sa SetShaderId()
        """
        customData = {
            string apiName = "id"
        }
    )
}

class "ConnectableAPI"
(
    inherits = </APISchemaBase>
    doc = """UsdShadeConnectableAPI is an API schema that provides a common
    interface for creating outputs and making connections between shading 
    parameters and outputs. The interface is common to all UsdShade schemas
    that support Inputs and Outputs, which currently includes UsdShadeShader,
    UsdShadeNodeGraph, and UsdShadeMaterial .

    One can construct a UsdShadeConnectableAPI directly from a UsdPrim, or
    from objects of any of the schema classes listed above.  If it seems
    onerous to need to construct a secondary schema object to interact with
    Inputs and Outputs, keep in mind that any function whose purpose is either
    to walk material/shader networks via their connections, or to create such
    networks, can typically be written entirely in terms of 
    UsdShadeConnectableAPI objects, without needing to care what the underlying
    prim type is.

    Additionally, the most common UsdShadeConnectableAPI behaviors
    (creating Inputs and Outputs, and making connections) are wrapped as
    convenience methods on the prim schema classes (creation) and 
    UsdShadeInput and UsdShadeOutput.
    """ 
    customData = {
        token apiSchemaType = "nonApplied"
        string extraIncludes = '''
#include "pxr/usd/usd/typed.h"
#include "pxr/usd/usdShade/input.h"
#include "pxr/usd/usdShade/output.h"
#include "pxr/usd/usdShade/tokens.h"
#include "pxr/usd/usdShade/types.h"'''
    }
)
{
}

class "MaterialBindingAPI"
(
    inherits = </APISchemaBase>
    doc = """UsdShadeMaterialBindingAPI is an API schema that provides an 
    interface for binding materials to prims or collections of prims 
    (represented by UsdCollectionAPI objects). 
    
    In the USD shading model, each renderable gprim computes a single 
    <b>resolved Material</b> that will be used to shade the gprim (exceptions, 
    of course, for gprims that possess UsdGeomSubsets, as each subset can be 
    shaded by a different Material).  A gprim <b>and each of its ancestor 
    prims</b> can possess, through the MaterialBindingAPI, both a 
    <b>direct</b> binding to a Material, and any number of 
    <b>collection-based</b> bindings to Materials; each binding can be generic 
    or declared for a particular <b>purpose</b>, and given a specific <b>binding 
    strength</b>. It is the process of "material resolution" (see 
    \\ref UsdShadeMaterialBindingAPI_MaterialResolution) that examines all of 
    these bindings, and selects the one Material that best matches the 
    client's needs.

    The intent of <b>purpose</b> is that each gprim should be able to resolve a 
    Material for any given purpose, which implies it can have differently bound 
    materials for different purposes. There are two <i>special</i> values of 
    <b>purpose</b> defined in UsdShade, although the API fully supports 
    specifying arbitrary values for it, for the sake of extensibility:
    <ul><li><b>UsdShadeTokens->full</b>: to be used when the purpose of the 
    render is entirely to visualize the truest representation of a scene, 
    considering all lighting and material information, at highest fidelity.</li>  
    <li><b>UsdShadeTokens->preview</b>: to be used when the render is in 
    service of a goal other than a high fidelity "full" render (such as scene
    manipulation, modeling, or realtime playback). Latency and speed are 
    generally of greater concern for preview renders, therefore preview 
    materials are generally designed to be "lighterweight" compared to full
    materials.</li></ul>
    A binding can also have no specific purpose at all, in which 
    case, it is considered to be the fallback or all-purpose binding (denoted 
    by the empty-valued token <b>UsdShadeTokens->allPurpose</b>). 

    The <b>purpose</b> of a material binding is encoded in the name of the 
    binding relationship. 
    <ul><li>
    In the case of a direct binding, the <i>allPurpose</i> binding is 
    represented by the relationship named <b>"material:binding"</b>. 
    Special-purpose direct bindings are represented by relationships named
    <b>"material:binding:<i>purpose</i></b>. A direct binding relationship 
    must have a single target path that points to a <b>UsdShadeMaterial</b>.</li>
    <li>
    In the case of a collection-based binding, the <i>allPurpose</i> binding is 
    represented by a relationship named 
    "material:binding:collection:<i>bindingName</i>", where 
    <b>bindingName</b> establishes an identity for the binding that is unique 
    on the prim. Attempting to establish two collection bindings of the same 
    name on the same prim will result in the first binding simply being 
    overridden. A special-purpose collection-based binding is represented by a 
    relationship named "material:binding:collection:<i>purpose:bindingName</i>".
    A collection-based binding relationship must have exacly two targets, one of 
    which should be a collection-path (see 
    \ref UsdCollectionAPI::GetCollectionPath()) and the other should point to a
    <b>UsdShadeMaterial</b>. In the future, we may allow a single collection 
    binding to target multiple collections, if we can establish a reasonable 
    round-tripping pattern for applications that only allow a single collection 
    to be associated with each Material.
    </li>
    </ul>

    <b>Note:</b> Both <b>bindingName</b> and <b>purpose</b> must be 
    non-namespaced tokens. This allows us to know the role of a binding 
    relationship simply from the number of tokens in it. 
    <ul><li><b>Two tokens</b>: the fallback, "all purpose", direct binding, 
    <i>material:binding</i></li>
    <li><b>Three tokens</b>: a purpose-restricted, direct, fallback binding, 
    e.g. material:binding:preview</li>
    <li><b>Four tokens</b>: an all-purpose, collection-based binding, e.g. 
    material:binding:collection:metalBits</li>
    <li><b>Five tokens</b>: a purpose-restricted, collection-based binding, 
    e.g. material:binding:collection:full:metalBits</li>
    </ul>

    A <b>binding-strength</b> value is used to specify whether a binding 
    authored on a prim should be weaker or stronger than bindings that appear 
    lower in namespace. We encode the binding strength with as token-valued 
    metadata <b>'bindMaterialAs'</b> for future flexibility, even though for 
    now, there are only two possible values:
    <i>UsdShadeTokens->weakerThanDescendants</i> and 
    <i>UsdShadeTokens->strongerThanDescendants</i>. When binding-strength is 
    not authored (i.e. empty) on a binding-relationship, the default behavior 
    matches UsdShadeTokens->weakerThanDescendants.

    \\note If a material binding relationship is a built-in property defined as 
    part of a typed prim's schema, a fallback value should not be provided for 
    it. This is because the "material resolution" algorithm only conisders 
    <i>authored</i> properties.
    """ 
    customData = {
        string extraIncludes = """
#include "pxr/usd/usd/collectionAPI.h"
#include "pxr/usd/usdGeom/subset.h"
#include "pxr/usd/usdShade/material.h"
#include <tbb/concurrent_unordered_map.h>"""
         dictionary schemaTokens = {
            dictionary materialBinding = {
                string value = "material:binding"
                string doc = """
                The relationship name on non-shading prims to
                denote a binding to a UsdShadeMaterial.
                """
            }
            dictionary materialBindingCollection = {
                string value = "material:binding:collection"
                string doc = """ 
                The relationship name on non-shading prims to
                denote a collection-based binding to a UsdShadeMaterial.
                """
            }
            dictionary allPurpose = {
                string value = ""
                string doc = """Possible value for the 'materialPurpose' parameter
                in the various methods available in UsdShadeMaterialBindingAPI.
                Its value is empty and its purpose is to represent a general 
                purpose material-binding that applies in the absence of a 
                specific-purpose binding.
                """
            }
            dictionary preview = {
                string doc = """Possible value for the 'materialPurpose' 
                parameter in UsdShadeMaterialBindingAPI, to be used when the 
                render is in service of a goal other than a high fidelity "full"
                render (such as scene manipulation, modeling, or realtime 
                playback). Latency and speed are generally of greater concern 
                for preview renders, therefore preview materials are generally 
                designed to be "lighterweight" compared to full materials.
                """
            }

            dictionary full = {
                string doc= """Possible value for the 'materialPurpose'
                parameter in UsdShadeMaterialBindingAPI, to be used when the
                purpose of the render is entirely about visualizing the truest
                representation of a scene, considering all lighting and material
                information, at highest fidelity.
                """
            }
            dictionary bindMaterialAs = {
                string doc = """Token valued metadata key authored on a material 
                binding relationship to indicate the strength of the binding 
                relative to bindings authored on descendants.
                """
            }
            dictionary weakerThanDescendants = {
                string doc = """Possible value for 'bindMaterialAs' metadata on the 
                collection-based material binding relationship. Indicates 
                that the binding represented by the relationship is weaker than 
                any bindings authored on the descendants."""
            }
            dictionary strongerThanDescendants = {
                string doc = """Possible value for 'bindMaterialAs' metadata on the 
                collection-based material binding relationship. Indicates 
                that the binding represented by the relationship is stronger than 
                any bindings authored on the descendants."""
            }
            dictionary fallbackStrength = {
                string doc = """Sentinal value to be used for 'bindMaterialAs' 
                metadata's default value. Clients should pass this in for the 
                'bindingStrength' argument to UsdShadeMaterialBindingAPI::Bind(),
                if they want to author the default value (weakerThanDescendants)
                sparsely. The value "fallbackStrength" never gets authored 
                into scene description."""
            }
        }
    }
)
{
    
}

class "CoordSysAPI"
(
    inherits = </APISchemaBase>
    doc = """UsdShadeCoordSysAPI provides a way to designate, name,
    and discover coordinate systems.

    Coordinate systems are implicitly established by UsdGeomXformable
    prims, using their local space.  That coordinate system may be
    bound (i.e., named) from another prim.  The binding is encoded
    as a single-target relationship in the "coordSys:" namespace.
    Coordinate system bindings apply to descendants of the prim
    where the binding is expressed, but names may be re-bound by
    descendant prims.

    Named coordinate systems are useful in shading workflows.
    An example is projection paint, which projects a texture
    from a certain view (the paint coordinate system).  Using
    the paint coordinate frame avoids the need to assign a UV
    set to the object, and can be a concise way to project
    paint across a collection of objects with a single shared
    paint coordinate system.

    This is a non-applied API schema.
    """
    customData = {
        token apiSchemaType = "nonApplied"
        string extraIncludes = '''
#include "pxr/usd/usdGeom/xformable.h"'''
        dictionary schemaTokens = {
            dictionary coordSys = {
                string value = "coordSys:"
                string doc = """Namespace prefix for relationships that
                bind coordinate systems."""
            }
        }
    }
)
{
}
{
    "Plugins": [
        {
            "Info": {
                "SdfMetadata": {
                    "payloadAssetDependencies": {
                        "appliesTo": "prims",
                        "displayGroup": "Pipeline",
                        "type": "asset[]"
                    }
                },
                "Types": {
                    "SdfFileFormat": {
                        "displayName": "Sdf file format base class",
                        "target": "sdf"
                    },
                    "SdfTextFileFormat": {
                        "bases": [
                            "SdfFileFormat"
                        ],
                        "displayName": "Sdf Text File Format",
                        "extensions": [
                            "sdf"
                        ],
                        "formatId": "sdf"
                    }
                }
            },
            "LibraryPath": "",
            "Name": "sdf",
            "ResourcePath": "resources",
            "Root": "..",
            "Type": "library"
        }
    ]
}
{
    "Plugins": [
        {
            "Info": {},
            "LibraryPath": "",
            "Name": "hd",
            "ResourcePath": "resources",
            "Root": "..",
            "Type": "library"
        }
    ]
}
# Portions of this file auto-generated by usdGenSchema.
# Edits will survive regeneration except for comments and
# changes to types with autoGenerated=true.
{
    "Plugins": [
        {
            "Info": {
                "Types": {
                    "UsdHydraDiscoveryPlugin" : {
                        "bases": ["NdrDiscoveryPlugin"],
                        "displayName": "Discovery plugin for deprecated hydra shaders."
                    }
                }
            }, 
            "LibraryPath": "", 
            "Name": "usdHydra", 
            "ResourcePath": "resources", 
            "Root": "..", 
            "Type": "library"
        }
    ]
}
#usda 1.0 

def Shader "HwPtexTexture_1" (
    sdrMetadata = {
        token role = "texture"
        token isPtex = "1"
    }
)
{
    uniform token info:id = "HwPtexTexture_1"
    uniform token info:implementationSource = "sourceAsset"

    # Add a dummy sourceAsset attribute with sourceType="glslfx", so that 
    # an entry gets created for this deprecated shader in the registry.
    uniform asset info:glslfx:sourceAsset = @./empty.glslfx@

    token inputs:faceIndexPrimvar = "ptexFaceIndex" (
        sdrMetadata = {
            token primvarProperty = "1"
        }
    )

    token inputs:faceOffsetPrimvar = "ptexFaceOffset" (
        sdrMetadata = {
            token primvarProperty = "1"
        }
    )

    asset inputs:file = @@ (
        doc = "Asset path to the file containg the image data."
    )

    float inputs:frame (
        doc = "The frame offset for animated textures."
    )

    float inputs:textureMemory (
        doc = """Amount of memory used to store the texture (in Mb). A value of 
        zero specifies the native resolution."""
    )

    int inputs:faceIndex (
        doc = """The Ptex face index from which to sample. By default, this
        parameter will be bound to the ptexFaceIndex primvar."""
    )

    int inputs:faceOffset (
        doc = """The Ptex face offset to be applied to the face index. By
        default, this parameter will be bound to the ptexFaceOffset primvar."""
    )

    float outputs:r ( 
        doc = "Outputs the red channel."
        sdrMetadata = {
            token swizzle = "x"
        }
    )

    float outputs:g (
        doc = "Outputs the green channel."
        sdrMetadata = {
            token swizzle = "y"
        }
    )

    float outputs:b (
        doc = "Outputs the blue channnel."
        sdrMetadata = {
            token swizzle = "z"
        }
    )

    float outputs:a (
        doc = "Outputs the alpha channnel."
        sdrMetadata = {
            token swizzle = "w"
        }
    )

    float3 outputs:rgb (
        doc = "Outputs the red, green and blue channels."
        sdrMetadata = {
            token swizzle = "xyz"
        }
    )

    float4 outputs:rgba (
        doc = "Outputs all 4 channels (red, green, blue and alpha)."
        sdrMetadata = {
            token swizzle = "xyzw"
        }
    )
}

def Shader "HwUvTexture_1" (
    sdrMetadata = {
        token role = "texture"
        token primvars = "uv"
    }
)
{
    uniform token info:id = "HwUvTexture_1"
    uniform token info:implementationSource = "sourceAsset"

    # Add a dummy sourceAsset attribute with sourceType="glslfx", so that 
    # an entry gets created for this deprecated shader in the registry.
    uniform asset info:glslfx:sourceAsset = @./empty.glslfx@

    asset inputs:file = @@ (
        doc = "Asset path to the file containg the image data."
    )

    float inputs:frame (
        doc = "The frame offset for animated textures."
    )

    float inputs:textureMemory (
        doc = """Amount of memory used to store the texture (in Mb). A value of 
        zero specifies the native resolution."""
    )

    float2 inputs:uv (
        doc = "The uv coordinates at which to sample the texture."
    )

    token inputs:wrapS (
        allowedTokens = ["clamp", "repeat", "mirror", "black"]
        doc = "Specifies the wrap mode for this texture."
    )

    token inputs:wrapT (
        allowedTokens = ["clamp", "repeat", "mirror", "black"]
        doc = "Specifies the wrap mode for this texture."
    )

    token inputs:minFilter (
        allowedTokens = ["nearest", "linear",
                         "linearMipmapLinear", "linearMipmapNearest",
                         "nearestMipmapLinear", "nearestMipmapNearest" ]
        doc = "Specifies the minification filter mode for this texture."
    )
    
    token inputs:magFilter (
        allowedTokens = ["nearest", "linear"]
        doc = "Specifies the magnification filter mode for this texture."
    )

    float4 inputs:fallback = (0.0, 0.0, 0.0, 1.0) (
        doc = """Fallback value to be used when no texture is connected."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )
}

def Shader "HwFieldReader_1" (
    sdrMetadata = {
        token role = "field"
    }
    doc = """Samples from a usdVol FieldAsset."""
)
{
    uniform asset info:glslfx:sourceAsset = @./empty.glslfx@
    uniform token info:implementationSource = "sourceAsset"
    token inputs:fieldname = "" (
        connectability = "interfaceOnly"
        doc = """Name of the field to be fetched from volume
                 (e.g., FOO if the relationship from the volume to field is called field::FOO)."""
        sdrMetadata = {
            token fieldProperty = "1"
        }
    )
}

def Shader "HwFieldReader_float" ( 
    inherits = </HwFieldReader_1>
)
{
    uniform token info:id = "HwFieldReader_float"
    float inputs:fallback = 0 (
        doc = "Fallback value to be returned when fetch failed."
        sdrMetadata = {
            token defaultInput = "1"
        }
    )
    float outputs:result (
        sdrMetadata = {
            token swizzle = "x"
        }
    )
}

def Shader "HwFieldReader_float2" (
    inherits = </HwFieldReader_1>
)
{
    uniform token info:id = "HwFieldReader_float2"
    float2 inputs:fallback = (0, 0) (
        doc = "Fallback value to be returned when fetch failed."
        sdrMetadata = {
            token defaultInput = "1"
        }
    )
    float2 outputs:result (
        sdrMetadata = {
            token swizzle = "xy"
        }
    )
}

def Shader "HwFieldReader_float3" (
    inherits = </HwFieldReader_1>
)
{
    uniform token info:id = "HwFieldReader_float3"
    float3 inputs:fallback = (0, 0, 0) (
        doc = "Fallback value to be returned when fetch failed."
        sdrMetadata = {
            token defaultInput = "1"
        }
    )
    float3 outputs:result (
        sdrMetadata = {
            token swizzle = "xyz"
        }
    )
}

def Shader "HwPrimvar_1" (
    sdrMetadata = {
        token role = "primvar"
    }
)
{
    uniform token info:id = "HwPrimvar_1"
    uniform token info:implementationSource = "sourceAsset"

    # Add a dummy sourceAsset attribute with sourceType="glslfx", so that 
    # an entry gets created for this deprecated shader in the registry.
    uniform asset info:glslfx:sourceAsset = @./empty.glslfx@

    token inputs:varname = "" (
        sdrMetadata = {
            bool primvarProperty = 1
        }
        doc = """The name of the primvar. Note that on the gprim, this primvar
        must follow the standard UsdGeom primvar declaration.        
        Further note that this name should not contain the UsdGeom primvar
        namespace prefix.
        """
    )
}
-- glslfx version 0.1

//
// Copyright 2018 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

-- configuration
{
    "techniques": {
        "default": {
        }
    }
}

-- This file is intentionally empty. 
{
    "Plugins": [
        {
            "Info": {
                "Types": {
                    "UsdShadersDiscoveryPlugin" : {
                        "bases": ["NdrDiscoveryPlugin"],
                        "displayName": "USD-based shader definition discovery plugin."
                    }
                },
                # Allow usdShaders/shaders to be accessible by hio/glslfx.cpp's 
                #   ShaderResourceRegistry
                "ShaderResources": "shaders"
            },
            "LibraryPath": "",
            "Name": "usdShaders",
            "ResourcePath": "resources",
            "Root": "..",
            "Type": "library"
        }
    ]
}
#usda 1.0

def Shader "UsdPreviewSurface" (
    doc = "Preview surface specification"
)
{
    uniform token info:id = "UsdPreviewSurface"
    uniform token info:implementationSource = "sourceAsset"

    # XXX: This doesn't resolve if it's defined as a search path.
    # Might require special resolver configuration, to include the resources
    # directory.
    uniform asset info:glslfx:sourceAsset = @./previewSurface.glslfx@

    # Outputs
    token outputs:surface (
        sdrMetadata = {
            string renderType = "terminal surface"
        }
    )
    token outputs:displacement (
        sdrMetadata = {
            string renderType = "terminal displacement"
        }
    )
 
    # Inputs
    color3f inputs:diffuseColor = (0.18, 0.18, 0.18) (
        doc = """Parameter used as diffuseColor when using the specular
                 workflow, when using metallic workflow this is interpreted
                 as albedo."""
    )

    color3f inputs:emissiveColor = (0.0, 0.0, 0.0) (
        doc = """Emissive component."""
    )

    int inputs:useSpecularWorkflow = 0 (
        connectability = "interfaceOnly"
        doc = """This node can fundamentally operate in two modes :
            Specular workflow where you provide a texture/value to the
            "specularColor" input. Or, Metallic workflow where you
            provide a texture/value to the "metallic" input."""
    )
 
    color3f inputs:specularColor = (0.0, 0.0, 0.0) (
        doc = """Used only in the specular workflow.
             Specular color to be used.
             This is the color at 0 incidence. Edge color is assumed white.
             Transition between the two colors according to Schlick fresnel 
             approximation."""
    )
 
    float inputs:metallic = 0.0 (
        doc = """Used only in the metalness workflow.
            1 for metallic surfaces and 0 for non-metallic.
            - If metallic is 1, then both F0 (reflectivity at 0 degree 
            incidence) and edge F90 reflectivity will simply be the Albedo.
            - If metallic is 0, then Albedo is ignored in the calculation of F0
            and F90; F0 is derived from ior via ( (1-ior)/(1+ior) )^2 and F90 is
            white. 
            In between, we interpolate."""
    )
 
    float inputs:roughness = 0.5 (
        doc = """Roughness for the specular lobe. The value ranges from 0 to 1, 
        which goes from a perfectly specular surface at 0.0 to maximum roughness 
        of the specular lobe. This value is usually squared before use with a 
        GGX or Beckmann lobe."""
    )
 
    float inputs:clearcoat = 0.0 (
        doc = """Second specular lobe amount. The color is white."""
    )
 
    float inputs:clearcoatRoughness = 0.01 (
        doc = """Roughness for the second specular lobe."""
    )
 
    float inputs:opacity = 1.0 (
        doc = """Opacity of the material."""
    )

    float inputs:opacityThreshold = 0.0 (
        connectability = "interfaceOnly"
        doc = """Threshold used to determine opacity values that will be
        considered fully transparent. A value of 0.0 indicates that no masking
        is applied to the opacity input, while a value greater than 0.0 indicates
        that rendering of the surface is limited to the areas where the opacity
        is greater or equal to that value. Note that when opacityThreshold is
        greater than zero, the opacity values less than the opacityThreshold will
        not be rendered, and the opacity values greater than or equal to the
        opacityThreshold will be fully visible."""
    )

    float inputs:ior = 1.5 (
        doc = """Index of Refraction to be used for translucent objects."""
    )

    normal3f inputs:normal = (0.0, 0.0, 1.0) (
        doc = """Expects normal in tangent space [(-1,-1,-1), (1,1,1)]
            This means your texture reader implementation should provide
            data to this node that is properly scaled and ready
            to be consumed as a tangent space normal."""
    )

    float inputs:displacement = 0.0 (
        doc = """Displacement in the direction of the normal. """
    )

    float inputs:occlusion = 1.0 (
        doc = """Occlusion signal. This provides extra information about the 
        occlusion of different parts of the mesh that this material is applied 
        to.  Occlusion only makes sense as a surface-varying signal, and 
        pathtracers will likely choose to ignore it.  An occlusion value of 0.0 
        means the surface point is fully occluded by other parts of the surface, 
        and a value of 1.0 means the surface point is completely unoccluded by 
        other parts of the surface. """
    )
}

def Shader "UsdUVTexture" (
    doc = """Texture Node Specification represents a node that can be used to 
    read UV textures, including tiled textures such as Mari UDIM's.
     
    Reads from a texture file and outputs one or more values. If the texture has
    8 bits per component, [0, 255] values will first be converted to floating 
    point in the range [0, 1] and then any transformations (bias, scale) 
    indicated  are applied. Otherwise any indicated transformation (bias, 
    scale) is just applied. If a single-channel texture is fed into a 
    UsdUVTexture, the r, g, and b components of the rgb output will repeat the 
    channel's value, while the single 'a' output will be set to 1.0. If a 
    two-channel texture is fed into a UsdUVTexture, the r, g, and b components 
    of the rgb output will repeat the first channel's value, while the single 
    'a' output will be set to the second channel's value. If a three-channel 
    texture is fed into a UsdUVTexture, the r, g, and b components of the rgb 
    outputs will contain the assigned texture channel's value, while the single 
    'a' output will be set to 1.0.
"""
    sdrMetadata = {
        token role = "texture"
    }
)
{
    uniform token info:id = "UsdUVTexture"
    uniform token info:implementationSource = "sourceAsset"
    uniform asset info:glslfx:sourceAsset = @./uvTexture.glslfx@

    asset inputs:file = @@ (
        connectability = "interfaceOnly"
        doc = """Path to the texture this node uses."""
    )

    float2 inputs:st = (0.0, 0.0) (
        doc = """This input provides the texture coordinates. It is usually 
                connected to a (primvar) node that will provide the texture 
                coords."""
    )

    token inputs:wrapS = "useMetadata" (
        allowedTokens = ["black", "clamp", "repeat", "mirror", "useMetadata"]
        connectability = "interfaceOnly"
        doc = """<options> black, clamp, repeat, mirror, useMetadata."""
    )

    token inputs:wrapT = "useMetadata" (
        allowedTokens = ["black", "clamp", "repeat", "mirror", "useMetadata"]
        connectability = "interfaceOnly"
        doc = """<options> black, clamp, repeat, mirror, useMetadata."""
    )

    float4 inputs:fallback = (0.0, 0.0, 0.0, 1.0) (
        doc = """Fallback value to be used when no texture is connected."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    float4 inputs:scale = (1.0, 1.0, 1.0, 1.0) (
        connectability = "interfaceOnly"
        doc = """Scale to be applied to all components of the texture. 
                 value * scale + bias"""
    )

    float4 inputs:bias = (0.0, 0.0, 0.0, 0.0) (
        connectability = "interfaceOnly"
        doc = """Bias to be applied to all components of the texture. 
                 value * scale + bias)"""
    )

    token inputs:sourceColorSpace = "auto" (
        connectability = "interfaceOnly"
        allowedTokens = ["raw", "sRGB", "auto"]
        doc = """<options> raw, sRGB, auto. Flag indicating the color
                 space in which the source texture is encoded."""
    )

    float outputs:r ( 
        doc = "Outputs the red channel."
        sdrMetadata = {
            token swizzle = "x"
        }
    )

    float outputs:g (
        doc = "Outputs the green channel."
        sdrMetadata = {
            token swizzle = "y"
        }
    )

    float outputs:b (
        doc = "Outputs the blue channnel."
        sdrMetadata = {
            token swizzle = "z"
        }
    )

    float outputs:a (
        doc = "Outputs the alpha channnel."
        sdrMetadata = {
            token swizzle = "w"
        }
    )

    float3 outputs:rgb (
        doc = "Outputs the red, green and blue channels."
        sdrMetadata = {
            token swizzle = "xyz"
        }
    )
}

class "UsdPrimvarReader" (
    sdrMetadata = {
        token role = "primvar"
    }
)
{
    uniform token info:implementationSource = "sourceAsset"
    uniform asset info:glslfx:sourceAsset = @./primvarReader.glslfx@
    string inputs:varname = "" (
        connectability = "interfaceOnly"
        doc = """Name of the primvar to be fetched from the geometry."""
        sdrMetadata = {
            token primvarProperty = "1"
        }
    )    
}

def Shader "UsdPrimvarReader_float" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_float"

    float inputs:fallback = 0.0 (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    float outputs:result
}

def Shader "UsdPrimvarReader_float2" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_float2"

    float2 inputs:fallback = (0.0, 0.0) (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    float2 outputs:result
}

def Shader "UsdPrimvarReader_float3" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_float3"

    float3 inputs:fallback = (0.0, 0.0, 0.0) (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    float3 outputs:result
}

def Shader "UsdPrimvarReader_float4" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_float4"

    float4 inputs:fallback = (0.0, 0.0, 0.0, 0.0) (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    float4 outputs:result
}

def Shader "UsdPrimvarReader_int" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_int"

    int inputs:fallback = 0 (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    int outputs:result
}

def Shader "UsdPrimvarReader_string" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_string"

    string inputs:fallback = "" (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    string outputs:result
}

def Shader "UsdPrimvarReader_normal" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_normal"

    normal3f inputs:fallback = (0.0, 0.0, 0.0) (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    normal3f outputs:result
}

def Shader "UsdPrimvarReader_point" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_point"

    point3f inputs:fallback = (0.0, 0.0, 0.0) (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    point3f outputs:result
}

def Shader "UsdPrimvarReader_vector" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_vector"

    vector3f inputs:fallback = (0.0, 0.0, 0.0) (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    vector3f outputs:result
}

def Shader "UsdPrimvarReader_matrix" (
    inherits = </UsdPrimvarReader>
)
{
    uniform token info:id = "UsdPrimvarReader_matrix"

    matrix4d inputs:fallback = ( (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1) ) (
        doc = """Fallback value to be returned when fetch failed."""
        sdrMetadata = {
            token defaultInput = "1"
        }
    )

    matrix4d outputs:result
}

def Shader "UsdTransform2d" (
    doc = """Transform 2d represents a node that can be used to
    transform 2d data (for instance, texture coordinates).
    The node applies the following transformation :
    in * scale * rotate + translation"""
    sdrMetadata = {
        token role = "math"
    }
)
{
    uniform token info:id = "UsdTransform2d"
    uniform token info:implementationSource = "sourceAsset"
    uniform asset info:glslfx:sourceAsset = @./transform2d.glslfx@
 
    float2 inputs:in = (0.0, 0.0) (
        doc = """This input provides the data. It is usually
                connected to a UsdPrimvarReader_float2 that
                will provide the data."""
    )

    float inputs:rotation = 0.0 (
        connectability = "interfaceOnly"
        doc = """Counter-clockwise rotation in degrees around the origin to be applied
        to all components of the data."""
    )

    float2 inputs:scale = (1.0, 1.0) (
        connectability = "interfaceOnly"
        doc = """Scale around the origin to be applied to all components of the data."""
    )

    float2 inputs:translation = (0.0, 0.0) (
        connectability = "interfaceOnly"
        doc = """Translation to be applied to all components of the data."""
    )

    float2 outputs:result (
        doc = "Outputs transformed float2 values."
    )
}
-- glslfx version 0.1

//
// Copyright 2018 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

-- configuration
{
    "techniques": {
        "default": {
            "displacementShader": {
                "source": [ "Preview.Displacement" ]
            },
            "surfaceShader": {
                "source": [ "Preview.LightStructures",
                            "Preview.Lighting",
                            "Preview.LightIntegration",
                            "Preview.NormalMapping",
                            "Preview.Surface" ]
            }
        }
    }
}


-- glsl Preview.Displacement

vec4
displacementShader(int index, vec4 Peye, vec3 Neye, vec4 patchCoord)
{
    // Calculate scalar displacement.
    float texDisplacement = HdGet_displacement(index).x;
    return Peye + vec4(Neye*texDisplacement, 0);
}


-- glsl Preview.Surface

vec4
surfaceShader(vec4 Peye, vec3 Neye, vec4 color, vec4 patchCoord)
{
    float clearcoatAmount    = HdGet_clearcoat().x;
    float clearcoatRoughness = HdGet_clearcoatRoughness().x;
    vec3 diffuseColor        = HdGet_diffuseColor().xyz;
    vec3 emissiveColor       = HdGet_emissiveColor().xyz;
    float ior                = HdGet_ior().x;
    float metallic           = HdGet_metallic().x;
    float occlusion          = HdGet_occlusion().x;
    float opacity            = HdGet_opacity().x;
    float opacityThreshold   = HdGet_opacityThreshold().x;
    float roughness          = HdGet_roughness().x;
    vec3 specularColor       = HdGet_specularColor().xyz;
    bool useSpecularWorkflow = (HdGet_useSpecularWorkflow().x == 1);

    vec3 clearcoatColor      = vec3(1.0);
    float specularAmount     = 1.0;

#ifdef HD_MATERIAL_TAG_MASKED   
    if (opacity < opacityThreshold) {
        discard;
    } 
    opacity = 1.0;
#endif            

    // Selection highlighting.
    vec4 colorAndOpacity = vec4(diffuseColor, opacity);
    diffuseColor = ApplyColorOverrides(colorAndOpacity).rgb;

    // Pre-multiply diffuse color by opacity if not done so already
#ifndef diffuseColor_IS_PREMULTIPLIED
    diffuseColor *= opacity;
#endif    

    // Evaluate all lights.
    vec3 c = evaluateLights(
        emissiveColor,
        diffuseColor,
        useSpecularWorkflow,
        ior,
        metallic,
        specularAmount,
        specularColor,
        roughness,
        clearcoatAmount,
        clearcoatColor,
        clearcoatRoughness,
        occlusion,
        Peye,
        perturbFragmentNormal(Peye.xyz, Neye));

    return vec4(c, colorAndOpacity.a);
}


-- glsl Preview.LightStructures

struct LightingContributions
{
    vec3 diffuse;
    vec3 specular;
};


-- glsl Preview.Lighting

#define PI 3.1415
#define EPSILON 0.001


float
SchlickFresnel(float EdotH)
{
    return pow(max(0.0, 1.0 - EdotH), 5.0);
}

float
NormalDistribution(float specularRoughness, float NdotH)
{
    float alpha = specularRoughness * specularRoughness;
    float alpha2 = alpha * alpha;
    float NdotH2 = NdotH * NdotH;
    float DDenom = (NdotH2 * (alpha2 - 1.0)) + 1.0;
    DDenom *= DDenom;
    DDenom *= PI;
    float D = (alpha2 + EPSILON) / DDenom;
    return D;
}

float
Geometric(
        float specularRoughness,
        float NdotL,
        float NdotE,
        float NdotH,
        float EdotH)
{
    float alpha = specularRoughness * specularRoughness;
    float k = alpha * 0.5;
    float G = NdotE / (NdotE * (1.0 - k) + k);
    G *= NdotL / (NdotL * (1.0 - k) + k);
    return G;
}

vec3
evaluateDirectDiffuse()
{
    return vec3(1.0 / PI);
}

vec3
evaluateDirectSpecular(
        vec3 specularColorF0,
        vec3 specularColorF90,
        float specularRoughness,
        float fresnel,
        float NdotL,
        float NdotE,
        float NdotH,
        float EdotH)
{
    vec3 F = mix(specularColorF0, specularColorF90, fresnel);
    float D = NormalDistribution(specularRoughness, NdotH);
    float G = Geometric(specularRoughness, NdotL, NdotE, NdotH, EdotH);
    vec3 RNum = F * G * D;
    float RDenom = 4.0f * NdotL * NdotE + EPSILON;
    return RNum / RDenom;
}

LightingContributions
evaluateLight(
        vec3 diffuseColor,
        bool useSpecularWorkflow,
        float ior,
        float metallic,
        float specularAmount,
        vec3 specularColor,
        float specularRoughness,
        float clearcoatAmount,
        vec3 clearcoatColor,
        float clearcoatRoughness,
        float occlusion,
        float NdotL,
        float NdotE,
        float NdotH,
        float EdotH,
        vec3 lightDiffuseIrradiance,
        vec3 lightSpecularIrradiance)
{
    specularRoughness = max(0.001, specularRoughness);
    clearcoatRoughness = max(0.001, clearcoatRoughness);

    float fresnel = SchlickFresnel(EdotH);

    // Evaluate diffuse
    vec3 d = diffuseColor * evaluateDirectDiffuse();

    // Evaluate specular first lobe
    vec3 s1 = vec3(0.0);
    const float R = (1.0 - ior) / (1.0 + ior);
    if (specularAmount > 0.0) {
        vec3 F0 = specularColor;
        vec3 F90 = vec3(1.0);

        if (!useSpecularWorkflow) {
            vec3 specColor = mix(vec3(1.0), diffuseColor, metallic);
            F0 = mix(R * R * specColor, specColor, metallic);
            F90 = specColor;

            // For metallic workflows, pure metals have no diffuse
            d *= 1.0 - metallic;
        }

        s1 = specularAmount * evaluateDirectSpecular(
             F0,                          // Specular color 0
             F90,                         // Specular color 90
             specularRoughness,           // Roughness
             fresnel,                     // Fresnel
             NdotL, NdotE, NdotH, EdotH); // Dot products needed for lights

        // Adjust the diffuse so glazing angles have less diffuse
        d *= (1.0 - mix(F0, F90, fresnel));
    }

    // Evaluate clearcoat
    vec3 s2 = vec3(0.0);
    if (clearcoatAmount > 0.0) {
        s2 = clearcoatAmount * evaluateDirectSpecular(
             R * R * clearcoatColor,      // Clearcoat color 0
             clearcoatColor,              // Clearcoat color 90
             clearcoatRoughness,          // Roughness
             fresnel,                     // Fresnel
             NdotL, NdotE, NdotH, EdotH); // Dot products needed for lights
    }

    LightingContributions lightingContrib;

    lightingContrib.diffuse =
        occlusion * NdotL * d * lightDiffuseIrradiance;

    lightingContrib.specular =
        occlusion * NdotL * (s1 + s2) * lightSpecularIrradiance;

    return lightingContrib;
}


-- glsl Preview.LightIntegration

vec2 projectToLatLong(vec3 sample3D)
{
    // project spherical coord onto latitude-longitude map with
    // latitude: +y == pi/2 and longitude: +z == 0, +x == pi/2
    vec2 coord = vec2((atan(sample3D.z, sample3D.x) + 0.5 * PI) / (2.0 * PI),
                      acos(sample3D.y) / PI);
    return coord;
}

mat4 GetDomeLightTransform(mat4 worldToLightTransform)
{
    // transform from view space to light space
    mat4 worldToViewInverse = GetWorldToViewInverseMatrix();
    return worldToLightTransform * worldToViewInverse;
}

vec3
evaluateIndirectLighting(
        vec3 diffuseColor,
        vec3 specularColor,
        vec3 Neye,
        vec3 Reye,
        float NdotE,
        float EdotH,
        float ior,
        float metallic,
        float occlusion,
        float roughness,
        bool useSpecularWorkflow,
        float clearcoatAmount, 
        vec3 clearcoatColor, 
        float clearcoatRoughness,
        mat4 worldToLightTransform)
{
    vec3 indirect = vec3(0.0);

#ifdef HD_HAS_domeLightIrradiance
    vec3 F0 = specularColor;
    vec3 F90 = vec3(1.0);
    vec3 d = diffuseColor;
    const float R = (1.0 - ior) / (1.0 + ior);
    if (!useSpecularWorkflow) {
        vec3 specColor = mix(vec3(1.0), diffuseColor, metallic);
        F0 = mix(R * R * specColor, specColor, metallic);
        F90 = specColor;

        // For metallic workflows, pure metals have no diffuse
        d *= 1.0 - metallic;
    }
    // Adjust the diffuse so glazing angles have less diffuse
    float fresnel = SchlickFresnel(EdotH);
    vec3 F = mix(F0, F90, fresnel);
    d *= (1.0 - F);

    mat4 transformationMatrix = GetDomeLightTransform(worldToLightTransform);

    // Diffuse Component
    vec3 dir = normalize((transformationMatrix * vec4(Neye,0.0)).xyz);
    vec2 coord = projectToLatLong(dir);
    vec3 diffuse = HdGet_domeLightIrradiance(coord).rgb;

    // Specular Component 
    const float MAX_REFLECTION_LOD = 
        textureQueryLevels(HdGetSampler_domeLightPrefilter());
    float lod = roughness * MAX_REFLECTION_LOD;
    vec3 Rdir = normalize((transformationMatrix * vec4(Reye,0.0)).xyz);
    vec2 Rcoord = projectToLatLong(Rdir);
    vec3 prefilter = textureLod(HdGetSampler_domeLightPrefilter(),
                                Rcoord, lod).rgb;

    vec2 brdf = HdGet_domeLightBRDF(vec2(NdotE, roughness)).rg;

    vec3 specular = prefilter * (F * brdf.x + brdf.y);

    // Clearcoat Component
    vec3 clearcoat = vec3(0.0);
    if (clearcoatAmount > 0.0) {
        const vec3 clearcoatF = clearcoatAmount * mix(
            R * R * clearcoatColor, // Clearcoat F0
            clearcoatColor,         // Clearcoat F90
            fresnel);
        lod = clearcoatRoughness * MAX_REFLECTION_LOD;
        prefilter = textureLod(HdGetSampler_domeLightPrefilter(),
                                Rcoord, lod).rgb;
        clearcoat = prefilter * (clearcoatF * brdf.x + brdf.y);
    }

    // Indirect Lighting
    indirect = (d * diffuse + specular + clearcoat) * occlusion;
#endif

    return indirect;
}

vec3
evaluateLights(
        vec3 emissiveColor,
        vec3 diffuseColor,
        bool useSpecularWorkflow,
        float ior,
        float metallic,
        float specularAmount,
        vec3 specularColor,
        float specularRoughness,
        float clearcoatAmount,
        vec3 clearcoatColor,
        float clearcoatRoughness,
        float occlusion,
        vec4 Peye,
        vec3 Neye)
{
    vec3 n = Neye;
    vec3 e = normalize(-Peye.xyz);
    float NdotE = max(0.0, dot(n, e));

    vec3 Reye = reflect(-e, n);

    vec3 directLight = vec3(0.0);
    vec3 indirectLight = vec3(0.0);

#if NUM_LIGHTS > 0
    for (int i = 0; i < NUM_LIGHTS; ++i) {

        // Calculate necessary vector information for lighting
        vec4 Plight = (lightSource[i].isIndirectLight)
                        ? vec4(0,0,0,1)
                        : lightSource[i].position;
        vec3 l = (Plight.w == 0.0)
                    ? normalize(Plight.xyz)
                    : normalize(Plight - Peye).xyz;
        vec3 h = normalize(e + l);
        float NdotL = max(0.0, dot(n, l));
        float NdotH = max(0.0, dot(n, h));
        float EdotH = max(0.0, dot(e, h));

        // Calculate light intensity
        float atten = lightDistanceAttenuation(Peye, i);
        float spot = lightSpotAttenuation(l, i);

        // Calculate the shadow factor
        float shadow = 1.0;
    #if USE_SHADOWS
        shadow = (lightSource[i].hasShadow) ?
            shadowing(/*lightIndex=*/i, Peye) : 1.0;
    #endif

        float intensity = atten * spot * shadow;

        vec3 lightDiffuseIrradiance = intensity * lightSource[i].diffuse.rgb;
        vec3 lightSpecularIrradiance = intensity * lightSource[i].specular.rgb;

        LightingContributions lightingContrib = evaluateLight(
            diffuseColor,
            useSpecularWorkflow,
            ior,
            metallic,
            specularAmount,
            specularColor,
            specularRoughness,
            clearcoatAmount,
            clearcoatColor,
            clearcoatRoughness,
            occlusion,
            NdotL,
            NdotE,
            NdotH,
            EdotH,
            lightDiffuseIrradiance,
            lightSpecularIrradiance);

        // calculate the indirect light (DomeLight)
        if (lightSource[i].isIndirectLight) {

            indirectLight = evaluateIndirectLighting(diffuseColor,
                                    specularColor, Neye, Reye, NdotE,
                                    EdotH, ior, metallic, occlusion,
                                    specularRoughness, useSpecularWorkflow,
                                    clearcoatAmount, clearcoatColor, 
                                    clearcoatRoughness, 
                                    lightSource[i].worldToLightTransform);
        }
        // all other light sources contribute to the direct lighting
        else {
            directLight += (lightingContrib.diffuse + lightingContrib.specular);
        }
    }
#endif

    return (emissiveColor + directLight + indirectLight);
}


-- glsl Preview.NormalMapping

vec3
perturbFragmentNormal(vec3 P, vec3 N)
{
#ifdef HD_HAS_COORD_normal
    // Calculation of TBN matrix and terminology based on "Surface 
    // Gradient-Based Bump Mapping Framework" (2020)
    vec3 Nt = normalize(HdGet_normal().xyz);
    vec2 st = HdGetCoord_normal().st;

    // Get screen space derivatives of position
    vec3 dPdx = dFdx(P);
    vec3 dPdy = dFdy(P);

    // Ensure position derivatives are perpendicular to N
    vec3 sigmaX = dPdx - dot(dPdx, N) * N;
    vec3 sigmaY = dPdy - dot(dPdy, N) * N;

    float flipSign = dot(dPdy, cross(N, dPdx)) < 0 ? -1 : 1;

    // Get screen space derivatives of st
    vec2 dSTdx = dFdx(st);
    vec2 dSTdy = dFdy(st);

    // Get determinant and determinant sign of st matrix
    float det = dot(dSTdx, vec2(dSTdy.y, -dSTdy.x));
    float signDet = det < 0 ? -1 : 1;

    // Get first column of inv st matrix
    // Don't divide by det, but scale by its sign
    vec2 invC0 = signDet * vec2(dSTdy.y, -dSTdx.y);

    vec3 T = sigmaX * invC0.x + sigmaY * invC0.y;

    if (abs(det) > 0) {
        T = normalize(T);
    }

    vec3 B = (signDet * flipSign) * cross(N, T);

    mat3 TBN = mat3(T, B, N);
    return normalize(TBN * Nt);
#endif
    return N;
}


-- glslfx version 0.1

//
// Copyright 2018 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

-- configuration
{
    "techniques": {
        "default": {
        }
    }
}

-- This file is intentionally empty. 
-- glslfx version 0.1

//
// Copyright 2018 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

-- configuration
{
    "techniques": {
        "default": {
        }
    }
}

-- This file is intentionally empty. 
-- glslfx version 0.1

//
// Copyright 2020 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

-- configuration
{
    "techniques": {
        "default": {
        }
    }
}

-- This file is intentionally empty. 
{
    "Plugins": [
        {
            "Info": {
                "SdfMetadata": {
                    "faceIndexPrimvar": {
                        "appliesTo": [
                            "attributes"
                        ],
                        "default": "ptexFaceIndex",
                        "documentation": "Specifies an array of face indices used for ptex mapping",
                        "type": "token"
                    },
                    "faceOffsetPrimvar": {
                        "appliesTo": [
                            "attributes"
                        ],
                        "default": "ptexFaceOffset",
                        "documentation": "Specifies the ptex face index offset for aggregated ptex files",
                        "type": "token"
                    },
                    "uvPrimvar": {
                        "appliesTo": [
                            "attributes"
                        ],
                        "default": "",
                        "documentation": "Specifies the UV primvar for texture mapping",
                        "type": "token"
                    }
                },
                "Types": {
                    "UsdImagingBasisCurvesAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "BasisCurves"
                    },
                    "UsdImagingCameraAdapter": {
                        "bases": [
                            "UsdImagingPrimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "Camera"
                    },
                    "UsdImagingCapsuleAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "Capsule"
                    },
                    "UsdImagingConeAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "Cone"
                    },
                    "UsdImagingCoordSysAdapter": {
                        "bases": [
                            "UsdImagingPrimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "coordSys"
                    },
                    "UsdImagingCubeAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "Cube"
                    },
                    "UsdImagingCylinderAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "Cylinder"
                    },
                    "UsdImagingHermiteCurvesAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "HermiteCurves"
                    },
                    "UsdImagingMaterialAdapter" : {
                        "bases": ["UsdImagingPrimAdapter"],
                        "isInternal": true,
                        "primTypeName": "Material"
                    },
                    "UsdImagingMeshAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "Mesh"
                    },
                    "UsdImagingNurbsCurvesAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "NurbsCurves"
                    },
                    "UsdImagingNurbsPatchAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "NurbsPatch"
                    },
                    "UsdImagingPointsAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "Points"
                    },
                    "UsdImagingPointInstancerAdapter": {
                        "bases": [
                            "UsdImagingPrimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "PointInstancer"
                    },
                    "UsdImagingSphereAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "Sphere"
                    },
                    "UsdImagingVolumeAdapter": {
                        "bases": [
                            "UsdImagingGprimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "Volume"
                    },
                    "UsdImagingLightAdapter": {
                        "bases": [
                            "UsdImagingPrimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "LightAPI",
                        "includeDerivedPrimTypes" : true 
                    },
                    "UsdImagingLightFilterAdapter": {
                        "bases": [
                            "UsdImagingPrimAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "LightFilter",
                        "includeDerivedPrimTypes" : true 
                    },
                    "UsdImagingDomeLightAdapter": {
                        "bases": [
                            "UsdImagingLightAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "DomeLight"
                    },
                    "UsdImagingRectLightAdapter": {
                        "bases": [
                            "UsdImagingLightAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "RectLight"
                    },
                    "UsdImagingSphereLightAdapter": {
                        "bases": [
                            "UsdImagingLightAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "SphereLight"
                    },
                    "UsdImagingCylinderLightAdapter": {
                        "bases": [
                            "UsdImagingLightAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "CylinderLight"
                    },
                    "UsdImagingDiskLightAdapter": {
                        "bases": [
                            "UsdImagingLightAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "DiskLight"
                    },
                    "UsdImagingDistantLightAdapter": {
                        "bases": [
                            "UsdImagingLightAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "DistantLight"
                    },
                    "UsdImagingPluginLightAdapter": {
                        "bases": [
                            "UsdImagingLightAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "PluginLight"
                    },
                    "UsdImagingGeometryLightAdapter": {
                        "bases": [
                            "UsdImagingLightAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "GeometryLight"
                    },
                    "UsdImagingPortalLightAdapter": {
                        "bases": [
                            "UsdImagingLightAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "PortalLight"
                    },
                    "UsdImagingPluginLightFilterAdapter": {
                        "bases": [
                            "UsdImagingLightFilterAdapter"
                        ],
                        "isInternal": true,
                        "primTypeName": "PluginLightFilter"
                    }
                }
            },
            "LibraryPath": "",
            "Name": "usdImaging",
            "ResourcePath": "resources",
            "Root": "..",
            "Type": "library"
        }
    ]
}
# Portions of this file auto-generated by usdGenSchema.
# Edits will survive regeneration except for comments and
# changes to types with autoGenerated=true.
{
    "Plugins": [
        {
            "Info": {
                "SdfMetadata": {
                    "apiSchemas": {
                        "appliesTo": "prims", 
                        "type": "tokenlistop"
                    }, 
                    "clipSets": {
                        "appliesTo": [
                            "prims"
                        ], 
                        "type": "stringlistop"
                    }, 
                    "clips": {
                        "appliesTo": [
                            "prims"
                        ], 
                        "type": "dictionary"
                    }, 
                    "fallbackPrimTypes": {
                        "appliesTo": [
                            "layers"
                        ], 
                        "type": "dictionary"
                    }
                }, 
                "Types": {
                    "UsdAPISchemaBase": {
                        "autoGenerated": true, 
                        "bases": [
                            "UsdSchemaBase"
                        ], 
                        "schemaKind": "abstractBase"
                    }, 
                    "UsdClipsAPI": {
                        "alias": {
                            "UsdSchemaBase": "ClipsAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "nonAppliedAPI"
                    }, 
                    "UsdCollectionAPI": {
                        "alias": {
                            "UsdSchemaBase": "CollectionAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "multipleApplyAPI"
                    }, 
                    "UsdModelAPI": {
                        "alias": {
                            "UsdSchemaBase": "ModelAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "nonAppliedAPI"
                    }, 
                    "UsdSchemaBase": {}, 
                    "UsdTyped": {
                        "bases": [
                            "UsdSchemaBase"
                        ]
                    }, 
                    "UsdUsdFileFormat": {
                        "bases": [
                            "SdfFileFormat"
                        ], 
                        "displayName": "USD File Format", 
                        "extensions": [
                            "usd"
                        ], 
                        "formatId": "usd", 
                        "primary": true, 
                        "target": "usd"
                    }, 
                    "UsdUsdaFileFormat": {
                        "bases": [
                            "SdfTextFileFormat"
                        ], 
                        "displayName": "USD Text File Format", 
                        "extensions": [
                            "usda"
                        ], 
                        "formatId": "usda", 
                        "primary": true, 
                        "target": "usd"
                    }, 
                    "UsdUsdcFileFormat": {
                        "bases": [
                            "SdfFileFormat"
                        ], 
                        "displayName": "USD Crate File Format", 
                        "extensions": [
                            "usdc"
                        ], 
                        "formatId": "usdc", 
                        "primary": true, 
                        "target": "usd"
                    }, 
                    "UsdUsdzFileFormat": {
                        "bases": [
                            "SdfFileFormat"
                        ], 
                        "displayName": "USDZ File Format", 
                        "extensions": [
                            "usdz"
                        ], 
                        "formatId": "usdz", 
                        "primary": true, 
                        "target": "usd"
                    }, 
                    "Usd_UsdzResolver": {
                        "bases": [
                            "ArPackageResolver"
                        ], 
                        "extensions": [
                            "usdz"
                        ]
                    }
                }
            }, 
            "LibraryPath": "", 
            "Name": "usd", 
            "ResourcePath": "resources", 
            "Root": "..", 
            "Type": "library"
        }
    ]
}
#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
    customLayerData = {
        dictionary multipleApplyAPISchemas = {
            string CollectionAPI = "collection"
        }
    }
)

class "APISchemaBase" (
    doc = """The base class for all API schemas.

    An API schema provides an interface to a prim's qualities, but does not
    specify a typeName for the underlying prim. The prim's qualities include 
    its inheritance structure, attributes, relationships etc. Since it cannot
    provide a typeName, an API schema is considered to be non-concrete. 
    
    To auto-generate an API schema using usdGenSchema, simply leave the 
    typeName empty and make it inherit from \"/APISchemaBase\" or from another 
    API schema. See UsdModelAPI, UsdClipsAPI and UsdCollectionAPI for examples.
    
    API schemas are classified into applied and non-applied API schemas. 
    The author of an API schema has to decide on the type of API schema 
    at the time of its creation by setting customData['apiSchemaType'] in the 
    schema definition (i.e. in  the associated primSpec inside the schema.usda 
    file).  UsdAPISchemaBase implements methods that are used to record the 
    application of an API schema on a USD prim.

    If an API schema only provides an interface to set certain core bits of 
    metadata (like UsdModelAPI, which sets model kind and UsdClipsAPI, which 
    sets clips-related metadata) OR if the API schema can apply to any type of 
    prim or only to a known fixed set of prim types OR if there is no use of 
    recording the application of the API schema, in such cases, it would be 
    better to make it a non-applied API schema. Examples of non-applied API 
    schemas include UsdModelAPI, UsdClipsAPI, UsdShadeConnectableAPI and
    UsdGeomPrimvarsAPI.

    If there is a need to discover (or record) whether a prim contains or 
    subscribes to a given API schema, it would be advantageous to make the API 
    schema be \"applied\". In general, API schemas that add one or more properties 
    to a prim should be tagged as applied API schemas. A public Apply() method 
    is generated for applied API schemas by usdGenSchema. An applied API schema 
    must be applied to a prim via a call to the generated Apply() method, for 
    the schema object to evaluate to true when converted to a bool using the 
    explicit bool conversion operator. Examples of applied API schemas include
    UsdCollectionAPI, UsdGeomModelAPI and UsdGeomMotionAPI

    \\anchor UsdAPISchemaBase_SingleVsMultipleApply
    \\name Single vs. Multiple Apply API Schemas
    
    Applied API schemas can further be classified into single-apply and 
    multiple-apply API schemas. As the name suggests, a single-apply API schema 
    can only be applied once to a prim. A multiple-apply API schema can be 
    applied multiple times with different 'instanceName' values. An example of 
    a multiple-apply API schema is UsdCollectionAPI, where the API schema is 
    applied to a prim once for every collection owned by the prim. 
    
    \\note An applied API schema can only inherit from another applied API 
    schema or directly from APISchemaBase. Similarly, a non-applied API schema 
    can only inherit from a non-applied API Schema or directly from 
    APISchemaBase. 'usdGenSchema' attempts to issue a warning if it detects 
    an incompatibility.

    \\note A multiple-apply API schema may not inherit from a single-apply API 
    schema and vice versa. 

    \\note When the bool-conversion operator is invoked on an applied API 
    schema, it evaluates to true only if the application of the API schema has
    been recorded on the prim via a call to the auto-generated Apply() method.
    
    """
)
{
}

class "ModelAPI" (
    doc = """UsdModelAPI is an API schema that provides an interface to a prim's
    model qualities, if it does, in fact, represent the root prim of a model.
    
    The first and foremost model quality is its kind, i.e. the metadata 
    that establishes it as a model (See KindRegistry).  UsdModelAPI provides
    various methods for setting and querying the prim's kind, as well as
    queries (also available on UsdPrim) for asking what category of model
    the prim is.  See \"Kind and Model-ness\".
    
    UsdModelAPI also provides access to a prim's \"assetInfo\"
    data.  While any prim can host assetInfo, it is common that published
    (referenced) assets are packaged as models, therefore it is convenient
    to provide access to the one from the other.
    
    \\todo establish an _IsCompatible() override that returns IsModel()
    \\todo GetModelInstanceName()
    """
)
{
}

class "CollectionAPI" (
    doc = """ This is a general purpose API schema, used to describe a 
    collection of heterogeneous objects within the scene. \"Objects\" here may be 
    prims or properties belonging to prims or other collections. It's an add-on 
    schema that can be applied many times to a prim with different collection 
    names. 

    A collection allows an enumeration of a set of paths to include and a 
    set of paths to exclude.  Whether the descendants of an included
    path are members of a collection are decided by its expansion rule
    (see below).  If the collection excludes paths that are not descendents
    of included paths, the collection implicitly includes the root path
    &lt;/&gt;.  If such a collection also includes paths that are not
    descendants of the excluded paths, it is considered invalid, since
    the intention is ambiguous.

    All the properties authored by the schema are namespaced under
    \"collection:\". The given name of the collection provides additional 
    namespacing for the various per-collection properties, which include the 
    following:

    <ul><li><b>uniform token collection:<i>collectionName</i>:expansionRule</b> - 
    specified how the paths that are included in the collection must be expanded 
    to determine its members. Possible values include:
        <ul>
        <li><b>explicitOnly</b> - only paths in the includes rel targets and not 
        in the excludes rel targets belong to the collection.
        </li>
        <li><b>expandPrims</b> - all the prims at or below the includes rel-
        targets (and not under the excludes rel-targets) belong to the 
        collection.  Any property paths included in the collection would, of 
        course, also be honored. This is the default behavior as it satisfies 
        most use cases.
        </li>
        <li><b>expandPrimsAndProperties</b> - like expandPrims, but also 
        includes all properties on all matched prims.  We're still not quite 
        sure what the use cases are for this, but you can use it to capture a 
        whole lot of UsdObjects very concisely.
        </li>
        </ul>
    </li>
    <li><b>bool collection:<i>collectionName</i>:includeRoot</b> - boolean
    attribute indicating whether the pseudo-root path &lt;/&gt; should
    be counted as one of the included target paths.  The fallback is false.
    This separate attribute is required because relationships cannot
    directly target the root.
    <li><b>rel collection:<i>collectionName</i>:includes</b> - specifies a list 
    of targets that are included in the collection. This can target prims or 
    properties directly. A collection can insert the rules of another
    collection by making its <i>includes</i> relationship target the
    <b>collection:{collectionName}</b> property on the owning prim of the
    collection to be included.
    Such a property may not (and typically does not) exist on the UsdStage, but 
    it is the path that is used to refer to the collection.
    It is important to note that including another collection does not
    guarantee the contents of that collection will be in the final collection;
    instead, the rules are merged.  This means, for example, an exclude
    entry may exclude a portion of the included collection.
    When a collection includes one or more collections, the order in which 
    targets are added to the includes relationship may become significant, if 
    there are conflicting opinions about the same path. Targets that are added 
    later are considered to be stronger than earlier targets for the same path.
    </li>
    <li><b>rel collection:<i>collectionName</i>:excludes</b> - specifies a list 
    of targets that are excluded below the <b>included</b> paths in this 
    collection. This can target prims or properties directly, but <b>cannot
    target another collection</b>. This is to keep the membership determining 
    logic simple, efficient and easier to reason about. Finally, it is invalid 
    for a collection to exclude paths that are not included in it. The presence
    of such \"orphaned\" excluded paths will not affect the set of paths included 
    in the collection, but may affect the performance of querying membership of 
    a path in the collection (see UsdCollectionAPI::MembershipQuery::IsPathIncluded) 
    or of enumerating the objects belonging to the collection (see 
    UsdCollectionAPI::GetIncludedObjects).
    </li></ul>

    <b>Implicit inclusion</b>

    In some scenarios it is useful to express a collection that includes
    everything except certain paths.  To support this, a collection
    that has an exclude that is not a descendent of any include
    will include the root path &lt;/&gt;.

    <b>Creating collections in C++</b>
    
    \\snippet examples.cpp ApplyCollections
    """
)
{
    rel excludes (
        doc = '''Specifies a list of targets that are excluded below
        the included paths in this collection. This can target prims or
        properties directly, but cannot target another collection. This is to
        keep the membership determining logic simple, efficient and easier to
        reason about. Finally, it is invalid for a collection to exclude
        paths that are not included in it. The presence of such "orphaned"
        excluded paths will not affect the set of paths included in the
        collection, but may affect the performance of querying membership of 
        a path in the collection (see
        UsdCollectionAPI::MembershipQuery::IsPathIncluded) 
        or of enumerating the objects belonging to the collection (see 
        UsdCollectionAPI::GetIncludedObjects).'''
    )
    uniform token expansionRule = "expandPrims" (
        allowedTokens = ["explicitOnly", "expandPrims", "expandPrimsAndProperties"]
        doc = """Specifies how the paths that are included in
        the collection must be expanded to determine its members."""
    )
    uniform bool includeRoot (
        doc = """Boolean attribute indicating whether the pseudo-root
        path &lt;/&gt; should be counted as one of the included target
        paths.  The fallback is false.  This separate attribute is
        required because relationships cannot directly target the root."""
    )
    rel includes (
        doc = """Specifies a list of targets that are included in the collection.
        This can target prims or properties directly. A collection can insert
        the rules of another collection by making its <i>includes</i>
        relationship target the <b>collection:{collectionName}</b> property on
        the owning prim of the collection to be included"""
    )
}

class "ClipsAPI" (
    doc = """ UsdClipsAPI is an API schema that provides an interface to
    a prim's clip metadata. Clips are a \"value resolution\" feature that 
    allows one to specify a sequence of usd files (clips) to be consulted, 
    over time, as a source of varying overrides for the prims at and 
    beneath this prim in namespace.
            
    SetClipAssetPaths() establishes the set of clips that can be consulted.
    SetClipActive() specifies the ordering of clip application over time 
    (clips can be repeated), while SetClipTimes() specifies time-mapping
    from stage-time to clip-time for the clip active at a given stage-time,
    which allows for time-dilation and repetition of clips. 
    Finally, SetClipPrimPath() determines the path within each clip that will 
    map to this prim, i.e. the location within the clip at which we will look
    for opinions for this prim. 

    The clip asset paths, times and active metadata can also be specified 
    through template clip metadata. This can be desirable when your set of 
    assets is very large, as the template metadata is much more concise. 
    SetClipTemplateAssetPath() establishes the asset identifier pattern of the 
    set of clips to be consulted. SetClipTemplateStride(), 
    SetClipTemplateEndTime(), and SetClipTemplateStartTime() specify the range 
    in which USD will search, based on the template. From the set of resolved 
    asset paths, times and active will be derived internally.

    A prim may have multiple \"clip sets\" -- named sets of clips that each
    have their own values for the metadata described above. For example, 
    a prim might have a clip set named \"Clips_1\" that specifies some group
    of clip asset paths, and another clip set named \"Clips_2\" that uses
    an entirely different set of clip asset paths. These clip sets are 
    composed across composition arcs, so clip sets for a prim may be
    defined in multiple sublayers or references, for example. Individual
    metadata for a given clip set may be sparsely overridden.
                
    Important facts about clips:            
    - Within the layerstack in which clips are established, the           
    opinions within the clips will be weaker than any local opinions
    in the layerstack, but em stronger than varying opinions coming across
    references and variants.            
    - We will never look for metadata or default opinions in clips            
    when performing value resolution on the owning stage, since these           
    quantities must be time-invariant.          
            
    This leads to the common structure in which we reference a model asset
    on a prim, and then author clips at the same site: the asset reference
    will provide the topology and unvarying data for the model, while the 
    clips will provide the time-sampled animation.

    For further information, see \\ref Usd_Page_ValueClips
    """
)
{
}

#usda 1.0
(
    "This file describes the USD primitive schemata and drives code generation."
)

def "GLOBAL" (
    customData = {
        string libraryName      = "usd"
        string libraryPath      = "pxr/usd/usd"
        # string libraryPrefix  = "Usd"
        # string tokensPrefix   = "Usd"
        dictionary libraryTokens = {
            dictionary apiSchemas = {
                string doc = """
                A listop metadata containing the API schemas which have
                been applied to this prim, using the Apply() method on
                the particular schema class. 
                """
            }
            dictionary fallbackPrimTypes = {
                string doc = """
                A dictionary metadata that maps the name of a concrete schema
                prim type to an ordered list of schema prim types to use instead
                if the schema prim type doesn't exist in version of USD being
                used.
                """
            }
        }
    }
)
{
}

class "Typed" 
(
    doc = """The base class for all \\em typed schemas (those that can impart a
    typeName to a UsdPrim), and therefore the base class for all
    concrete, instantiable "IsA" schemas.
       
    UsdTyped implements a typeName-based query for its override of
    UsdSchemaBase::_IsCompatible().  It provides no other behavior."""
)
{
}

class "APISchemaBase"
(
    doc = """The base class for all \\em API schemas.

    An API schema provides an interface to a prim's qualities, but does not
    specify a typeName for the underlying prim. The prim's qualities include 
    its inheritance structure, attributes, relationships etc. Since it cannot
    provide a typeName, an API schema is considered to be non-concrete. 
    
    To auto-generate an API schema using usdGenSchema, simply leave the 
    typeName empty and make it inherit from "/APISchemaBase" or from another 
    API schema. See UsdModelAPI, UsdClipsAPI and UsdCollectionAPI for examples.
    
    API schemas are classified into applied and non-applied API schemas. 
    The author of an API schema has to decide on the type of API schema 
    at the time of its creation by setting customData['apiSchemaType'] in the 
    schema definition (i.e. in  the associated primSpec inside the schema.usda 
    file).  UsdAPISchemaBase implements methods that are used to record the 
    application of an API schema on a USD prim.

    If an API schema only provides an interface to set certain core bits of 
    metadata (like UsdModelAPI, which sets model kind and UsdClipsAPI, which 
    sets clips-related metadata) OR if the API schema can apply to any type of 
    prim or only to a known fixed set of prim types OR if there is no use of 
    recording the application of the API schema, in such cases, it would be 
    better to make it a non-applied API schema. Examples of non-applied API 
    schemas include UsdModelAPI, UsdClipsAPI, UsdShadeConnectableAPI and
    UsdGeomPrimvarsAPI.

    If there is a need to discover (or record) whether a prim contains or 
    subscribes to a given API schema, it would be advantageous to make the API 
    schema be "applied". In general, API schemas that add one or more properties 
    to a prim should be tagged as applied API schemas. A public Apply() method 
    is generated for applied API schemas by usdGenSchema. An applied API schema 
    must be applied to a prim via a call to the generated Apply() method, for 
    the schema object to evaluate to true when converted to a bool using the 
    explicit bool conversion operator. Examples of applied API schemas include
    UsdCollectionAPI, UsdGeomModelAPI and UsdGeomMotionAPI

    \\anchor UsdAPISchemaBase_SingleVsMultipleApply
    \\name Single vs. Multiple Apply API Schemas
    
    Applied API schemas can further be classified into single-apply and 
    multiple-apply API schemas. As the name suggests, a single-apply API schema 
    can only be applied once to a prim. A multiple-apply API schema can be 
    applied multiple times with different 'instanceName' values. An example of 
    a multiple-apply API schema is UsdCollectionAPI, where the API schema is 
    applied to a prim once for every collection owned by the prim. 
    
    \\note An applied API schema can only inherit from another applied API 
    schema or directly from APISchemaBase. Similarly, a non-applied API schema 
    can only inherit from a non-applied API Schema or directly from 
    APISchemaBase. 'usdGenSchema' attempts to issue a warning if it detects 
    an incompatibility.

    \\note A multiple-apply API schema may not inherit from a single-apply API 
    schema and vice versa. 

    \\note When the bool-conversion operator is invoked on an applied API 
    schema, it evaluates to true only if the application of the API schema has
    been recorded on the prim via a call to the auto-generated Apply() method.
    
    """
    customData = {
        string fileName = "apiSchemaBase"
    }
)
{
}

class "ModelAPI" 
(
    inherits = </APISchemaBase>
    doc = """UsdModelAPI is an API schema that provides an interface to a prim's
    model qualities, if it does, in fact, represent the root prim of a model.
    
    The first and foremost model quality is its \\em kind, i.e. the metadata 
    that establishes it as a model (See KindRegistry).  UsdModelAPI provides
    various methods for setting and querying the prim's kind, as well as
    queries (also available on UsdPrim) for asking what category of model
    the prim is.  See \\ref Usd_ModelKind "Kind and Model-ness".
    
    UsdModelAPI also provides access to a prim's \\ref Usd_Model_AssetInfo "assetInfo"
    data.  While any prim \\em can host assetInfo, it is common that published
    (referenced) assets are packaged as models, therefore it is convenient
    to provide access to the one from the other.
    
    \\todo establish an _IsCompatible() override that returns IsModel()
    \\todo GetModelInstanceName()
    """
    customData = {
        string apiSchemaType = "nonApplied"
    }
)
{
}

class "CollectionAPI"
(
    inherits = </APISchemaBase>
    doc = """ This is a general purpose API schema, used to describe a 
    collection of heterogeneous objects within the scene. "Objects" here may be 
    prims or properties belonging to prims or other collections. It's an add-on 
    schema that can be applied many times to a prim with different collection 
    names. 

    A collection allows an enumeration of a set of paths to include and a 
    set of paths to exclude.  Whether the descendants of an included
    path are members of a collection are decided by its expansion rule
    (see below).  If the collection excludes paths that are not descendents
    of included paths, the collection implicitly includes the root path
    &lt;/&gt;.  If such a collection also includes paths that are not
    descendants of the excluded paths, it is considered invalid, since
    the intention is ambiguous.

    All the properties authored by the schema are namespaced under
    "collection:". The given name of the collection provides additional 
    namespacing for the various per-collection properties, which include the 
    following:

    <ul><li><b>uniform token collection:<i>collectionName</i>:expansionRule</b> - 
    specified how the paths that are included in the collection must be expanded 
    to determine its members. Possible values include:
        <ul>
        <li><b>explicitOnly</b> - only paths in the includes rel targets and not 
        in the excludes rel targets belong to the collection.
        </li>
        <li><b>expandPrims</b> - all the prims at or below the includes rel-
        targets (and not under the excludes rel-targets) belong to the 
        collection.  Any property paths included in the collection would, of 
        course, also be honored. This is the default behavior as it satisfies 
        most use cases.
        </li>
        <li><b>expandPrimsAndProperties</b> - like expandPrims, but also 
        includes all properties on all matched prims.  We're still not quite 
        sure what the use cases are for this, but you can use it to capture a 
        whole lot of UsdObjects very concisely.
        </li>
        </ul>
    </li>
    <li><b>bool collection:<i>collectionName</i>:includeRoot</b> - boolean
    attribute indicating whether the pseudo-root path &lt;/&gt; should
    be counted as one of the included target paths.  The fallback is false.
    This separate attribute is required because relationships cannot
    directly target the root.
    <li><b>rel collection:<i>collectionName</i>:includes</b> - specifies a list 
    of targets that are included in the collection. This can target prims or 
    properties directly. A collection can insert the rules of another
    collection by making its <i>includes</i> relationship target the
    <b>collection:{collectionName}</b> property on the owning prim of the
    collection to be included.
    Such a property may not (and typically does not) exist on the UsdStage, but 
    it is the path that is used to refer to the collection.
    It is important to note that including another collection does not
    guarantee the contents of that collection will be in the final collection;
    instead, the rules are merged.  This means, for example, an exclude
    entry may exclude a portion of the included collection.
    When a collection includes one or more collections, the order in which 
    targets are added to the includes relationship may become significant, if 
    there are conflicting opinions about the same path. Targets that are added 
    later are considered to be stronger than earlier targets for the same path.
    </li>
    <li><b>rel collection:<i>collectionName</i>:excludes</b> - specifies a list 
    of targets that are excluded below the <b>included</b> paths in this 
    collection. This can target prims or properties directly, but <b>cannot
    target another collection</b>. This is to keep the membership determining 
    logic simple, efficient and easier to reason about. Finally, it is invalid 
    for a collection to exclude paths that are not included in it. The presence
    of such "orphaned" excluded paths will not affect the set of paths included 
    in the collection, but may affect the performance of querying membership of 
    a path in the collection (see UsdCollectionAPI::MembershipQuery::IsPathIncluded) 
    or of enumerating the objects belonging to the collection (see 
    UsdCollectionAPI::GetIncludedObjects).
    </li></ul>

    <b>Implicit inclusion</b>

    In some scenarios it is useful to express a collection that includes
    everything except certain paths.  To support this, a collection
    that has an exclude that is not a descendent of any include
    will include the root path &lt;/&gt;.

    <b>Creating collections in C++</b>
    
    \\snippet examples.cpp ApplyCollections
    """

    customData = {
        string extraIncludes = """
#include "pxr/usd/usd/collectionMembershipQuery.h"
#include "pxr/usd/usd/primFlags.h"
#include "pxr/usd/usd/tokens.h"
"""
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix  = "collection"
        dictionary schemaTokens = {
            dictionary exclude = {
                string doc = """
                This is the token used to exclude a path from a collection. 
                Although it is not a possible value for the "expansionRule"
                attribute, it is used as the expansionRule for excluded paths 
                in UsdCollectionAPI::MembershipQuery::IsPathIncluded.
                """
            }
        }
    }
)
{
    uniform token expansionRule = "expandPrims" (
        allowedTokens = ["explicitOnly", "expandPrims", "expandPrimsAndProperties"]
        doc = """Specifies how the paths that are included in
        the collection must be expanded to determine its members."""
    )
    uniform bool includeRoot (
        doc = """Boolean attribute indicating whether the pseudo-root
        path &lt;/&gt; should be counted as one of the included target
        paths.  The fallback is false.  This separate attribute is
        required because relationships cannot directly target the root."""
    )
    rel includes (
        doc = """Specifies a list of targets that are included in the collection.
        This can target prims or properties directly. A collection can insert
        the rules of another collection by making its <i>includes</i>
        relationship target the <b>collection:{collectionName}</b> property on
        the owning prim of the collection to be included"""
    )
    rel excludes (
        doc = """Specifies a list of targets that are excluded below
        the included paths in this collection. This can target prims or
        properties directly, but cannot target another collection. This is to
        keep the membership determining logic simple, efficient and easier to
        reason about. Finally, it is invalid for a collection to exclude
        paths that are not included in it. The presence of such "orphaned"
        excluded paths will not affect the set of paths included in the
        collection, but may affect the performance of querying membership of 
        a path in the collection (see
        UsdCollectionAPI::MembershipQuery::IsPathIncluded) 
        or of enumerating the objects belonging to the collection (see 
        UsdCollectionAPI::GetIncludedObjects)."""
    )
}

class "ClipsAPI"
(
    inherits = </APISchemaBase>
    doc = """ UsdClipsAPI is an API schema that provides an interface to
    a prim's clip metadata. Clips are a "value resolution" feature that 
    allows one to specify a sequence of usd files (clips) to be consulted, 
    over time, as a source of varying overrides for the prims at and 
    beneath this prim in namespace.
            
    SetClipAssetPaths() establishes the set of clips that can be consulted.
    SetClipActive() specifies the ordering of clip application over time 
    (clips can be repeated), while SetClipTimes() specifies time-mapping
    from stage-time to clip-time for the clip active at a given stage-time,
    which allows for time-dilation and repetition of clips. 
    Finally, SetClipPrimPath() determines the path within each clip that will 
    map to this prim, i.e. the location within the clip at which we will look
    for opinions for this prim. 

    The clip asset paths, times and active metadata can also be specified 
    through template clip metadata. This can be desirable when your set of 
    assets is very large, as the template metadata is much more concise. 
    SetClipTemplateAssetPath() establishes the asset identifier pattern of the 
    set of clips to be consulted. SetClipTemplateStride(), 
    SetClipTemplateEndTime(), and SetClipTemplateStartTime() specify the range 
    in which USD will search, based on the template. From the set of resolved 
    asset paths, times and active will be derived internally.

    A prim may have multiple "clip sets" -- named sets of clips that each
    have their own values for the metadata described above. For example, 
    a prim might have a clip set named "Clips_1" that specifies some group
    of clip asset paths, and another clip set named "Clips_2" that uses
    an entirely different set of clip asset paths. These clip sets are 
    composed across composition arcs, so clip sets for a prim may be
    defined in multiple sublayers or references, for example. Individual
    metadata for a given clip set may be sparsely overridden.
                
    Important facts about clips:            
    \\li Within the layerstack in which clips are established, the           
    opinions within the clips will be \\em weaker than any local opinions
    in the layerstack, but \em stronger than varying opinions coming across
    references and variants.            
    \\li We will never look for metadata or default opinions in clips            
    when performing value resolution on the owning stage, since these           
    quantities must be time-invariant.          
            
    This leads to the common structure in which we reference a model asset
    on a prim, and then author clips at the same site: the asset reference
    will provide the topology and unvarying data for the model, while the 
    clips will provide the time-sampled animation.

    For further information, see \\ref Usd_Page_ValueClips
    """
    customData = {
        token apiSchemaType = "nonApplied"
        dictionary schemaTokens = {
            dictionary clips = {
              string doc = """
              Dictionary that contains the definition of the clip sets on
              this prim. See \\ref UsdClipsAPI::GetClips.
              """
            }

            dictionary clipSets = {
              string doc = """
              ListOp that may be used to affect how opinions from
              clip sets are applied during value resolution. 
              See \\ref UsdClipsAPI::GetClipSets.
              """
            }
        }
    }
)
{
}
//
// Copyright 2017 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//
#ifndef {{ Upper(libraryName) }}_API_H
#define {{ Upper(libraryName) }}_API_H

#include "pxr/base/arch/export.h"

#if defined(PXR_STATIC)
#   define {{ Upper(libraryName) }}_API
#   define {{ Upper(libraryName) }}_API_TEMPLATE_CLASS(...)
#   define {{ Upper(libraryName) }}_API_TEMPLATE_STRUCT(...)
#   define {{ Upper(libraryName) }}_LOCAL
#else
#   if defined({{ Upper(libraryName) }}_EXPORTS)
#       define {{ Upper(libraryName) }}_API ARCH_EXPORT
#       define {{ Upper(libraryName) }}_API_TEMPLATE_CLASS(...) ARCH_EXPORT_TEMPLATE(class, __VA_ARGS__)
#       define {{ Upper(libraryName) }}_API_TEMPLATE_STRUCT(...) ARCH_EXPORT_TEMPLATE(struct, __VA_ARGS__)
#   else
#       define {{ Upper(libraryName) }}_API ARCH_IMPORT
#       define {{ Upper(libraryName) }}_API_TEMPLATE_CLASS(...) ARCH_IMPORT_TEMPLATE(class, __VA_ARGS__)
#       define {{ Upper(libraryName) }}_API_TEMPLATE_STRUCT(...) ARCH_IMPORT_TEMPLATE(struct, __VA_ARGS__)
#   endif
#   define {{ Upper(libraryName) }}_LOCAL ARCH_HIDDEN
#endif

#endif
{
    "Plugins": [
        {
            "Info": {
                "Types": {
                }
            }, 
            "LibraryPath": "@PLUG_INFO_LIBRARY_PATH@", 
            "Name": "{{ libraryName }}", 
            "ResourcePath": "@PLUG_INFO_RESOURCE_PATH@", 
            "Root": "@PLUG_INFO_ROOT@", 
            "Type": "library"
        }
    ]
}
//
// Copyright 2016 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//
#include "{{ libraryPath }}/{{ cls.GetHeaderFile() }}"
#include "pxr/usd/usd/schemaRegistry.h"
#include "pxr/usd/usd/typed.h"
{% if cls.isApi %}
#include "pxr/usd/usd/tokens.h"
{% endif %}

#include "pxr/usd/sdf/types.h"
#include "pxr/usd/sdf/assetPath.h"

{% if useExportAPI %}
{{ namespaceOpen }}

{% endif %}
// Register the schema with the TfType system.
TF_REGISTRY_FUNCTION(TfType)
{
    TfType::Define<{{ cls.cppClassName }},
        TfType::Bases< {{ cls.parentCppClassName }} > >();
    
{% if cls.isConcrete %}
    // Register the usd prim typename as an alias under UsdSchemaBase. This
    // enables one to call
    // TfType::Find<UsdSchemaBase>().FindDerivedByName("{{ cls.usdPrimTypeName }}")
    // to find TfType<{{ cls.cppClassName }}>, which is how IsA queries are
    // answered.
    TfType::AddAlias<UsdSchemaBase, {{ cls.cppClassName }}>("{{ cls.usdPrimTypeName }}");
{% endif %}
}

{% if cls.isApi %}
TF_DEFINE_PRIVATE_TOKENS(
    _schemaTokens,
    ({{ cls.primName }})
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}
    ({{ cls.propertyNamespacePrefix }})
{% endif %}
);

{% endif %}
/* virtual */
{{ cls.cppClassName }}::~{{ cls.cppClassName }}()
{
}

{% if not cls.isAPISchemaBase %}
/* static */
{{ cls.cppClassName }}
{{ cls.cppClassName }}::Get(const UsdStagePtr &stage, const SdfPath &path)
{
    if (!stage) {
        TF_CODING_ERROR("Invalid stage");
        return {{ cls.cppClassName }}();
    }
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}
    TfToken name;
    if (!Is{{ cls.usdPrimTypeName }}Path(path, &name)) {
        TF_CODING_ERROR("Invalid {{ cls.propertyNamespacePrefix }} path <%s>.", path.GetText());
        return {{ cls.cppClassName }}();
    }
    return {{ cls.cppClassName }}(stage->GetPrimAtPath(path.GetPrimPath()), name);
{% else %}
    return {{ cls.cppClassName }}(stage->GetPrimAtPath(path));
{% endif %}
}

{% if cls.isMultipleApply %}
{{ cls.cppClassName }}
{{ cls.cppClassName }}::Get(const UsdPrim &prim, const TfToken &name)
{
    return {{ cls.cppClassName }}(prim, name);
}

{% endif %}
{% endif %}
{% if cls.isConcrete %}
/* static */
{{ cls.cppClassName }}
{{ cls.cppClassName }}::Define(
    const UsdStagePtr &stage, const SdfPath &path)
{
    static TfToken usdPrimTypeName("{{ cls.usdPrimTypeName }}");
    if (!stage) {
        TF_CODING_ERROR("Invalid stage");
        return {{ cls.cppClassName }}();
    }
    return {{ cls.cppClassName }}(
        stage->DefinePrim(path, usdPrimTypeName));
}
{% endif %}
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}

/* static */
bool 
{{ cls.cppClassName }}::IsSchemaPropertyBaseName(const TfToken &baseName)
{
    static TfTokenVector attrsAndRels = {
{% for attrName in cls.attrOrder %}
{% set attr = cls.attrs[attrName] %}
        {{ tokensPrefix }}Tokens->{{ attr.name }},
{% endfor %}
{% for relName in cls.relOrder %}
{% set rel = cls.rels[relName] %}
        {{ tokensPrefix }}Tokens->{{ rel.name }},
{% endfor %}
    };

    return find(attrsAndRels.begin(), attrsAndRels.end(), baseName)
            != attrsAndRels.end();
}

/* static */
bool
{{ cls.cppClassName }}::Is{{ cls.usdPrimTypeName }}Path(
    const SdfPath &path, TfToken *name)
{
    if (!path.IsPropertyPath()) {
        return false;
    }

    std::string propertyName = path.GetName();
    TfTokenVector tokens = SdfPath::TokenizeIdentifierAsTokens(propertyName);

    // The baseName of the {{ cls.usdPrimTypename }} path can't be one of the 
    // schema properties. We should validate this in the creation (or apply)
    // API.
    TfToken baseName = *tokens.rbegin();
    if (IsSchemaPropertyBaseName(baseName)) {
        return false;
    }

    if (tokens.size() >= 2
        && tokens[0] == _schemaTokens->{{ cls.propertyNamespacePrefix }}) {
        *name = TfToken(propertyName.substr(
            _schemaTokens->{{ cls.propertyNamespacePrefix }}.GetString().size() + 1));
        return true;
    }

    return false;
}
{% endif %}

/* virtual */
UsdSchemaKind {{ cls.cppClassName }}::_GetSchemaKind() const
{
    return {{ cls.cppClassName }}::schemaKind;
}
{% if cls.isAppliedAPISchema %}

/* static */
bool
{% if not cls.isMultipleApply %}
{{ cls.cppClassName }}::CanApply(
    const UsdPrim &prim, std::string *whyNot)
{% else %}
{{ cls.cppClassName }}::CanApply(
    const UsdPrim &prim, const TfToken &name, std::string *whyNot)
{% endif %}
{
{% if cls.isMultipleApply %}
    return prim.CanApplyAPI<{{ cls.cppClassName }}>(name, whyNot);
{% else %}
    return prim.CanApplyAPI<{{ cls.cppClassName }}>(whyNot);
{% endif %}
}

/* static */
{{ cls.cppClassName }}
{% if not cls.isMultipleApply %}
{{ cls.cppClassName }}::Apply(const UsdPrim &prim)
{% else %}
{{ cls.cppClassName }}::Apply(const UsdPrim &prim, const TfToken &name)
{% endif %}
{
{% if cls.isMultipleApply %}
    if (prim.ApplyAPI<{{ cls.cppClassName }}>(name)) {
        return {{ cls.cppClassName }}(prim, name);
    }
{% else %}
    if (prim.ApplyAPI<{{ cls.cppClassName }}>()) {
        return {{ cls.cppClassName }}(prim);
    }
{% endif %}
    return {{ cls.cppClassName }}();
}
{% endif %}

/* static */
const TfType &
{{ cls.cppClassName }}::_GetStaticTfType()
{
    static TfType tfType = TfType::Find<{{ cls.cppClassName }}>();
    return tfType;
}

/* static */
bool 
{{ cls.cppClassName }}::_IsTypedSchema()
{
    static bool isTyped = _GetStaticTfType().IsA<UsdTyped>();
    return isTyped;
}

/* virtual */
const TfType &
{{ cls.cppClassName }}::_GetTfType() const
{
    return _GetStaticTfType();
}
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}

/// Returns the property name prefixed with the correct namespace prefix, which
/// is composed of the the API's propertyNamespacePrefix metadata and the
/// instance name of the API.
static inline
TfToken
_GetNamespacedPropertyName(const TfToken instanceName, const TfToken propName)
{
    TfTokenVector identifiers =
        {_schemaTokens->{{ cls.propertyNamespacePrefix }}, instanceName, propName};
    return TfToken(SdfPath::JoinIdentifier(identifiers));
}
{% endif %}

{% for attrName in cls.attrOrder %}
{% set attr = cls.attrs[attrName] %}
{# Only emit Create/Get API and doxygen if apiName is not empty string. #}
{% if attr.apiName != '' %}
{% if attr.apiGet != "custom" %}
UsdAttribute
{{ cls.cppClassName }}::Get{{ Proper(attr.apiName) }}Attr() const
{
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}
    return GetPrim().GetAttribute(
        _GetNamespacedPropertyName(
            GetName(),
            {{ tokensPrefix }}Tokens->{{ attr.name }}));
{% else %}
    return GetPrim().GetAttribute({{ tokensPrefix }}Tokens->{{ attr.name }});
{% endif %}
}
{% endif %}

UsdAttribute
{{ cls.cppClassName }}::Create{{ Proper(attr.apiName) }}Attr(VtValue const &defaultValue, bool writeSparsely) const
{
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}
    return UsdSchemaBase::_CreateAttr(
                       _GetNamespacedPropertyName(
                            GetName(),
                           {{ tokensPrefix }}Tokens->{{ attr.name }}),
{% else %}
    return UsdSchemaBase::_CreateAttr({{ tokensPrefix }}Tokens->{{ attr.name }},
{% endif %}
                       {{ attr.usdType }},
                       /* custom = */ {{ "true" if attr.custom else "false" }},
                       {{ attr.variability }},
                       defaultValue,
                       writeSparsely);
}

{% endif %}
{% endfor %}
{% for relName in cls.relOrder %}
{% set rel = cls.rels[relName] %}
{# Only emit Create/Get API and doxygen if apiName is not empty string. #}
{% if rel.apiName != '' %}
{% if rel.apiGet != "custom" %}
UsdRelationship
{{ cls.cppClassName }}::Get{{ Proper(rel.apiName) }}Rel() const
{
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}
    return GetPrim().GetRelationship(
        _GetNamespacedPropertyName(
            GetName(),
            {{ tokensPrefix }}Tokens->{{ rel.name }}));
{% else %}
    return GetPrim().GetRelationship({{ tokensPrefix }}Tokens->{{ rel.name }});
{% endif %}
}
{% endif %}

UsdRelationship
{{ cls.cppClassName }}::Create{{ Proper(rel.apiName) }}Rel() const
{
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}
    return GetPrim().CreateRelationship(
                       _GetNamespacedPropertyName(
                           GetName(),
                           {{ tokensPrefix }}Tokens->{{ rel.name }}),
{% else %}
    return GetPrim().CreateRelationship({{ tokensPrefix }}Tokens->{{rel.name}},
{% endif %}
                       /* custom = */ {{ "true" if rel.custom else "false" }});
}

{% endif %}
{% endfor %}
{% if cls.attrOrder|length > 0 %}
namespace {
static inline TfTokenVector
{% if cls.isMultipleApply %}
_ConcatenateAttributeNames(
    const TfToken instanceName,
    const TfTokenVector& left,
    const TfTokenVector& right)
{% else %}
_ConcatenateAttributeNames(const TfTokenVector& left,const TfTokenVector& right)
{% endif %}
{
    TfTokenVector result;
    result.reserve(left.size() + right.size());
    result.insert(result.end(), left.begin(), left.end());
{% if cls.isMultipleApply %}

    for (const TfToken attrName : right) {
        result.push_back(
            _GetNamespacedPropertyName(instanceName, attrName));
    }
{% endif %}
    result.insert(result.end(), right.begin(), right.end());
    return result;
}
}

{% endif %}
/*static*/
const TfTokenVector&
{% if cls.isMultipleApply %}
{{ cls.cppClassName }}::GetSchemaAttributeNames(
    bool includeInherited, const TfToken instanceName)
{% else %}
{{ cls.cppClassName }}::GetSchemaAttributeNames(bool includeInherited)
{% endif %}
{
{% if cls.attrOrder|length > 0 %}
    static TfTokenVector localNames = {
{% for attrName in cls.attrOrder %}
{% set attr = cls.attrs[attrName] %}
        {{ tokensPrefix }}Tokens->{{ attr.name }},
{% endfor %}
    };
{% if cls.isMultipleApply %}
    static TfTokenVector allNames =
        _ConcatenateAttributeNames(
            instanceName,
{# The schema generator has already validated whether our parent is #}
{# a multiple apply schema or UsdSchemaBaseAPI, choose the correct function #}
{# depending on the situation #}
{% if cls.parentCppClassName == "UsdAPISchemaBase" %}
            {{ cls.parentCppClassName }}::GetSchemaAttributeNames(true),
{% else %}
            {{ cls.parentCppClassName }}::GetSchemaAttributeNames(true, instanceName),
{% endif %}
            localNames);
{% else %}
    static TfTokenVector allNames =
        _ConcatenateAttributeNames(
            {{ cls.parentCppClassName }}::GetSchemaAttributeNames(true),
            localNames);
{% endif %}
{% else %}
    static TfTokenVector localNames;
    static TfTokenVector allNames =
        {{ cls.parentCppClassName }}::GetSchemaAttributeNames(true);
{% endif %}

    if (includeInherited)
        return allNames;
    else
        return localNames;
}

{% if useExportAPI %}
{{ namespaceClose }}

{% endif %}
// ===================================================================== //
// Feel free to add custom code below this line. It will be preserved by
// the code generator.
{% if useExportAPI %}
//
// Just remember to wrap code in the appropriate delimiters:
// '{{ namespaceOpen }}', '{{ namespaceClose }}'.
{% endif %}
// ===================================================================== //
// --(BEGIN CUSTOM CODE)--

//
// Copyright 2016 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//
#ifndef {{ Upper(libraryName) }}_GENERATED_{{ Upper(cls.className) }}_H
#define {{ Upper(libraryName) }}_GENERATED_{{ Upper(cls.className) }}_H

/// \file {{ libraryName }}/{{ cls.GetHeaderFile() }}

{% if useExportAPI %}
#include "pxr/pxr.h"
#include "{{ libraryPath }}/api.h"
{% endif %}
#include "{{ cls.parentLibPath }}/{{ cls.GetParentHeaderFile() }}"
#include "pxr/usd/usd/prim.h"
#include "pxr/usd/usd/stage.h"
{% if cls.tokens -%}
#include "{{ libraryPath }}/tokens.h"
{% endif %}
{% if cls.extraIncludes -%}
{{ cls.extraIncludes }}
{% endif %}

#include "pxr/base/vt/value.h"

#include "pxr/base/gf/vec3d.h"
#include "pxr/base/gf/vec3f.h"
#include "pxr/base/gf/matrix4d.h"

#include "pxr/base/tf/token.h"
#include "pxr/base/tf/type.h"

{% if useExportAPI %}
{{ namespaceOpen }}

{% endif %}
class SdfAssetPath;

// -------------------------------------------------------------------------- //
// {{ Upper(cls.usdPrimTypeName) }}{{' ' * (74 - cls.usdPrimTypeName|count)}} //
// -------------------------------------------------------------------------- //

/// \class {{ cls.cppClassName }}
///
{% if cls.doc -%}
/// {{ cls.doc }}
{% endif %}
{% if cls.doc and hasTokenAttrs -%}
///
{%endif%}
{% if hasTokenAttrs -%}
/// For any described attribute \em Fallback \em Value or \em Allowed \em Values below
/// that are text/tokens, the actual token is published and defined in \ref {{ tokensPrefix }}Tokens.
/// So to set an attribute to the value "rightHanded", use {{ tokensPrefix }}Tokens->rightHanded
/// as the value.
{% endif %}
///
class {{ cls.cppClassName }} : public {{ cls.parentCppClassName }}
{
public:
    /// Compile time constant representing what kind of schema this class is.
    ///
    /// \sa UsdSchemaKind
    static const UsdSchemaKind schemaKind = {{cls.schemaKindEnumValue }};

{% if cls.isMultipleApply %}
    /// Construct a {{ cls.cppClassName }} on UsdPrim \p prim with
    /// name \p name . Equivalent to
    /// {{ cls.cppClassName }}::Get(
    ///    prim.GetStage(),
    ///    prim.GetPath().AppendProperty(
    ///        "{{ cls.propertyNamespacePrefix }}:name"));
    ///
    /// for a \em valid \p prim, but will not immediately throw an error for
    /// an invalid \p prim
    explicit {{ cls.cppClassName }}(
        const UsdPrim& prim=UsdPrim(), const TfToken &name=TfToken())
        : {{ cls.parentCppClassName }}(prim, /*instanceName*/ name)
    { }

    /// Construct a {{ cls.cppClassName }} on the prim held by \p schemaObj with
    /// name \p name.  Should be preferred over
    /// {{ cls.cppClassName }}(schemaObj.GetPrim(), name), as it preserves
    /// SchemaBase state.
    explicit {{ cls.cppClassName }}(
        const UsdSchemaBase& schemaObj, const TfToken &name)
        : {{ cls.parentCppClassName }}(schemaObj, /*instanceName*/ name)
    { }
{% else %}
    /// Construct a {{ cls.cppClassName }} on UsdPrim \p prim .
    /// Equivalent to {{ cls.cppClassName }}::Get(prim.GetStage(), prim.GetPath())
    /// for a \em valid \p prim, but will not immediately throw an error for
    /// an invalid \p prim
    explicit {{ cls.cppClassName }}(const UsdPrim& prim=UsdPrim())
        : {{ cls.parentCppClassName }}(prim)
    {
    }

    /// Construct a {{ cls.cppClassName }} on the prim held by \p schemaObj .
    /// Should be preferred over {{ cls.cppClassName }}(schemaObj.GetPrim()),
    /// as it preserves SchemaBase state.
    explicit {{ cls.cppClassName }}(const UsdSchemaBase& schemaObj)
        : {{ cls.parentCppClassName }}(schemaObj)
    {
    }
{% endif %}

    /// Destructor.
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    virtual ~{{ cls.cppClassName }}() {%- if cls.isAPISchemaBase %} = 0{% endif %};

{% if cls.isMultipleApply %}
    /// Return a vector of names of all pre-declared attributes for this schema
    /// class and all its ancestor classes for a given instance name.  Does not
    /// include attributes that may be authored by custom/extended methods of
    /// the schemas involved. The names returned will have the proper namespace
    /// prefix.
{% else %}
    /// Return a vector of names of all pre-declared attributes for this schema
    /// class and all its ancestor classes.  Does not include attributes that
    /// may be authored by custom/extended methods of the schemas involved.
{% endif %}
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static const TfTokenVector &
{% if cls.isMultipleApply %}
    GetSchemaAttributeNames(
        bool includeInherited=true, const TfToken instanceName=TfToken());
{% else %}
    GetSchemaAttributeNames(bool includeInherited=true);
{% endif %}
{% if cls.isMultipleApply %}

    /// Returns the name of this multiple-apply schema instance
    TfToken GetName() const {
        return _GetInstanceName();
    }
{% endif %}
{% if not cls.isAPISchemaBase %}

    /// Return a {{ cls.cppClassName }} holding the prim adhering to this
    /// schema at \p path on \p stage.  If no prim exists at \p path on
    /// \p stage, or if the prim at that path does not adhere to this schema,
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}
    /// return an invalid schema object.  \p path must be of the format
    /// <path>.{{ cls.propertyNamespacePrefix }}:name .
    ///
    /// This is shorthand for the following:
    ///
    /// \code
    /// TfToken name = SdfPath::StripNamespace(path.GetToken());
    /// {{ cls.cppClassName }}(
    ///     stage->GetPrimAtPath(path.GetPrimPath()), name);
    /// \endcode
{% else %}
    /// return an invalid schema object.  This is shorthand for the following:
    ///
    /// \code
    /// {{ cls.cppClassName }}(stage->GetPrimAtPath(path));
    /// \endcode
{% endif %}
    ///
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static {{ cls.cppClassName }}
    Get(const UsdStagePtr &stage, const SdfPath &path);
{% if cls.isMultipleApply %}

    /// Return a {{ cls.cppClassName }} with name \p name holding the
    /// prim \p prim. Shorthand for {{ cls.cppClassName }}(prim, name);
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static {{ cls.cppClassName }}
    Get(const UsdPrim &prim, const TfToken &name);
{% endif %}
{% endif %}

{% if cls.isConcrete %}
    /// Attempt to ensure a \a UsdPrim adhering to this schema at \p path
    /// is defined (according to UsdPrim::IsDefined()) on this stage.
    ///
    /// If a prim adhering to this schema at \p path is already defined on this
    /// stage, return that prim.  Otherwise author an \a SdfPrimSpec with
    /// \a specifier == \a SdfSpecifierDef and this schema's prim type name for
    /// the prim at \p path at the current EditTarget.  Author \a SdfPrimSpec s
    /// with \p specifier == \a SdfSpecifierDef and empty typeName at the
    /// current EditTarget for any nonexistent, or existing but not \a Defined
    /// ancestors.
    ///
    /// The given \a path must be an absolute prim path that does not contain
    /// any variant selections.
    ///
    /// If it is impossible to author any of the necessary PrimSpecs, (for
    /// example, in case \a path cannot map to the current UsdEditTarget's
    /// namespace) issue an error and return an invalid \a UsdPrim.
    ///
    /// Note that this method may return a defined prim whose typeName does not
    /// specify this schema class, in case a stronger typeName opinion overrides
    /// the opinion at the current EditTarget.
    ///
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static {{ cls.cppClassName }}
    Define(const UsdStagePtr &stage, const SdfPath &path);
{% endif %}
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}
    /// Checks if the given name \p baseName is the base name of a property
    /// of {{ cls.usdPrimTypeName }}.
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static bool
    IsSchemaPropertyBaseName(const TfToken &baseName);

    /// Checks if the given path \p path is of an API schema of type
    /// {{ cls.usdPrimTypeName }}. If so, it stores the instance name of
    /// the schema in \p name and returns true. Otherwise, it returns false.
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static bool
    Is{{ cls.usdPrimTypeName }}Path(const SdfPath &path, TfToken *name);
{% endif %}
{% if cls.isAppliedAPISchema and not cls.isMultipleApply %}

    /// Returns true if this <b>single-apply</b> API schema can be applied to 
    /// the given \p prim. If this schema can not be a applied to the prim, 
    /// this returns false and, if provided, populates \p whyNot with the 
    /// reason it can not be applied.
    /// 
    /// Note that if CanApply returns false, that does not necessarily imply
    /// that calling Apply will fail. Callers are expected to call CanApply
    /// before calling Apply if they want to ensure that it is valid to 
    /// apply a schema.
    /// 
    /// \sa UsdPrim::GetAppliedSchemas()
    /// \sa UsdPrim::HasAPI()
    /// \sa UsdPrim::CanApplyAPI()
    /// \sa UsdPrim::ApplyAPI()
    /// \sa UsdPrim::RemoveAPI()
    ///
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static bool 
    CanApply(const UsdPrim &prim, std::string *whyNot=nullptr);

    /// Applies this <b>single-apply</b> API schema to the given \p prim.
    /// This information is stored by adding "{{ cls.primName }}" to the 
    /// token-valued, listOp metadata \em apiSchemas on the prim.
    /// 
    /// \return A valid {{ cls.cppClassName }} object is returned upon success. 
    /// An invalid (or empty) {{ cls.cppClassName }} object is returned upon 
    /// failure. See \ref UsdPrim::ApplyAPI() for conditions 
    /// resulting in failure. 
    /// 
    /// \sa UsdPrim::GetAppliedSchemas()
    /// \sa UsdPrim::HasAPI()
    /// \sa UsdPrim::CanApplyAPI()
    /// \sa UsdPrim::ApplyAPI()
    /// \sa UsdPrim::RemoveAPI()
    ///
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static {{ cls.cppClassName }} 
    Apply(const UsdPrim &prim);
{% endif %}
{% if cls.isAppliedAPISchema and cls.isMultipleApply %}

    /// Returns true if this <b>multiple-apply</b> API schema can be applied,
    /// with the given instance name, \p name, to the given \p prim. If this 
    /// schema can not be a applied the prim, this returns false and, if 
    /// provided, populates \p whyNot with the reason it can not be applied.
    /// 
    /// Note that if CanApply returns false, that does not necessarily imply
    /// that calling Apply will fail. Callers are expected to call CanApply
    /// before calling Apply if they want to ensure that it is valid to 
    /// apply a schema.
    /// 
    /// \sa UsdPrim::GetAppliedSchemas()
    /// \sa UsdPrim::HasAPI()
    /// \sa UsdPrim::CanApplyAPI()
    /// \sa UsdPrim::ApplyAPI()
    /// \sa UsdPrim::RemoveAPI()
    ///
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static bool 
    CanApply(const UsdPrim &prim, const TfToken &name, 
             std::string *whyNot=nullptr);

    /// Applies this <b>multiple-apply</b> API schema to the given \p prim 
    /// along with the given instance name, \p name. 
    /// 
    /// This information is stored by adding "{{ cls.primName }}:<i>name</i>" 
    /// to the token-valued, listOp metadata \em apiSchemas on the prim.
    /// For example, if \p name is 'instance1', the token 
    /// '{{ cls.primName }}:instance1' is added to 'apiSchemas'.
    /// 
    /// \return A valid {{ cls.cppClassName }} object is returned upon success. 
    /// An invalid (or empty) {{ cls.cppClassName }} object is returned upon 
    /// failure. See \ref UsdPrim::ApplyAPI() for 
    /// conditions resulting in failure. 
    /// 
    /// \sa UsdPrim::GetAppliedSchemas()
    /// \sa UsdPrim::HasAPI()
    /// \sa UsdPrim::CanApplyAPI()
    /// \sa UsdPrim::ApplyAPI()
    /// \sa UsdPrim::RemoveAPI()
    ///
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static {{ cls.cppClassName }} 
    Apply(const UsdPrim &prim, const TfToken &name);
{% endif %}

protected:
    /// Returns the kind of schema this class belongs to.
    ///
    /// \sa UsdSchemaKind
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    UsdSchemaKind _GetSchemaKind() const override;

private:
    // needs to invoke _GetStaticTfType.
    friend class UsdSchemaRegistry;
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    static const TfType &_GetStaticTfType();

    static bool _IsTypedSchema();

    // override SchemaBase virtuals.
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    const TfType &_GetTfType() const override;

{% for attrName in cls.attrOrder %}
{% set attr = cls.attrs[attrName]%}
{# Only emit Create/Get API and doxygen if apiName is not empty string. #}
{% if attr.apiName != '' %}
public:
    // --------------------------------------------------------------------- //
    // {{ Upper(attr.apiName) }} 
    // --------------------------------------------------------------------- //
    /// {{ attr.doc }}
    ///
{% if attr.details %}
    /// | ||
    /// | -- | -- |
{% for detail in attr.details %}
    /// | {{ detail[0] }} | {{ detail[1] }} |
{% endfor %}
{% endif %}
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    UsdAttribute Get{{ Proper(attr.apiName) }}Attr() const;

    /// See Get{{ Proper(attr.apiName) }}Attr(), and also 
    /// \ref Usd_Create_Or_Get_Property for when to use Get vs Create.
    /// If specified, author \p defaultValue as the attribute's default,
    /// sparsely (when it makes sense to do so) if \p writeSparsely is \c true -
    /// the default for \p writeSparsely is \c false.
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    UsdAttribute Create{{ Proper(attr.apiName) }}Attr(VtValue const &defaultValue = VtValue(), bool writeSparsely=false) const;

{% endif %}
{% endfor %}
{% for relName in cls.relOrder %}
{% set rel = cls.rels[relName]%}
{# Only emit Create/Get API and doxygen if apiName is not empty string. #}
{% if rel.apiName != '' %}
public:
    // --------------------------------------------------------------------- //
    // {{ Upper(rel.apiName) }} 
    // --------------------------------------------------------------------- //
    /// {{ rel.doc }}
    ///
{% for detail in rel.details %}
    /// \n  {{ detail[0] }}: {{ detail[1] }}
{% endfor %}
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    UsdRelationship Get{{ Proper(rel.apiName) }}Rel() const;

    /// See Get{{ Proper(rel.apiName) }}Rel(), and also 
    /// \ref Usd_Create_Or_Get_Property for when to use Get vs Create
    {% if useExportAPI -%}
    {{ Upper(libraryName) }}_API
    {% endif -%}
    UsdRelationship Create{{ Proper(rel.apiName) }}Rel() const;
{% endif %}

{% endfor %}
public:
    // ===================================================================== //
    // Feel free to add custom code below this line, it will be preserved by 
    // the code generator. 
    //
    // Just remember to: 
    //  - Close the class declaration with }; 
{% if useExportAPI %}
    //  - Close the namespace with {{ namespaceClose }}
{% endif %}
    //  - Close the include guard with #endif
    // ===================================================================== //
    // --(BEGIN CUSTOM CODE)--

//
// Copyright 2016 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//
#include "{{ libraryPath }}/tokens.h"

{% if useExportAPI %}
{{ namespaceOpen }}

{% endif %}
{{ tokensPrefix }}TokensType::{{ tokensPrefix }}TokensType() :
{% for token in tokens %}
    {{ token.id }}("{{ token.value }}", TfToken::Immortal),
{% endfor %}
    allTokens({
{% for token in tokens %}
        {{ token.id }}{% if not loop.last %},{% endif %}

{% endfor %}
    })
{
}

TfStaticData<{{ tokensPrefix }}TokensType> {{ tokensPrefix }}Tokens;
{% if useExportAPI %}

{{ namespaceClose }}
{% endif %}
//
// Copyright 2016 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//
#ifndef {{ Upper(tokensPrefix) }}_TOKENS_H
#define {{ Upper(tokensPrefix) }}_TOKENS_H

/// \file {{ libraryName }}/tokens.h

// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// 
// This is an automatically generated file (by usdGenSchema.py).
// Do not hand-edit!
// 
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

{% if useExportAPI %}
#include "pxr/pxr.h"
#include "{{ libraryPath }}/api.h"
{% endif %}
#include "pxr/base/tf/staticData.h"
#include "pxr/base/tf/token.h"
#include <vector>

{% if useExportAPI %}
{{ namespaceOpen }}

{% endif %}

/// \class {{ tokensPrefix }}TokensType
///
/// \link {{ tokensPrefix }}Tokens \endlink provides static, efficient
/// \link TfToken TfTokens\endlink for use in all public USD API.
///
/// These tokens are auto-generated from the module's schema, representing
/// property names, for when you need to fetch an attribute or relationship
/// directly by name, e.g. UsdPrim::GetAttribute(), in the most efficient
/// manner, and allow the compiler to verify that you spelled the name
/// correctly.
///
/// {{ tokensPrefix }}Tokens also contains all of the \em allowedTokens values
/// declared for schema builtin attributes of 'token' scene description type.
{% if tokens %}
/// Use {{ tokensPrefix }}Tokens like so:
///
/// \code
///     gprim.GetMyTokenValuedAttr().Set({{ tokensPrefix }}Tokens->{{ tokens[0].id }});
/// \endcode
{% endif %}
struct {{ tokensPrefix }}TokensType {
    {% if useExportAPI %}{{ Upper(libraryName) }}_API {% endif %}{{ tokensPrefix }}TokensType();
{% for token in tokens %}
    /// \brief "{{ token.value }}"
    /// 
    /// {{ token.desc }}
    const TfToken {{ token.id }};
{% endfor %}
    /// A vector of all of the tokens listed above.
    const std::vector<TfToken> allTokens;
};

/// \var {{ tokensPrefix }}Tokens
///
/// A global variable with static, efficient \link TfToken TfTokens\endlink
/// for use in all public USD API.  \sa {{ tokensPrefix }}TokensType
extern{% if useExportAPI %} {{ Upper(libraryName) }}_API{% endif %} TfStaticData<{{ tokensPrefix }}TokensType> {{ tokensPrefix }}Tokens;
{% if useExportAPI %}

{{ namespaceClose }}
{% endif %}

#endif
//
// Copyright 2016 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//
#include "{{ libraryPath }}/{{ cls.GetHeaderFile() }}"
#include "pxr/usd/usd/schemaBase.h"

#include "pxr/usd/sdf/primSpec.h"

#include "pxr/usd/usd/pyConversions.h"
{% if cls.isAppliedAPISchema %}
#include "pxr/base/tf/pyAnnotatedBoolResult.h"
{% endif %}
#include "pxr/base/tf/pyContainerConversions.h"
#include "pxr/base/tf/pyResultConversions.h"
#include "pxr/base/tf/pyUtils.h"
#include "pxr/base/tf/wrapTypeHelpers.h"

#include <boost/python.hpp>

#include <string>

using namespace boost::python;

{% if useExportAPI %}
{{ namespaceUsing }}

namespace {

{% endif %}
#define WRAP_CUSTOM                                                     \
    template <class Cls> static void _CustomWrapCode(Cls &_class)

// fwd decl.
WRAP_CUSTOM;

{% for attrName in cls.attrOrder -%}
{% set attr = cls.attrs[attrName] %}
{# Only emit Create/Get API if apiName is not empty string. #}
{% if attr.apiName != '' %}
        
static UsdAttribute
_Create{{ Proper(attr.apiName) }}Attr({{ cls.cppClassName }} &self,
                                      object defaultVal, bool writeSparsely) {
    return self.Create{{ Proper(attr.apiName) }}Attr(
        UsdPythonToSdfType(defaultVal, {{ attr.usdType }}), writeSparsely);
}
{% endif %}
{% endfor %}
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}

static bool _WrapIs{{ cls.usdPrimTypeName }}Path(const SdfPath &path) {
    TfToken collectionName;
    return {{ cls.cppClassName }}::Is{{ cls.usdPrimTypeName }}Path(
        path, &collectionName);
}
{% endif %}
{% if not cls.isAPISchemaBase %}

static std::string
_Repr(const {{ cls.cppClassName }} &self)
{
    std::string primRepr = TfPyRepr(self.GetPrim());
{% if cls.isMultipleApply %}
    std::string instanceName = self.GetName();
    return TfStringPrintf(
        "{{ libraryName[0]|upper }}{{ libraryName[1:] }}.{{ cls.className }}(%s, '%s')",
        primRepr.c_str(), instanceName.c_str());
{% else %}
    return TfStringPrintf(
        "{{ libraryName[0]|upper }}{{ libraryName[1:] }}.{{ cls.className }}(%s)",
        primRepr.c_str());
{% endif %}
}
{% endif %}
{% if cls.isAppliedAPISchema %}

struct {{ cls.cppClassName }}_CanApplyResult : 
    public TfPyAnnotatedBoolResult<std::string>
{
    {{ cls.cppClassName }}_CanApplyResult(bool val, std::string const &msg) :
        TfPyAnnotatedBoolResult<std::string>(val, msg) {}
};

{% if cls.isMultipleApply %}
static {{ cls.cppClassName }}_CanApplyResult
_WrapCanApply(const UsdPrim& prim, const TfToken& name)
{
    std::string whyNot;
    bool result = {{ cls.cppClassName }}::CanApply(prim, name, &whyNot);
    return {{ cls.cppClassName }}_CanApplyResult(result, whyNot);
}
{% else %}
static {{ cls.cppClassName }}_CanApplyResult
_WrapCanApply(const UsdPrim& prim)
{
    std::string whyNot;
    bool result = {{ cls.cppClassName }}::CanApply(prim, &whyNot);
    return {{ cls.cppClassName }}_CanApplyResult(result, whyNot);
}
{% endif %}
{% endif %}
{% if useExportAPI %}

} // anonymous namespace
{% endif %}

void wrap{{ cls.cppClassName }}()
{
    typedef {{ cls.cppClassName }} This;

{% if cls.isAppliedAPISchema %}
    {{ cls.cppClassName }}_CanApplyResult::Wrap<{{ cls.cppClassName }}_CanApplyResult>(
        "_CanApplyResult", "whyNot");

{% endif %}
{% if cls.isAPISchemaBase %}
    class_< This , bases<{{ cls.parentCppClassName }}>, boost::noncopyable> cls ("APISchemaBase", "", no_init);
{% else %}
    class_<This, bases<{{ cls.parentCppClassName }}> >
        cls("{{ cls.className }}");
{% endif %}

    cls
{% if not cls.isAPISchemaBase %}
{% if cls.isMultipleApply %}
        .def(init<UsdPrim, TfToken>())
        .def(init<UsdSchemaBase const&, TfToken>())
{% else %}
        .def(init<UsdPrim>(arg("prim")))
        .def(init<UsdSchemaBase const&>(arg("schemaObj")))
{% endif %}
{% endif %}
        .def(TfTypePythonClass())

{% if not cls.isAPISchemaBase %}
{% if cls.isMultipleApply %}
        .def("Get",
            ({{ cls.cppClassName }}(*)(const UsdStagePtr &stage, 
                                       const SdfPath &path))
               &This::Get,
            (arg("stage"), arg("path")))
        .def("Get",
            ({{ cls.cppClassName }}(*)(const UsdPrim &prim,
                                       const TfToken &name))
               &This::Get,
            (arg("prim"), arg("name")))
{% else %}
        .def("Get", &This::Get, (arg("stage"), arg("path")))
{% endif %}
        .staticmethod("Get")
{% endif %}
{% if cls.isConcrete %}

        .def("Define", &This::Define, (arg("stage"), arg("path")))
        .staticmethod("Define")
{% endif %}
{% if cls.isAppliedAPISchema and not cls.isMultipleApply %}

        .def("CanApply", &_WrapCanApply, (arg("prim")))
        .staticmethod("CanApply")
{% endif %}
{% if cls.isAppliedAPISchema and cls.isMultipleApply %}

        .def("CanApply", &_WrapCanApply, (arg("prim"), arg("name")))
        .staticmethod("CanApply")
{% endif %}
{% if cls.isAppliedAPISchema and not cls.isMultipleApply %}

        .def("Apply", &This::Apply, (arg("prim")))
        .staticmethod("Apply")
{% endif %}
{% if cls.isAppliedAPISchema and cls.isMultipleApply %}

        .def("Apply", &This::Apply, (arg("prim"), arg("name")))
        .staticmethod("Apply")
{% endif %}

        .def("GetSchemaAttributeNames",
             &This::GetSchemaAttributeNames,
             arg("includeInherited")=true,
{% if cls.isMultipleApply %}
             arg("instanceName")=TfToken(),
{% endif %}
             return_value_policy<TfPySequenceToList>())
        .staticmethod("GetSchemaAttributeNames")

        .def("_GetStaticTfType", (TfType const &(*)()) TfType::Find<This>,
             return_value_policy<return_by_value>())
        .staticmethod("_GetStaticTfType")

        .def(!self)

{% for attrName in cls.attrOrder -%}
{% set attr = cls.attrs[attrName] %}
{# Only emit Create/Get API if apiName is not empty string. #}
{% if attr.apiName != '' %}
        
        .def("Get{{ Proper(attr.apiName) }}Attr",
             &This::Get{{ Proper(attr.apiName) }}Attr)
        .def("Create{{ Proper(attr.apiName) }}Attr",
             &_Create{{ Proper(attr.apiName) }}Attr,
             (arg("defaultValue")=object(),
              arg("writeSparsely")=false))
{% endif %}
{% endfor %}

{% for relName in cls.relOrder -%}
{# Only emit Create/Get API and doxygen if apiName is not empty string. #}
{% set rel = cls.rels[relName] %}
{% if rel.apiName != '' %}
        
        .def("Get{{ Proper(rel.apiName) }}Rel",
             &This::Get{{ Proper(rel.apiName) }}Rel)
        .def("Create{{ Proper(rel.apiName) }}Rel",
             &This::Create{{ Proper(rel.apiName) }}Rel)
{% endif %}
{% endfor %}
{% if cls.isMultipleApply and cls.propertyNamespacePrefix %}
        .def("Is{{ cls.usdPrimTypeName }}Path", _WrapIs{{ cls.usdPrimTypeName }}Path)
            .staticmethod("Is{{ cls.usdPrimTypeName }}Path")
{% endif %}
{% if not cls.isAPISchemaBase %}
        .def("__repr__", ::_Repr)
{% endif %}
    ;

    _CustomWrapCode(cls);
}

// ===================================================================== //
// Feel free to add custom code below this line, it will be preserved by 
// the code generator.  The entry point for your custom code should look
// minimally like the following:
//
// WRAP_CUSTOM {
//     _class
//         .def("MyCustomMethod", ...)
//     ;
// }
//
// Of course any other ancillary or support code may be provided.
{% if useExportAPI %}
// 
// Just remember to wrap code in the appropriate delimiters:
// 'namespace {', '}'.
//
{% endif %}
// ===================================================================== //
// --(BEGIN CUSTOM CODE)--

//
// Copyright 2016 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//
// GENERATED FILE.  DO NOT EDIT.
#include <boost/python/class.hpp>
#include "{{ libraryPath }}/tokens.h"

{% if useExportAPI %}
{{ namespaceUsing }}

{% endif %}
namespace {

// Helper to return a static token as a string.  We wrap tokens as Python
// strings and for some reason simply wrapping the token using def_readonly
// bypasses to-Python conversion, leading to the error that there's no
// Python type for the C++ TfToken type.  So we wrap this functor instead.
class _WrapStaticToken {
public:
    _WrapStaticToken(const TfToken* token) : _token(token) { }

    std::string operator()() const
    {
        return _token->GetString();
    }

private:
    const TfToken* _token;
};

template <typename T>
void
_AddToken(T& cls, const char* name, const TfToken& token)
{
    cls.add_static_property(name,
                            boost::python::make_function(
                                _WrapStaticToken(&token),
                                boost::python::return_value_policy<
                                    boost::python::return_by_value>(),
                                boost::mpl::vector1<std::string>()));
}

} // anonymous

void wrap{{ tokensPrefix }}Tokens()
{
    boost::python::class_<{{ tokensPrefix }}TokensType, boost::noncopyable>
        cls("Tokens", boost::python::no_init);
{% for token in tokens %}
    _AddToken(cls, "{{ token.id }}", {{ tokensPrefix }}Tokens->{{ token.id }});
{% endfor %}
}
# Portions of this file auto-generated by usdGenSchema.
# Edits will survive regeneration except for comments and
# changes to types with autoGenerated=true.
{
    "Plugins": [
        {
            "Info": {
                "Types": {
                    "UsdLuxBoundableLightBase": {
                        "alias": {
                            "UsdSchemaBase": "BoundableLightBase"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomBoundable"
                        ], 
                        "schemaKind": "abstractTyped"
                    }, 
                    "UsdLuxCylinderLight": {
                        "alias": {
                            "UsdSchemaBase": "CylinderLight"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdLuxBoundableLightBase"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxDiskLight": {
                        "alias": {
                            "UsdSchemaBase": "DiskLight"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdLuxBoundableLightBase"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxDistantLight": {
                        "alias": {
                            "UsdSchemaBase": "DistantLight"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdLuxNonboundableLightBase"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxDomeLight": {
                        "alias": {
                            "UsdSchemaBase": "DomeLight"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdLuxNonboundableLightBase"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxGeometryLight": {
                        "alias": {
                            "UsdSchemaBase": "GeometryLight"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdLuxNonboundableLightBase"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxLightAPI": {
                        "alias": {
                            "UsdSchemaBase": "LightAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "providesUsdShadeConnectableAPIBehavior": true, 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdLuxLightFilter": {
                        "alias": {
                            "UsdSchemaBase": "LightFilter"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomXformable"
                        ], 
                        "providesUsdShadeConnectableAPIBehavior": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxListAPI": {
                        "alias": {
                            "UsdSchemaBase": "ListAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdLuxMeshLightAPI": {
                        "alias": {
                            "UsdSchemaBase": "MeshLightAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdLuxNonboundableLightBase": {
                        "alias": {
                            "UsdSchemaBase": "NonboundableLightBase"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomXformable"
                        ], 
                        "schemaKind": "abstractTyped"
                    }, 
                    "UsdLuxPluginLight": {
                        "alias": {
                            "UsdSchemaBase": "PluginLight"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomXformable"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxPluginLightFilter": {
                        "alias": {
                            "UsdSchemaBase": "PluginLightFilter"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdLuxLightFilter"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxPortalLight": {
                        "alias": {
                            "UsdSchemaBase": "PortalLight"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdLuxBoundableLightBase"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxRectLight": {
                        "alias": {
                            "UsdSchemaBase": "RectLight"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdLuxBoundableLightBase"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxShadowAPI": {
                        "alias": {
                            "UsdSchemaBase": "ShadowAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdLuxShapingAPI": {
                        "alias": {
                            "UsdSchemaBase": "ShapingAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdLuxSphereLight": {
                        "alias": {
                            "UsdSchemaBase": "SphereLight"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdLuxBoundableLightBase"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdLuxVolumeLightAPI": {
                        "alias": {
                            "UsdSchemaBase": "VolumeLightAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdLux_DiscoveryPlugin": {
                        "bases": [
                            "NdrDiscoveryPlugin"
                        ]
                    }, 
                    "UsdLux_LightDefParserPlugin": {
                        "bases": [
                            "NdrParserPlugin"
                        ]
                    }
                }
            }, 
            "LibraryPath": "", 
            "Name": "usdLux", 
            "ResourcePath": "resources", 
            "Root": "..", 
            "Type": "library"
        }
    ]
}
#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "LightAPI" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
    doc = """API schema that imparts the quality of being a light onto a prim. 

    A light is any prim that has this schema applied to it.  This is true 
    regardless of whether LightAPI is included as a built-in API of the prim 
    type (e.g. RectLight or DistantLight) or is applied directly to a Gprim 
    that should be treated as a light.

    <b>Linking</b>

    Lights can be linked to geometry.  Linking controls which geometry
    a light illuminates, and which geometry casts shadows from the light.

    Linking is specified as collections (UsdCollectionAPI) which can
    be accessed via GetLightLinkCollection() and GetShadowLinkCollection().
    Note that these collections have their includeRoot set to true,
    so that lights will illuminate and cast shadows from all objects
    by default.  To illuminate only a specific set of objects, there
    are two options.  One option is to modify the collection paths
    to explicitly exclude everything else, assuming it is known;
    the other option is to set includeRoot to false and explicitly
    include the desired objects.  These are complementary approaches
    that may each be preferable depending on the scenario and how
    to best express the intent of the light setup.
    """
)
{
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f inputs:color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float inputs:colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the
        white point.  The default is a common white point, D65.  Lower
        values are warmer and higher values are cooler.  The valid range
        is from 1000 to 10000. Only takes effect when
        enableColorTemperature is set to true.  When active, the
        computed result multiplies against the color attribute.
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float inputs:diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse
        response of materials.  This is a non-physical control."""
    )
    bool inputs:enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float inputs:exposure = 0 (
        doc = """Scales the power of the light exponentially as a power
        of 2 (similar to an F-stop control over exposure).  The result
        is multiplied against the intensity."""
    )
    float inputs:intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    bool inputs:normalize = 0 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.
        This makes it easier to independently adjust the power and shape
        of the light, by causing the power to not vary with the area or
        angular size of the light."""
    )
    float inputs:specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular
        response of materials.  This is a non-physical control."""
    )
    rel light:filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    uniform token light:materialSyncMode = "noMaterialResponse" (
        allowedTokens = ["materialGlowTintsLight", "independent", "noMaterialResponse"]
        doc = """For a LightAPI applied to geometry that has a bound Material, 
        which is entirely or partly emissive, this specifies the relationship 
        of the Material response to the lighting response.
        Valid values are:
        - materialGlowTintsLight: All primary and secondary rays see the 
          emissive/glow response as dictated by the bound Material while the 
          base color seen by light rays (which is then modulated by all of the 
          other LightAPI controls) is the multiplication of the color feeding 
          the emission/glow input of the Material (i.e. its surface or volume 
          shader) with the scalar or pattern input to *inputs:color*.
          This allows the light's color to tint the geometry's glow color while 
          preserving access to intensity and other light controls as ways to 
          further modulate the illumination.
        - independent: All primary and secondary rays see the emissive/glow 
          response as dictated by the bound Material, while the base color seen 
          by light rays is determined solely by *inputs:color*. Note that for 
          partially emissive geometry (in which some parts are reflective 
          rather than emissive), a suitable pattern must be connected to the 
          light's color input, or else the light will radiate uniformly from 
          the geometry.
        - noMaterialResponse: The geometry behaves as if there is no Material
          bound at all, i.e. there is no diffuse, specular, or transmissive 
          response. The base color of light rays is entirely controlled by the
          *inputs:color*. This is the standard mode for \"canonical\" lights in 
          UsdLux and indicates to renderers that a Material will either never 
          be bound or can always be ignored.
        """
    )
    uniform token light:shaderId = "" (
        displayGroup = "Internal"
        doc = """Default ID for the light's shader. 
        This defines the shader ID for this light when a render context specific
        shader ID is not available. 

        The default shaderId for the intrinsic UsdLux lights (RectLight, 
        DistantLight, etc.) are set to default to the light's type name. For 
        each intrinsic UsdLux light, we will always register an SdrShaderNode in
        the SdrRegistry, with the identifier matching the type name and the 
        source type \"USD\", that corresponds to the light's inputs.
        \\see GetShaderId
        \\see GetShaderIdAttrForRenderContext
        \\see SdrRegistry::GetShaderNodeByIdentifier
        \\see SdrRegistry::GetShaderNodeByIdentifierAndType
        """
    )
}

class "MeshLightAPI" (
    apiSchemas = ["LightAPI"]
    doc = '''This is the preferred API schema to apply to 
    "Mesh" type prims when adding light behaviors to a mesh. 
    At its base, this API schema has the built-in behavior of applying LightAPI 
    to the mesh and overriding the default materialSyncMode to allow the 
    emission/glow of the bound material to affect the color of the light. 
    But, it additionally serves as a hook for plugins to attach additional 
    properties to "mesh lights" through the creation of API schemas which are 
    authored to auto-apply to MeshLightAPI.
    \\see \\ref Usd_AutoAppliedAPISchemas
    '''
)
{
    uniform token light:materialSyncMode = "materialGlowTintsLight"
    uniform token light:shaderId = "MeshLight" (
        displayGroup = "Internal"
    )
}

class "VolumeLightAPI" (
    apiSchemas = ["LightAPI"]
    doc = '''This is the preferred API schema to apply to 
    "Volume" type prims when adding light behaviors to a 
    volume. At its base, this API schema has the built-in behavior of applying 
    LightAPI to the volume and overriding the default materialSyncMode to allow 
    the emission/glow of the bound material to affect the color of the light. 
    But, it additionally serves as a hook for plugins to attach additional 
    properties to "volume lights" through the creation of API schemas which are 
    authored to auto-apply to VolumeLightAPI.
    \\see \\ref Usd_AutoAppliedAPISchemas
    '''
)
{
    uniform token light:materialSyncMode = "materialGlowTintsLight"
    uniform token light:shaderId = "VolumeLight" (
        displayGroup = "Internal"
    )
}

class "ListAPI" (
    doc = '''API schema to support discovery and publishing of lights in a scene.

    Discovering Lights via Traversal
    
    To motivate this API, consider what is required to discover all
    lights in a scene.  We must load all payloads and traverse all prims:

    \\code
    01  // Load everything on the stage so we can find all lights,
    02  // including those inside payloads
    03  stage->Load();
    04  
    05  // Traverse all prims, checking if they have an applied UsdLuxLightAPI
    06  // (Note: ignoring instancing and a few other things for simplicity)
    07  SdfPathVector lights;
    08  for (UsdPrim prim: stage->Traverse()) {
    09      if (prim.HasAPI<UsdLuxLightAPI>()) {
    10          lights.push_back(i->GetPath());
    11      }
    12  }
    \\endcode

    This traversal -- suitably elaborated to handle certain details --
    is the first and simplest thing UsdLuxListAPI provides.
    UsdLuxListAPI::ComputeLightList() performs this traversal and returns
    all lights in the scene:

    \\code
    01  UsdLuxListAPI listAPI(stage->GetPseudoRoot());
    02  SdfPathVector lights = listAPI.ComputeLightList();
    \\endcode

    Publishing a Cached Light List

    Consider a USD client that needs to quickly discover lights but
    wants to defer loading payloads and traversing the entire scene
    where possible, and is willing to do up-front computation and
    caching to achieve that.

    UsdLuxListAPI provides a way to cache the computed light list,
    by publishing the list of lights onto prims in the model
    hierarchy.  Consider a big set that contains lights:

    \\code
    01  def Xform "BigSetWithLights" (
    02      kind = "assembly"
    03      payload = @BigSetWithLights.usd@   // Heavy payload
    04  ) {
    05      // Pre-computed, cached list of lights inside payload
    06      rel lightList = [
    07          <./Lights/light_1>,
    08          <./Lights/light_2>,
    09          ...
    10      ]
    11      token lightList:cacheBehavior = "consumeAndContinue";
    12  }
    \\endcode

    The lightList relationship encodes a set of lights, and the
    lightList:cacheBehavior property provides fine-grained
    control over how to use that cache.  (See details below.)

    The cache can be created by first invoking
    ComputeLightList(ComputeModeIgnoreCache) to pre-compute the list
    and then storing the result with UsdLuxListAPI::StoreLightList().

    To enable efficient retrieval of the cache, it should be stored
    on a model hierarchy prim.  Furthermore, note that while you can
    use a UsdLuxListAPI bound to the pseudo-root prim to query the
    lights (as in the example above) because it will perform a
    traversal over descendants, you cannot store the cache back to the
    pseduo-root prim.

    To consult the cached list, we invoke
    ComputeLightList(ComputeModeConsultModelHierarchyCache):

    \\code
    01  // Find and load all lights, using lightList cache where available
    02  UsdLuxListAPI list(stage->GetPseudoRoot());
    03  SdfPathSet lights = list.ComputeLightList(
    04      UsdLuxListAPI::ComputeModeConsultModelHierarchyCache);
    05  stage.LoadAndUnload(lights, SdfPathSet());
    \\endcode

    In this mode, ComputeLightList() will traverse the model
    hierarchy, accumulating cached light lists.

    Controlling Cache Behavior

    The lightList:cacheBehavior property gives additional fine-grained
    control over cache behavior:

    - The fallback value, "ignore", indicates that the lightList should
    be disregarded.  This provides a way to invalidate cache entries.
    Note that unless "ignore" is specified, a lightList with an empty
    list of targets is considered a cache indicating that no lights
    are present.

    - The value "consumeAndContinue" indicates that the cache should
    be consulted to contribute lights to the scene, and that recursion
    should continue down the model hierarchy in case additional lights
    are added as descedants. This is the default value established when
    StoreLightList() is invoked. This behavior allows the lights within
    a large model, such as the BigSetWithLights example above, to be
    published outside the payload, while also allowing referencing and
    layering to add additional lights over that set.

    - The value "consumeAndHalt" provides a way to terminate recursive
    traversal of the scene for light discovery. The cache will be
    consulted but no descendant prims will be examined.

    Instancing

    Where instances are present, UsdLuxListAPI::ComputeLightList() will
    return the instance-unique paths to any lights discovered within
    those instances.  Lights within a UsdGeomPointInstancer will
    not be returned, however, since they cannot be referred to
    solely via paths.
'''
)
{
    rel lightList (
        doc = "Relationship to lights in the scene."
    )
    token lightList:cacheBehavior (
        allowedTokens = ["consumeAndHalt", "consumeAndContinue", "ignore"]
        doc = """Controls how the lightList should be interpreted.
        Valid values are:
        - consumeAndHalt: The lightList should be consulted,
          and if it exists, treated as a final authoritative statement
          of any lights that exist at or below this prim, halting
          recursive discovery of lights.
        - consumeAndContinue: The lightList should be consulted,
          but recursive traversal over nameChildren should continue
          in case additional lights are added by descendants.
        - ignore: The lightList should be entirely ignored.  This
          provides a simple way to temporarily invalidate an existing
          cache.  This is the fallback behavior.
        """
    )
}

class "ShapingAPI" (
    doc = "Controls for shaping a light's emission."
)
{
    float inputs:shaping:cone:angle = 90 (
        displayGroup = "Shaping"
        doc = """Angular limit off the primary axis to restrict the
        light spread."""
    )
    float inputs:shaping:cone:softness = 0 (
        displayGroup = "Shaping"
        doc = """Controls the cutoff softness for cone angle.
        TODO: clarify semantics"""
    )
    float inputs:shaping:focus = 0 (
        displayGroup = "Shaping"
        doc = """A control to shape the spread of light.  Higher focus
        values pull light towards the center and narrow the spread.
        Implemented as an off-axis cosine power exponent.
        TODO: clarify semantics"""
    )
    color3f inputs:shaping:focusTint = (0, 0, 0) (
        displayGroup = "Shaping"
        doc = """Off-axis color tint.  This tints the emission in the
        falloff region.  The default tint is black.
        TODO: clarify semantics"""
    )
    float inputs:shaping:ies:angleScale = 0 (
        displayGroup = "Shaping"
        doc = """Rescales the angular distribution of the IES profile.
        TODO: clarify semantics"""
    )
    asset inputs:shaping:ies:file (
        displayGroup = "Shaping"
        doc = """An IES (Illumination Engineering Society) light
        profile describing the angular distribution of light."""
    )
    bool inputs:shaping:ies:normalize = 0 (
        displayGroup = "Shaping"
        doc = """Normalizes the IES profile so that it affects the shaping
        of the light while preserving the overall energy output."""
    )
}

class "ShadowAPI" (
    doc = """Controls to refine a light's shadow behavior.  These are
    non-physical controls that are valuable for visual lighting work."""
)
{
    color3f inputs:shadow:color = (0, 0, 0) (
        displayGroup = "Shadows"
        doc = """The color of shadows cast by the light.  This is a
        non-physical control.  The default is to cast black shadows."""
    )
    float inputs:shadow:distance = -1 (
        displayGroup = "Shadows"
        doc = """The maximum distance shadows are cast.
        The default value (-1) indicates no limit.
        """
    )
    bool inputs:shadow:enable = 1 (
        displayGroup = "Shadows"
        doc = "Enables shadows to be cast by this light."
    )
    float inputs:shadow:falloff = -1 (
        displayGroup = "Shadows"
        doc = """The near distance at which shadow falloff begins.
        The default value (-1) indicates no falloff.
        """
    )
    float inputs:shadow:falloffGamma = 1 (
        displayGroup = "Shadows"
        doc = """A gamma (i.e., exponential) control over shadow strength
        with linear distance within the falloff zone.
        This requires the use of shadowDistance and shadowFalloff."""
    )
}

class LightFilter "LightFilter" (
    apiSchemas = ["CollectionAPI:filterLink"]
    doc = """A light filter modifies the effect of a light.
    Lights refer to filters via relationships so that filters may be
    shared.

    <b>Linking</b>

    Filters can be linked to geometry.  Linking controls which geometry
    a light-filter affects, when considering the light filters attached
    to a light illuminating the geometry.

    Linking is specified as a collection (UsdCollectionAPI) which can
    be accessed via GetFilterLinkCollection().
    """
)
{
    uniform bool collection:filterLink:includeRoot = 1
    uniform token lightFilter:shaderId = "" (
        displayGroup = "Internal"
        doc = """Default ID for the light filter's shader. 
        This defines the shader ID for this light filter when a render context 
        specific shader ID is not available. 

        \\see GetShaderId
        \\see GetShaderIdAttrForRenderContext
        \\see SdrRegistry::GetShaderNodeByIdentifier
        \\see SdrRegistry::GetShaderNodeByIdentifierAndType
        """
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "BoundableLightBase" (
    apiSchemas = ["LightAPI"]
    doc = """Base class for intrinsic lights that are boundable.

    The primary purpose of this class is to provide a direct API to the 
    functions provided by LightAPI for concrete derived light types.
    """
)
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "NonboundableLightBase" (
    apiSchemas = ["LightAPI"]
    doc = """Base class for intrinsic lights that are not boundable.

    The primary purpose of this class is to provide a direct API to the 
    functions provided by LightAPI for concrete derived light types.
    """
)
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class DistantLight "DistantLight" (
    apiSchemas = ["LightAPI"]
    doc = """Light emitted from a distant source along the -Z axis.
    Also known as a directional light."""
)
{
    float inputs:angle = 0.53 (
        doc = """Angular size of the light in degrees.
        As an example, the Sun is approximately 0.53 degrees as seen from Earth.
        Higher values broaden the light and therefore soften shadow edges.
        """
    )
    float inputs:intensity = 50000 (
        doc = """Scales the emission of the light linearly.
        The DistantLight has a high default intensity to approximate the Sun."""
    )
    uniform token light:shaderId = "DistantLight" (
        displayGroup = "Internal"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class DiskLight "DiskLight" (
    apiSchemas = ["LightAPI"]
    doc = """Light emitted from one side of a circular disk.
    The disk is centered in the XY plane and emits light along the -Z axis."""
)
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    float inputs:radius = 0.5 (
        doc = "Radius of the disk."
    )
    uniform token light:shaderId = "DiskLight" (
        displayGroup = "Internal"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class RectLight "RectLight" (
    apiSchemas = ["LightAPI"]
    doc = """Light emitted from one side of a rectangle.
    The rectangle is centered in the XY plane and emits light along the -Z axis.
    The rectangle is 1 unit in length in the X and Y axis.  In the default 
    position, a texture file's min coordinates should be at (+X, +Y) and 
    max coordinates at (-X, -Y)."""
)
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    float inputs:height = 1 (
        doc = "Height of the rectangle, in the local Y axis."
    )
    asset inputs:texture:file (
        doc = "A color texture to use on the rectangle."
    )
    float inputs:width = 1 (
        doc = "Width of the rectangle, in the local X axis."
    )
    uniform token light:shaderId = "RectLight" (
        displayGroup = "Internal"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class SphereLight "SphereLight" (
    apiSchemas = ["LightAPI"]
    doc = "Light emitted outward from a sphere."
)
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    float inputs:radius = 0.5 (
        doc = "Radius of the sphere."
    )
    uniform token light:shaderId = "SphereLight" (
        displayGroup = "Internal"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    bool treatAsPoint = 0 (
        doc = """A hint that this light can be treated as a 'point'
        light (effectively, a zero-radius sphere) by renderers that
        benefit from non-area lighting. Renderers that only support
        area lights can disregard this."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class CylinderLight "CylinderLight" (
    apiSchemas = ["LightAPI"]
    doc = """Light emitted outward from a cylinder.
    The cylinder is centered at the origin and has its major axis on the X axis.
    The cylinder does not emit light from the flat end-caps.
    """
)
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    float inputs:length = 1 (
        doc = "Width of the rectangle, in the local X axis."
    )
    float inputs:radius = 0.5 (
        doc = "Radius of the cylinder."
    )
    uniform token light:shaderId = "CylinderLight" (
        displayGroup = "Internal"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    bool treatAsLine = 0 (
        doc = """A hint that this light can be treated as a 'line'
        light (effectively, a zero-radius cylinder) by renderers that
        benefit from non-area lighting. Renderers that only support
        area lights can disregard this."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class GeometryLight "GeometryLight" (
    apiSchemas = ["LightAPI"]
    doc = """\\deprecated
    Light emitted outward from a geometric prim (UsdGeomGprim),
    which is typically a mesh."""
)
{
    rel geometry (
        doc = "Relationship to the geometry to use as the light source."
    )
    uniform token light:shaderId = "GeometryLight" (
        displayGroup = "Internal"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class DomeLight "DomeLight" (
    apiSchemas = ["LightAPI"]
    doc = """Light emitted inward from a distant external environment,
    such as a sky or IBL light probe.  The orientation of a dome light with a
    latlong texture is expected to match the OpenEXR specification for latlong 
    environment maps.  From the OpenEXR documentation:
    
    -------------------------------------------------------------------------
    Latitude-Longitude Map:
    
    The environment is projected onto the image using polar coordinates
    (latitude and longitude).  A pixel's x coordinate corresponds to
    its longitude, and the y coordinate corresponds to its latitude.
    Pixel (dataWindow.min.x, dataWindow.min.y) has latitude +pi/2 and
    longitude +pi; pixel (dataWindow.max.x, dataWindow.max.y) has
    latitude -pi/2 and longitude -pi.
    
    In 3D space, latitudes -pi/2 and +pi/2 correspond to the negative and
    positive y direction.  Latitude 0, longitude 0 points into positive
    z direction; and latitude 0, longitude pi/2 points into positive x
    direction.
    
    The size of the data window should be 2*N by N pixels (width by height),
    where N can be any integer greater than 0.
    -------------------------------------------------------------------------
"""
)
{
    asset inputs:texture:file (
        doc = """A color texture to use on the dome, such as an HDR (high
        dynamic range) texture intended for IBL (image based lighting)."""
    )
    token inputs:texture:format = "automatic" (
        allowedTokens = ["automatic", "latlong", "mirroredBall", "angular", "cubeMapVerticalCross"]
        doc = """Specifies the parameterization of the color map file.
        Valid values are:
        - automatic: Tries to determine the layout from the file itself.
          For example, Renderman texture files embed an explicit
          parameterization.
        - latlong: Latitude as X, longitude as Y.
        - mirroredBall: An image of the environment reflected in a
          sphere, using an implicitly orthogonal projection.
        - angular: Similar to mirroredBall but the radial dimension
          is mapped linearly to the angle, providing better sampling
          at the edges.
        - cubeMapVerticalCross: A cube map with faces laid out as a
          vertical cross.
        """
    )
    uniform token light:shaderId = "DomeLight" (
        displayGroup = "Internal"
    )
    rel portals (
        doc = "Optional portals to guide light sampling."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class PortalLight "PortalLight" (
    apiSchemas = ["LightAPI"]
    doc = """A rectangular portal in the local XY plane that guides sampling
    of a dome light.  Transmits light in the -Z direction.
    The rectangle is 1 unit in length."""
)
{
    float3[] extent = [(-0.5, -0.5, 0), (0.5, 0.5, 0)] (
        doc = """Boundary extent of the unit rectangle in the XY plane that 
        defines the portal."""
    )
    uniform token light:shaderId = "PortalLight" (
        displayGroup = "Internal"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class PluginLight "PluginLight" (
    apiSchemas = ["NodeDefAPI", "LightAPI"]
    doc = """Light that provides properties that allow it to identify an 
    external SdrShadingNode definition, through UsdShadeNodeDefAPI, that can be 
    provided to render delegates without the need to provide a schema 
    definition for the light's type.

    \\see \\ref usdLux_PluginSchemas
"""
)
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class PluginLightFilter "PluginLightFilter" (
    apiSchemas = ["NodeDefAPI", "CollectionAPI:filterLink"]
    doc = """Light filter that provides properties that allow it to identify an 
    external SdrShadingNode definition, through UsdShadeNodeDefAPI, that can be 
    provided to render delegates without the need to provide a schema 
    definition for the light filter's type.

    \\see \\ref usdLux_PluginSchemas
"""
)
{
    uniform bool collection:filterLink:includeRoot = 1
    uniform token lightFilter:shaderId = "" (
        displayGroup = "Internal"
        doc = """Default ID for the light filter's shader. 
        This defines the shader ID for this light filter when a render context 
        specific shader ID is not available. 

        \\see GetShaderId
        \\see GetShaderIdAttrForRenderContext
        \\see SdrRegistry::GetShaderNodeByIdentifier
        \\see SdrRegistry::GetShaderNodeByIdentifierAndType
        """
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

#usda 1.0
(
    "This file describes the USD Lux light schemata for code generation."
    subLayers = [
        @usdGeom/schema.usda@
    ]
)

over "GLOBAL" (
    customData = {
        string libraryName      = "usdLux"
        string libraryPath      = "pxr/usd/usdLux"
        dictionary libraryTokens = {
            dictionary lightLink = {
                string doc = """
                This token represents the collection name to use
                with UsdCollectionAPI to represent light-linking
                of a prim with an applied UsdLuxLightAPI.
                """
            }
            dictionary shadowLink = {
                string doc = """
                This token represents the collection name to use
                with UsdCollectionAPI to represent shadow-linking
                of a prim with an applied UsdLuxLightAPI.
                """
            }
            dictionary filterLink = {
                string doc = """
                This token represents the collection name to use
                with UsdCollectionAPI to represent filter-linking
                of a UsdLuxLightFilter prim.
                """
            }
            dictionary orientToStageUpAxis = {
                string doc = """
                This token represents the suffix for a UsdGeomXformOp
                used to orient a light with the stage's up axis.
                """
            }
        }
    }
)
{
}

class "LightAPI" (
    inherits = </APISchemaBase>
    doc = """API schema that imparts the quality of being a light onto a prim. 

    A light is any prim that has this schema applied to it.  This is true 
    regardless of whether LightAPI is included as a built-in API of the prim 
    type (e.g. RectLight or DistantLight) or is applied directly to a Gprim 
    that should be treated as a light.

    <b>Linking</b>

    Lights can be linked to geometry.  Linking controls which geometry
    a light illuminates, and which geometry casts shadows from the light.

    Linking is specified as collections (UsdCollectionAPI) which can
    be accessed via GetLightLinkCollection() and GetShadowLinkCollection().
    Note that these collections have their includeRoot set to true,
    so that lights will illuminate and cast shadows from all objects
    by default.  To illuminate only a specific set of objects, there
    are two options.  One option is to modify the collection paths
    to explicitly exclude everything else, assuming it is known;
    the other option is to set includeRoot to false and explicitly
    include the desired objects.  These are complementary approaches
    that may each be preferable depending on the scenario and how
    to best express the intent of the light setup.
    """
    customData = {
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
        }
        string extraIncludes = """
#include "pxr/usd/usd/collectionAPI.h"
#include "pxr/usd/usdShade/input.h"
#include "pxr/usd/usdShade/output.h" """
    }
    prepend apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
) {
    uniform bool collection:lightLink:includeRoot = 1 (
        customData = {
            token apiName = ""
        }
    )
    uniform bool collection:shadowLink:includeRoot = 1 (
        customData = {
            token apiName = ""
        }
    )
    uniform token light:shaderId = "" (
        doc = """Default ID for the light's shader. 
        This defines the shader ID for this light when a render context specific
        shader ID is not available. 

        The default shaderId for the intrinsic UsdLux lights (RectLight, 
        DistantLight, etc.) are set to default to the light's type name. For 
        each intrinsic UsdLux light, we will always register an SdrShaderNode in
        the SdrRegistry, with the identifier matching the type name and the 
        source type "USD", that corresponds to the light's inputs.
        \\see GetShaderId
        \\see GetShaderIdAttrForRenderContext
        \\see SdrRegistry::GetShaderNodeByIdentifier
        \\see SdrRegistry::GetShaderNodeByIdentifierAndType
        """
        customData = {
            token apiName = "shaderId"
        }
        displayGroup = "Internal"
    )
    uniform token light:materialSyncMode = "noMaterialResponse" (
        doc = """For a LightAPI applied to geometry that has a bound Material, 
        which is entirely or partly emissive, this specifies the relationship 
        of the Material response to the lighting response.
        Valid values are:
        - materialGlowTintsLight: All primary and secondary rays see the 
          emissive/glow response as dictated by the bound Material while the 
          base color seen by light rays (which is then modulated by all of the 
          other LightAPI controls) is the multiplication of the color feeding 
          the emission/glow input of the Material (i.e. its surface or volume 
          shader) with the scalar or pattern input to *inputs:color*.
          This allows the light's color to tint the geometry's glow color while 
          preserving access to intensity and other light controls as ways to 
          further modulate the illumination.
        - independent: All primary and secondary rays see the emissive/glow 
          response as dictated by the bound Material, while the base color seen 
          by light rays is determined solely by *inputs:color*. Note that for 
          partially emissive geometry (in which some parts are reflective 
          rather than emissive), a suitable pattern must be connected to the 
          light's color input, or else the light will radiate uniformly from 
          the geometry.
        - noMaterialResponse: The geometry behaves as if there is no Material
          bound at all, i.e. there is no diffuse, specular, or transmissive 
          response. The base color of light rays is entirely controlled by the
          *inputs:color*. This is the standard mode for "canonical" lights in 
          UsdLux and indicates to renderers that a Material will either never 
          be bound or can always be ignored.
        """
        allowedTokens = ["materialGlowTintsLight", 
                         "independent", 
                         "noMaterialResponse"]
        customData = {
            token apiName = "materialSyncMode"
        }
    )
    float inputs:intensity = 1 (
        doc = """Scales the power of the light linearly."""
        customData = {
            token apiName = "intensity"
        }
    )
    float inputs:exposure = 0 (
        doc = """Scales the power of the light exponentially as a power
        of 2 (similar to an F-stop control over exposure).  The result
        is multiplied against the intensity."""
        customData = {
            token apiName = "exposure"
        }
    )
    float inputs:diffuse = 1.0 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse
        response of materials.  This is a non-physical control."""
        customData = {
            token apiName = "diffuse"
        }
    )
    float inputs:specular = 1.0 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular
        response of materials.  This is a non-physical control."""
        customData = {
            token apiName = "specular"
        }
    )
    bool inputs:normalize = false (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.
        This makes it easier to independently adjust the power and shape
        of the light, by causing the power to not vary with the area or
        angular size of the light."""
        customData = {
            token apiName = "normalize"
        }
    )
    color3f inputs:color = (1, 1, 1) (
        doc = """The color of emitted light, in energy-linear terms."""
        customData = {
            token apiName = "color"
        }
    )
    bool inputs:enableColorTemperature = false (
        displayName = "Enable Color Temperature"
        doc = """Enables using colorTemperature."""
        customData = {
            token apiName = "enableColorTemperature"
        }
    )
    float inputs:colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the
        white point.  The default is a common white point, D65.  Lower
        values are warmer and higher values are cooler.  The valid range
        is from 1000 to 10000. Only takes effect when
        enableColorTemperature is set to true.  When active, the
        computed result multiplies against the color attribute.
        See UsdLuxBlackbodyTemperatureAsRgb()."""
        customData = {
            token apiName = "colorTemperature"
        }
    )
    rel light:filters (
        doc = """Relationship to the light filters that apply to this light."""
        customData = {
            token apiName = "filters"
        }
    )
}

class "MeshLightAPI" (
    inherits = </APISchemaBase>
    doc = """This is the preferred API schema to apply to 
    \\ref UsdGeomMesh "Mesh" type prims when adding light behaviors to a mesh. 
    At its base, this API schema has the built-in behavior of applying LightAPI 
    to the mesh and overriding the default materialSyncMode to allow the 
    emission/glow of the bound material to affect the color of the light. 
    But, it additionally serves as a hook for plugins to attach additional 
    properties to "mesh lights" through the creation of API schemas which are 
    authored to auto-apply to MeshLightAPI.
    \\see \\ref Usd_AutoAppliedAPISchemas
    """
    prepend apiSchemas = ["LightAPI"]
) {
    uniform token light:shaderId = "MeshLight" (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
    uniform token light:materialSyncMode = "materialGlowTintsLight" (
        customData = {
            token apiName = ""
        }
    )
}

class "VolumeLightAPI" (
    inherits = </APISchemaBase>
    doc = """This is the preferred API schema to apply to 
    \\ref UsdVolVolume "Volume" type prims when adding light behaviors to a 
    volume. At its base, this API schema has the built-in behavior of applying 
    LightAPI to the volume and overriding the default materialSyncMode to allow 
    the emission/glow of the bound material to affect the color of the light. 
    But, it additionally serves as a hook for plugins to attach additional 
    properties to "volume lights" through the creation of API schemas which are 
    authored to auto-apply to VolumeLightAPI.
    \\see \\ref Usd_AutoAppliedAPISchemas
    """
    prepend apiSchemas = ["LightAPI"]
) {
    uniform token light:shaderId = "VolumeLight" (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
    uniform token light:materialSyncMode = "materialGlowTintsLight" (
        customData = {
            token apiName = ""
        }
    )
}

class "ListAPI" (
    inherits = </APISchemaBase>
    doc = """API schema to support discovery and publishing of lights in a scene.

    \\section UsdLuxListAPI_Discovery Discovering Lights via Traversal
    
    To motivate this API, consider what is required to discover all
    lights in a scene.  We must load all payloads and traverse all prims:

    \\code
    01  // Load everything on the stage so we can find all lights,
    02  // including those inside payloads
    03  stage->Load();
    04  
    05  // Traverse all prims, checking if they have an applied UsdLuxLightAPI
    06  // (Note: ignoring instancing and a few other things for simplicity)
    07  SdfPathVector lights;
    08  for (UsdPrim prim: stage->Traverse()) {
    09      if (prim.HasAPI<UsdLuxLightAPI>()) {
    10          lights.push_back(i->GetPath());
    11      }
    12  }
    \\endcode

    This traversal -- suitably elaborated to handle certain details --
    is the first and simplest thing UsdLuxListAPI provides.
    UsdLuxListAPI::ComputeLightList() performs this traversal and returns
    all lights in the scene:

    \\code
    01  UsdLuxListAPI listAPI(stage->GetPseudoRoot());
    02  SdfPathVector lights = listAPI.ComputeLightList();
    \\endcode

    \\section UsdLuxListAPI_LightList Publishing a Cached Light List

    Consider a USD client that needs to quickly discover lights but
    wants to defer loading payloads and traversing the entire scene
    where possible, and is willing to do up-front computation and
    caching to achieve that.

    UsdLuxListAPI provides a way to cache the computed light list,
    by publishing the list of lights onto prims in the model
    hierarchy.  Consider a big set that contains lights:

    \\code
    01  def Xform "BigSetWithLights" (
    02      kind = "assembly"
    03      payload = @BigSetWithLights.usd@   // Heavy payload
    04  ) {
    05      // Pre-computed, cached list of lights inside payload
    06      rel lightList = [
    07          <./Lights/light_1>,
    08          <./Lights/light_2>,
    09          ...
    10      ]
    11      token lightList:cacheBehavior = "consumeAndContinue";
    12  }
    \\endcode

    The lightList relationship encodes a set of lights, and the
    lightList:cacheBehavior property provides fine-grained
    control over how to use that cache.  (See details below.)

    The cache can be created by first invoking
    ComputeLightList(ComputeModeIgnoreCache) to pre-compute the list
    and then storing the result with UsdLuxListAPI::StoreLightList().

    To enable efficient retrieval of the cache, it should be stored
    on a model hierarchy prim.  Furthermore, note that while you can
    use a UsdLuxListAPI bound to the pseudo-root prim to query the
    lights (as in the example above) because it will perform a
    traversal over descendants, you cannot store the cache back to the
    pseduo-root prim.

    To consult the cached list, we invoke
    ComputeLightList(ComputeModeConsultModelHierarchyCache):

    \\code
    01  // Find and load all lights, using lightList cache where available
    02  UsdLuxListAPI list(stage->GetPseudoRoot());
    03  SdfPathSet lights = list.ComputeLightList(
    04      UsdLuxListAPI::ComputeModeConsultModelHierarchyCache);
    05  stage.LoadAndUnload(lights, SdfPathSet());
    \\endcode

    In this mode, ComputeLightList() will traverse the model
    hierarchy, accumulating cached light lists.

    \\section UsdLuxListAPI_CacheBehavior Controlling Cache Behavior

    The lightList:cacheBehavior property gives additional fine-grained
    control over cache behavior:

    \\li The fallback value, "ignore", indicates that the lightList should
    be disregarded.  This provides a way to invalidate cache entries.
    Note that unless "ignore" is specified, a lightList with an empty
    list of targets is considered a cache indicating that no lights
    are present.

    \\li The value "consumeAndContinue" indicates that the cache should
    be consulted to contribute lights to the scene, and that recursion
    should continue down the model hierarchy in case additional lights
    are added as descedants. This is the default value established when
    StoreLightList() is invoked. This behavior allows the lights within
    a large model, such as the BigSetWithLights example above, to be
    published outside the payload, while also allowing referencing and
    layering to add additional lights over that set.

    \\li The value "consumeAndHalt" provides a way to terminate recursive
    traversal of the scene for light discovery. The cache will be
    consulted but no descendant prims will be examined.

    \\section UsdLuxListAPI_Instancing Instancing

    Where instances are present, UsdLuxListAPI::ComputeLightList() will
    return the instance-unique paths to any lights discovered within
    those instances.  Lights within a UsdGeomPointInstancer will
    not be returned, however, since they cannot be referred to
    solely via paths.
"""
) {
    rel lightList (
        doc = """Relationship to lights in the scene."""
    )
    token lightList:cacheBehavior (
        doc = """Controls how the lightList should be interpreted.
        Valid values are:
        - consumeAndHalt: The lightList should be consulted,
          and if it exists, treated as a final authoritative statement
          of any lights that exist at or below this prim, halting
          recursive discovery of lights.
        - consumeAndContinue: The lightList should be consulted,
          but recursive traversal over nameChildren should continue
          in case additional lights are added by descendants.
        - ignore: The lightList should be entirely ignored.  This
          provides a simple way to temporarily invalidate an existing
          cache.  This is the fallback behavior.
        """
        allowedTokens = ["consumeAndHalt", "consumeAndContinue", "ignore"]
    )
}

class "ShapingAPI" (
    inherits = </APISchemaBase>
    doc = """Controls for shaping a light's emission."""
    customData = {
        string extraIncludes = """
#include "pxr/usd/usdShade/input.h"
#include "pxr/usd/usdShade/output.h" """
    }

) {
    float inputs:shaping:focus = 0 (
        displayGroup = "Shaping"
        doc = """A control to shape the spread of light.  Higher focus
        values pull light towards the center and narrow the spread.
        Implemented as an off-axis cosine power exponent.
        TODO: clarify semantics"""
        customData = {
            token apiName = "shaping:focus"
        }
    )
    color3f inputs:shaping:focusTint = (0, 0, 0) (
        displayGroup = "Shaping"
        doc = """Off-axis color tint.  This tints the emission in the
        falloff region.  The default tint is black.
        TODO: clarify semantics"""
        customData = {
            token apiName = "shaping:focusTint"
        }
    )
    float inputs:shaping:cone:angle = 90 (
        displayGroup = "Shaping"
        doc = """Angular limit off the primary axis to restrict the
        light spread."""
        customData = {
            token apiName = "shaping:cone:angle"
        }
    )
    float inputs:shaping:cone:softness = 0 (
        displayGroup = "Shaping"
        doc = """Controls the cutoff softness for cone angle.
        TODO: clarify semantics"""
        customData = {
            token apiName = "shaping:cone:softness"
        }
    )
    asset inputs:shaping:ies:file (
        displayGroup = "Shaping"
        doc = """An IES (Illumination Engineering Society) light
        profile describing the angular distribution of light."""
        customData = {
            token apiName = "shaping:ies:file"
        }
    )
    float inputs:shaping:ies:angleScale = 0 (
        displayGroup = "Shaping"
        doc = """Rescales the angular distribution of the IES profile.
        TODO: clarify semantics"""
        customData = {
            token apiName = "shaping:ies:angleScale"
        }
    )
    bool inputs:shaping:ies:normalize = false (
        displayGroup = "Shaping"
        doc = """Normalizes the IES profile so that it affects the shaping
        of the light while preserving the overall energy output."""
        customData = {
            token apiName = "shaping:ies:normalize"
        }
    )
}

class "ShadowAPI" (
    inherits = </APISchemaBase>
    doc = """Controls to refine a light's shadow behavior.  These are
    non-physical controls that are valuable for visual lighting work."""
    customData = {
        string extraIncludes = """
#include "pxr/usd/usdShade/input.h"
#include "pxr/usd/usdShade/output.h" """
    }

) {
    bool inputs:shadow:enable = true (
        displayGroup = "Shadows"
        doc = """Enables shadows to be cast by this light."""
        customData = {
            token apiName = "shadow:enable"
        }
    )
    color3f inputs:shadow:color = (0, 0, 0) (
        displayGroup = "Shadows"
        doc = """The color of shadows cast by the light.  This is a
        non-physical control.  The default is to cast black shadows."""
        customData = {
            token apiName = "shadow:color"
        }
    )
    float inputs:shadow:distance = -1.0 (
        displayGroup = "Shadows"
        doc = """The maximum distance shadows are cast.
        The default value (-1) indicates no limit.
        """
        customData = {
            token apiName = "shadow:distance"
        }
    )
    float inputs:shadow:falloff = -1.0 (
        displayGroup = "Shadows"
        doc = """The near distance at which shadow falloff begins.
        The default value (-1) indicates no falloff.
        """
        customData = {
            token apiName = "shadow:falloff"
        }
    )
    float inputs:shadow:falloffGamma = 1.0 (
        displayGroup = "Shadows"
        doc = """A gamma (i.e., exponential) control over shadow strength
        with linear distance within the falloff zone.
        This requires the use of shadowDistance and shadowFalloff."""
        customData = {
            token apiName = "shadow:falloffGamma"
        }
    )
}

class LightFilter "LightFilter" (
    inherits = </Xformable>
    doc = """A light filter modifies the effect of a light.
    Lights refer to filters via relationships so that filters may be
    shared.

    <b>Linking</b>

    Filters can be linked to geometry.  Linking controls which geometry
    a light-filter affects, when considering the light filters attached
    to a light illuminating the geometry.

    Linking is specified as a collection (UsdCollectionAPI) which can
    be accessed via GetFilterLinkCollection().
    """
    customData = {
        dictionary extraPlugInfo = {
            bool providesUsdShadeConnectableAPIBehavior = 1
        }
        string extraIncludes = """
#include "pxr/usd/usd/collectionAPI.h"
#include "pxr/usd/usdShade/input.h"
#include "pxr/usd/usdShade/output.h" """
    }
    prepend apiSchemas = ["CollectionAPI:filterLink"]
) {
    uniform bool collection:filterLink:includeRoot = 1 (
        customData = {
            token apiName = ""
        }
    )
    uniform token lightFilter:shaderId = "" (
        doc = """Default ID for the light filter's shader. 
        This defines the shader ID for this light filter when a render context 
        specific shader ID is not available. 

        \\see GetShaderId
        \\see GetShaderIdAttrForRenderContext
        \\see SdrRegistry::GetShaderNodeByIdentifier
        \\see SdrRegistry::GetShaderNodeByIdentifierAndType
        """
        customData = {
            token apiName = "shaderId"
        }
        displayGroup = "Internal"
    )

}

class "BoundableLightBase" (
    inherits = </Boundable>
    doc = """Base class for intrinsic lights that are boundable.

    The primary purpose of this class is to provide a direct API to the 
    functions provided by LightAPI for concrete derived light types.
    """
    customData = {
        string extraIncludes = """#include "pxr/usd/usdLux/lightAPI.h" """
    }
    prepend apiSchemas = ["LightAPI"]
) {
}

class "NonboundableLightBase" (
    inherits = </Xformable>
    doc = """Base class for intrinsic lights that are not boundable.

    The primary purpose of this class is to provide a direct API to the 
    functions provided by LightAPI for concrete derived light types.
    """
    customData = {
        string extraIncludes = """#include "pxr/usd/usdLux/lightAPI.h" """
    }
    prepend apiSchemas = ["LightAPI"]
) {
}

class DistantLight "DistantLight" (
    inherits = </NonboundableLightBase>
    doc = """Light emitted from a distant source along the -Z axis.
    Also known as a directional light."""
) {
    uniform token light:shaderId = "DistantLight" (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
    float inputs:angle = 0.53 (
        doc = """Angular size of the light in degrees.
        As an example, the Sun is approximately 0.53 degrees as seen from Earth.
        Higher values broaden the light and therefore soften shadow edges.
        """
        customData = {
            token apiName = "angle"
        }
    )
    float inputs:intensity = 50000 (
        doc = """Scales the emission of the light linearly.
        The DistantLight has a high default intensity to approximate the Sun."""
        customData = {
            token apiName = "intensity"
        }
    )
}

class DiskLight "DiskLight" (
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = 1
        }
    }
    inherits = </BoundableLightBase>
    doc = """Light emitted from one side of a circular disk.
    The disk is centered in the XY plane and emits light along the -Z axis."""
) {
    uniform token light:shaderId = "DiskLight"  (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
    float inputs:radius = 0.5 (
        doc = "Radius of the disk."
        customData = {
            token apiName = "radius"
        }
    )
}

class RectLight "RectLight" (
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = 1
        }
    }
    inherits = </BoundableLightBase>
    doc = """Light emitted from one side of a rectangle.
    The rectangle is centered in the XY plane and emits light along the -Z axis.
    The rectangle is 1 unit in length in the X and Y axis.  In the default 
    position, a texture file's min coordinates should be at (+X, +Y) and 
    max coordinates at (-X, -Y)."""
) {
    uniform token light:shaderId = "RectLight"  (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
    float inputs:width = 1 (
        doc = "Width of the rectangle, in the local X axis."
        customData = {
            token apiName = "width"
        }

    )
    float inputs:height = 1 (
        doc = "Height of the rectangle, in the local Y axis."
        customData = {
            token apiName = "height"
        }
    )
    asset inputs:texture:file (
        doc = """A color texture to use on the rectangle."""
        customData = {
            token apiName = "textureFile"
        }
    )
}

class SphereLight "SphereLight" (
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = 1
        }
    }
    inherits = </BoundableLightBase>
    doc = """Light emitted outward from a sphere."""
) {
    uniform token light:shaderId = "SphereLight"  (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
    float inputs:radius = 0.5 (
        doc = "Radius of the sphere."
        customData = {
            token apiName = "radius"
        }
    )
    bool treatAsPoint = false (
        doc = """A hint that this light can be treated as a 'point'
        light (effectively, a zero-radius sphere) by renderers that
        benefit from non-area lighting. Renderers that only support
        area lights can disregard this."""
    )
}

class CylinderLight "CylinderLight" (
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = 1
        }
    }
    inherits = </BoundableLightBase>
    doc = """Light emitted outward from a cylinder.
    The cylinder is centered at the origin and has its major axis on the X axis.
    The cylinder does not emit light from the flat end-caps.
    """
) {
    uniform token light:shaderId = "CylinderLight"  (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
    float inputs:length = 1 (
        doc = "Width of the rectangle, in the local X axis."
        customData = {
            token apiName = "length"
        }
    )
    float inputs:radius = 0.5 (
        doc = "Radius of the cylinder."
        customData = {
            token apiName = "radius"
        }
    )
    bool treatAsLine = false (
        doc = """A hint that this light can be treated as a 'line'
        light (effectively, a zero-radius cylinder) by renderers that
        benefit from non-area lighting. Renderers that only support
        area lights can disregard this."""
    )
}

class GeometryLight "GeometryLight" (
    inherits = </NonboundableLightBase>
    doc = """\\deprecated
    Light emitted outward from a geometric prim (UsdGeomGprim),
    which is typically a mesh."""
) {
    rel geometry (
        doc = """Relationship to the geometry to use as the light source."""
    )
    uniform token light:shaderId = "GeometryLight"  (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
}

class DomeLight "DomeLight" (
    inherits = </NonboundableLightBase>
    doc = """Light emitted inward from a distant external environment,
    such as a sky or IBL light probe.  The orientation of a dome light with a
    latlong texture is expected to match the OpenEXR specification for latlong 
    environment maps.  From the OpenEXR documentation:
    
    -------------------------------------------------------------------------
    Latitude-Longitude Map:
    
    The environment is projected onto the image using polar coordinates
    (latitude and longitude).  A pixel's x coordinate corresponds to
    its longitude, and the y coordinate corresponds to its latitude.
    Pixel (dataWindow.min.x, dataWindow.min.y) has latitude +pi/2 and
    longitude +pi; pixel (dataWindow.max.x, dataWindow.max.y) has
    latitude -pi/2 and longitude -pi.
    
    In 3D space, latitudes -pi/2 and +pi/2 correspond to the negative and
    positive y direction.  Latitude 0, longitude 0 points into positive
    z direction; and latitude 0, longitude pi/2 points into positive x
    direction.
    
    The size of the data window should be 2*N by N pixels (width by height),
    where N can be any integer greater than 0.
    -------------------------------------------------------------------------
"""
) {
    uniform token light:shaderId = "DomeLight"  (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
    asset inputs:texture:file (
        doc = """A color texture to use on the dome, such as an HDR (high
        dynamic range) texture intended for IBL (image based lighting)."""
        customData = {
            token apiName = "textureFile"
        }
    )
    token inputs:texture:format = "automatic" (
        allowedTokens = ["automatic", "latlong", "mirroredBall", "angular", "cubeMapVerticalCross"]
        doc = """Specifies the parameterization of the color map file.
        Valid values are:
        - automatic: Tries to determine the layout from the file itself.
          For example, Renderman texture files embed an explicit
          parameterization.
        - latlong: Latitude as X, longitude as Y.
        - mirroredBall: An image of the environment reflected in a
          sphere, using an implicitly orthogonal projection.
        - angular: Similar to mirroredBall but the radial dimension
          is mapped linearly to the angle, providing better sampling
          at the edges.
        - cubeMapVerticalCross: A cube map with faces laid out as a
          vertical cross.
        """
        customData = {
            token apiName = "textureFormat"
        }
    )
    rel portals (
        doc = """Optional portals to guide light sampling."""
    )
}

class PortalLight "PortalLight" (
    inherits = </BoundableLightBase>
    doc = """A rectangular portal in the local XY plane that guides sampling
    of a dome light.  Transmits light in the -Z direction.
    The rectangle is 1 unit in length."""
) {
    uniform token light:shaderId = "PortalLight"  (
        customData = {
            token apiName = ""
        }
        displayGroup = "Internal"
    )
    float3[] extent = [(-0.5, -0.5, 0.0), (0.5, 0.5, 0.0)] (
        doc = """Boundary extent of the unit rectangle in the XY plane that 
        defines the portal."""
        customData = {
            token apiName = ""
        }
    )
}

class PluginLight "PluginLight" (
    inherits = </Xformable>
    doc = """Light that provides properties that allow it to identify an 
    external SdrShadingNode definition, through UsdShadeNodeDefAPI, that can be 
    provided to render delegates without the need to provide a schema 
    definition for the light's type.

    \\see \\ref usdLux_PluginSchemas
"""
    prepend apiSchemas = ["NodeDefAPI", "LightAPI"]
    customData = {
        string extraIncludes = """
#include "pxr/usd/usdShade/nodeDefAPI.h" """
    }
) {
}

class PluginLightFilter "PluginLightFilter" (
    inherits = </LightFilter>
    doc = """Light filter that provides properties that allow it to identify an 
    external SdrShadingNode definition, through UsdShadeNodeDefAPI, that can be 
    provided to render delegates without the need to provide a schema 
    definition for the light filter's type.

    \\see \\ref usdLux_PluginSchemas
"""
    prepend apiSchemas = ["NodeDefAPI"]
    customData = {
        string extraIncludes = """
#include "pxr/usd/usdShade/nodeDefAPI.h" """
    }
) {
}
{
    "Plugins": [
        {
            "Info": {
                "Types": {
                    "ArResolver": {},
                    "ArDefaultResolver": {
                        "bases": [
                            "ArResolver"
                        ],
                        "implementsContexts": true
                    },
                    "ArPackageResolver": {}
                }
            },
            "LibraryPath": "", 
            "Name": "ar", 
            "ResourcePath": "resources", 
            "Root": "..", 
            "Type": "library"
        }
    ]
}
# Portions of this file auto-generated by usdGenSchema.
# Edits will survive regeneration except for comments and
# changes to types with autoGenerated=true.
{
    "Plugins": [
        {
            "Info": {
                "SdfMetadata": {
                    "constraintTargetIdentifier": {
                        "appliesTo": [
                            "attributes"
                        ], 
                        "default": "", 
                        "documentation": "Unique identifier within a model's namespace for an matrix-valued attribute representing a constraint target", 
                        "type": "token"
                    }, 
                    "elementSize": {
                        "appliesTo": [
                            "attributes"
                        ], 
                        "default": 1, 
                        "displayGroup": "Primvars", 
                        "documentation": "The number of values in a primvar's value array that must be aggregated for each element on the primitive.", 
                        "type": "int"
                    }, 
                    "inactiveIds": {
                        "appliesTo": [
                            "prims"
                        ], 
                        "type": "int64listop"
                    }, 
                    "interpolation": {
                        "appliesTo": [
                            "attributes"
                        ], 
                        "default": "constant", 
                        "displayGroup": "Primvars", 
                        "documentation": "How a primvar interpolates across a primitive; equivalent to RenderMan's 'class specifier'", 
                        "type": "token"
                    }, 
                    "metersPerUnit": {
                        "appliesTo": [
                            "layers"
                        ], 
                        "default": 0.01, 
                        "displayGroup": "Stage", 
                        "type": "double"
                    }, 
                    "unauthoredValuesIndex": {
                        "appliesTo": [
                            "attributes"
                        ], 
                        "default": -1, 
                        "displayGroup": "Primvars", 
                        "documentation": "The index that represents unauthored values in the indices array of an indexed primvar.", 
                        "type": "int"
                    }, 
                    "upAxis": {
                        "appliesTo": [
                            "layers"
                        ], 
                        "default": "Y", 
                        "displayGroup": "Stage", 
                        "type": "token"
                    }
                }, 
                "Types": {
                    "UsdGeomBasisCurves": {
                        "alias": {
                            "UsdSchemaBase": "BasisCurves"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomCurves"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomBoundable": {
                        "alias": {
                            "UsdSchemaBase": "Boundable"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomXformable"
                        ], 
                        "schemaKind": "abstractTyped"
                    }, 
                    "UsdGeomCamera": {
                        "alias": {
                            "UsdSchemaBase": "Camera"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomXformable"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomCapsule": {
                        "alias": {
                            "UsdSchemaBase": "Capsule"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomGprim"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomCone": {
                        "alias": {
                            "UsdSchemaBase": "Cone"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomGprim"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomCube": {
                        "alias": {
                            "UsdSchemaBase": "Cube"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomGprim"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomCurves": {
                        "alias": {
                            "UsdSchemaBase": "Curves"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomPointBased"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "abstractTyped"
                    }, 
                    "UsdGeomCylinder": {
                        "alias": {
                            "UsdSchemaBase": "Cylinder"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomGprim"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomGprim": {
                        "alias": {
                            "UsdSchemaBase": "Gprim"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomBoundable"
                        ], 
                        "schemaKind": "abstractTyped"
                    }, 
                    "UsdGeomHermiteCurves": {
                        "alias": {
                            "UsdSchemaBase": "HermiteCurves"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomCurves"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomImageable": {
                        "alias": {
                            "UsdSchemaBase": "Imageable"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdTyped"
                        ], 
                        "schemaKind": "abstractTyped"
                    }, 
                    "UsdGeomMesh": {
                        "alias": {
                            "UsdSchemaBase": "Mesh"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomPointBased"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomModelAPI": {
                        "alias": {
                            "UsdSchemaBase": "GeomModelAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdGeomMotionAPI": {
                        "alias": {
                            "UsdSchemaBase": "MotionAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdGeomNurbsCurves": {
                        "alias": {
                            "UsdSchemaBase": "NurbsCurves"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomCurves"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomNurbsPatch": {
                        "alias": {
                            "UsdSchemaBase": "NurbsPatch"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomPointBased"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomPointBased": {
                        "alias": {
                            "UsdSchemaBase": "PointBased"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomGprim"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "abstractTyped"
                    }, 
                    "UsdGeomPointInstancer": {
                        "alias": {
                            "UsdSchemaBase": "PointInstancer"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomBoundable"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomPoints": {
                        "alias": {
                            "UsdSchemaBase": "Points"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomPointBased"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomPrimvarsAPI": {
                        "alias": {
                            "UsdSchemaBase": "PrimvarsAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "nonAppliedAPI"
                    }, 
                    "UsdGeomScope": {
                        "alias": {
                            "UsdSchemaBase": "Scope"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomImageable"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomSphere": {
                        "alias": {
                            "UsdSchemaBase": "Sphere"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomGprim"
                        ], 
                        "implementsComputeExtent": true, 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomSubset": {
                        "alias": {
                            "UsdSchemaBase": "GeomSubset"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdTyped"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomVisibilityAPI": {
                        "alias": {
                            "UsdSchemaBase": "VisibilityAPI"
                        }, 
                        "apiSchemaCanOnlyApplyTo": [
                            "Imageable"
                        ], 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "singleApplyAPI"
                    }, 
                    "UsdGeomXform": {
                        "alias": {
                            "UsdSchemaBase": "Xform"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomXformable"
                        ], 
                        "schemaKind": "concreteTyped"
                    }, 
                    "UsdGeomXformCommonAPI": {
                        "alias": {
                            "UsdSchemaBase": "XformCommonAPI"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdAPISchemaBase"
                        ], 
                        "schemaKind": "nonAppliedAPI"
                    }, 
                    "UsdGeomXformable": {
                        "alias": {
                            "UsdSchemaBase": "Xformable"
                        }, 
                        "autoGenerated": true, 
                        "bases": [
                            "UsdGeomImageable"
                        ], 
                        "schemaKind": "abstractTyped"
                    }
                }
            }, 
            "LibraryPath": "", 
            "Name": "usdGeom", 
            "ResourcePath": "resources", 
            "Root": "..", 
            "Type": "library"
        }
    ]
}
#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "Imageable" (
    doc = """Base class for all prims that may require rendering or 
    visualization of some sort. The primary attributes of Imageable 
    are visibility and purpose, which each provide instructions for
    what geometry should be included for processing by rendering and other
    computations.

    \\deprecated Imageable also provides API for accessing primvars, which
    has been moved to the UsdGeomPrimvarsAPI schema, because primvars can now
    be applied on non-Imageable prim types.  This API is planned
    to be removed, UsdGeomPrimvarsAPI should be used directly instead."""
)
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class "VisibilityAPI" (
    doc = '''
    UsdGeomVisibilityAPI introduces properties that can be used to author
    visibility opinions.
   
    \\note
    Currently, this schema only introduces the attributes that are used to
    control purpose visibility. Later, this schema will define _all_
    visibility-related properties and UsdGeomImageable will no longer define
    those properties.
   
    The purpose visibility attributes added by this schema,
    _guideVisibility_, _proxyVisibility_, and _renderVisibility_ can each be
    used to control visibility for geometry of the corresponding purpose
    values, with the overall _visibility_ attribute acting as an
    override. I.e., if _visibility_ evaluates to "invisible", purpose
    visibility is invisible; otherwise, purpose visibility is determined by
    the corresponding purpose visibility attribute.

    Note that the behavior of _guideVisibility_ is subtly different from the
    _proxyVisibility_ and _renderVisibility_ attributes, in that "guide"
    purpose visibility always evaluates to either "invisible" or "visible",
    whereas the other attributes may yield computed values of "inherited" if
    there is no authored opinion on the attribute or inherited from an
    ancestor. This is motivated by the fact that, in Pixar"s user workflows,
    we have never found a need to have all guides visible in a scene by
    default, whereas we do find that flexibility useful for "proxy" and
    "render" geometry.

    This schema can only be applied to UsdGeomImageable prims. The
    UseGeomImageable schema provides API for computing the purpose visibility
    values that result from the attributes introduced by this schema.
    '''
)
{
    uniform token guideVisibility = "invisible" (
        allowedTokens = ["inherited", "invisible", "visible"]
        doc = '''
        This attribute controls visibility for geometry with purpose "guide".

        Unlike overall _visibility_, _guideVisibility_ is uniform, and
        therefore cannot be animated.

        Also unlike overall _visibility_, _guideVisibility_ is tri-state, in
        that a descendant with an opinion of "visible" overrides an ancestor
        opinion of "invisible".

        The _guideVisibility_ attribute works in concert with the overall
        _visibility_ attribute: The visibility of a prim with purpose "guide"
        is determined by the inherited values it receives for the _visibility_
        and _guideVisibility_ attributes. If _visibility_ evaluates to
        "invisible", the prim is invisible. If _visibility_ evaluates to
        "inherited" and _guideVisibility_ evaluates to "visible", then the
        prim is visible. __Otherwise, it is invisible.__
        '''
    )
    uniform token proxyVisibility = "inherited" (
        allowedTokens = ["inherited", "invisible", "visible"]
        doc = '''
        This attribute controls visibility for geometry with purpose "proxy".

        Unlike overall _visibility_, _proxyVisibility_ is uniform, and
        therefore cannot be animated.

        Also unlike overall _visibility_, _proxyVisibility_ is tri-state, in
        that a descendant with an opinion of "visible" overrides an ancestor
        opinion of "invisible".

        The _proxyVisibility_ attribute works in concert with the overall
        _visibility_ attribute: The visibility of a prim with purpose "proxy"
        is determined by the inherited values it receives for the _visibility_
        and _proxyVisibility_ attributes. If _visibility_ evaluates to
        "invisible", the prim is invisible. If _visibility_ evaluates to
        "inherited" then: If _proxyVisibility_ evaluates to "visible", then
        the prim is visible; if _proxyVisibility_ evaluates to "invisible",
        then the prim is invisible; if _proxyVisibility_ evaluates to
        "inherited", then the prim may either be visible or invisible,
        depending on a fallback value determined by the calling context.
        '''
    )
    uniform token renderVisibility = "inherited" (
        allowedTokens = ["inherited", "invisible", "visible"]
        doc = '''
        This attribute controls visibility for geometry with purpose
        "render".

        Unlike overall _visibility_, _renderVisibility_ is uniform, and
        therefore cannot be animated.

        Also unlike overall _visibility_, _renderVisibility_ is tri-state, in
        that a descendant with an opinion of "visible" overrides an ancestor
        opinion of "invisible".

        The _renderVisibility_ attribute works in concert with the overall
        _visibility_ attribute: The visibility of a prim with purpose "render"
        is determined by the inherited values it receives for the _visibility_
        and _renderVisibility_ attributes. If _visibility_ evaluates to
        "invisible", the prim is invisible. If _visibility_ evaluates to
        "inherited" then: If _renderVisibility_ evaluates to "visible", then
        the prim is visible; if _renderVisibility_ evaluates to "invisible",
        then the prim is invisible; if _renderVisibility_ evaluates to
        "inherited", then the prim may either be visible or invisible,
        depending on a fallback value determined by the calling context.
        '''
    )
}

class "PrimvarsAPI" (
    doc = """UsdGeomPrimvarsAPI encodes geometric \"primitive variables\",
    as UsdGeomPrimvar, which interpolate across a primitive's topology,
    can override shader inputs, and inherit down namespace.
    
    Which Method to Use to Retrieve Primvars
     
     While creating primvars is unambiguous (CreatePrimvar()), there are quite
     a few methods available for retrieving primvars, making it potentially
     confusing knowing which one to use.  Here are some guidelines:
     
     - If you are populating a GUI with the primvars already available for 
     authoring values on a prim, use GetPrimvars().
     - If you want all of the \"useful\" (e.g. to a renderer) primvars
     available at a prim, including those inherited from ancestor prims, use
     FindPrimvarsWithInheritance().  Note that doing so individually for many
     prims will be inefficient.
     - To find a particular primvar defined directly on a prim, which may
     or may not provide a value, use GetPrimvar().
     - To find a particular primvar defined on a prim or inherited from
     ancestors, which may or may not provide a value, use 
     FindPrimvarWithInheritance().
     - To *efficiently* query for primvars using the overloads of
     FindPrimvarWithInheritance() and FindPrimvarsWithInheritance(), one
     must first cache the results of FindIncrementallyInheritablePrimvars() for
     each non-leaf prim on the stage. """
)
{
}

class "Xformable" (
    doc = """Base class for all transformable prims, which allows arbitrary
    sequences of component affine transformations to be encoded.

    \\note 
    You may find it useful to review while reading
    this class description.
    
    <b>Supported Component Transformation Operations</b>
    
    UsdGeomXformable currently supports arbitrary sequences of the following
    operations, each of which can be encoded in an attribute of the proper
    shape in any supported precision:
    - translate - 3D
    - scale     - 3D
    - rotateX   - 1D angle in degrees
    - rotateY   - 1D angle in degrees
    - rotateZ   - 1D angle in degrees
    - rotateABC - 3D where ABC can be any combination of the six principle
                        Euler Angle sets: XYZ, XZY, YXZ, YZX, ZXY, ZYX.  See
                        \"note on rotation packing order\"
    - orient    - 4D (quaternion)
    - transform - 4x4D 
    
    <b>Creating a Component Transformation</b>
    
    To add components to a UsdGeomXformable prim, simply call AddXformOp()
    with the desired op type, as enumerated in \\ref UsdGeomXformOp::Type,
    and the desired precision, which is one of \\ref UsdGeomXformOp::Precision.
    Optionally, you can also provide an \"op suffix\" for the operator that 
    disambiguates it from other components of the same type on the same prim.  
    Application-specific transform schemas can use the suffixes to fill a role 
    similar to that played by AbcGeom::XformOp's \"Hint\" enums for their own 
    round-tripping logic.
    
    We also provide specific \"Add\" API for each type, for clarity and 
    conciseness, e.g. AddTranslateOp(), AddRotateXYZOp() etc.
    
    AddXformOp() will return a UsdGeomXformOp object, which is a schema on a 
    newly created UsdAttribute that provides convenience API for authoring
    and computing the component transformations.  The UsdGeomXformOp can then
    be used to author any number of timesamples and default for the op.
    
    Each successive call to AddXformOp() adds an operator that will be applied
    \"more locally\" than the preceding operator, just as if we were pushing
    transforms onto a transformation stack - which is precisely what should
    happen when the operators are consumed by a reader.
    
    \\note
    If you can, please try to use the UsdGeomXformCommonAPI, which wraps
    the UsdGeomXformable with an interface in which Op creation is taken
    care of for you, and there is a much higher chance that the data you
    author will be importable without flattening into other DCC's, as it
    conforms to a fixed set of Scale-Rotate-Translate Ops.
    
    \\sa \"Using the Authoring API\"
    
    <b>Data Encoding and Op Ordering</b>
    
    Because there is no \"fixed schema\" of operations, all of the attributes
    that encode transform operations are dynamic, and are scoped in 
    the namespace \"xformOp\". The second component of an attribute's name provides
    the type of operation, as listed above.  An \"xformOp\" attribute can 
    have additional namespace components derived from the opSuffix argument 
    to the AddXformOp() suite of methods, which provides a preferred way of 
    naming the ops such that we can have multiple \"translate\" ops with unique
    attribute names. For example, in the attribute named 
    \"xformOp:translate:maya:pivot\", \"translate\" is the type of operation and
    \"maya:pivot\" is the suffix.
    
    The following ordered list of attribute declarations in usda
    define a basic Scale-Rotate-Translate with XYZ Euler angles, wherein the
    translation is double-precision, and the remainder of the ops are single,
    in which we will:

    <ol>
    <li> Scale by 2.0 in each dimension
    <li> Rotate about the X, Y, and Z axes by 30, 60, and 90 degrees, respectively
    <li> Translate by 100 units in the Y direction
    </ol>

    \\code
    float3 xformOp:rotateXYZ = (30, 60, 90)
    float3 xformOp:scale = (2, 2, 2)
    double3 xformOp:translate = (0, 100, 0)
    uniform token[] xformOpOrder = [ \"xformOp:translate\", \"xformOp:rotateXYZ\", \"xformOp:scale\" ]
    \\endcode

    The attributes appear in the dictionary order in which USD, by default,
    sorts them.  To ensure the ops are recovered and evaluated in the correct
    order, the schema introduces the **xformOpOrder** attribute, which
    contains the names of the op attributes, in the precise sequence in which
    they should be pushed onto a transform stack. **Note** that the order is
    opposite to what you might expect, given the matrix algebra described in
     This also dictates order of op creation,
    since each call to AddXformOp() adds a new op to the end of the
    \\b xformOpOrder array, as a new \"most-local\" operation.  See 
    \"Example 2 below\" for C++ code that could
    have produced this USD.
    
    If it were important for the prim's rotations to be independently 
    overridable, we could equivalently (at some performance cost) encode
    the transformation also like so:
    \\code
    float xformOp:rotateX = 30
    float xformOp:rotateY = 60
    float xformOp:rotateZ = 90
    float3 xformOp:scale = (2, 2, 2)
    double3 xformOp:translate = (0, 100, 0)
    uniform token[] xformOpOrder = [ \"xformOp:translate\", \"xformOp:rotateZ\", \"xformOp:rotateY\", \"xformOp:rotateX\", \"xformOp:scale\" ]
    \\endcode
    
    Again, note that although we are encoding an XYZ rotation, the three
    rotations appear in the **xformOpOrder** in the opposite order, with Z,
    followed, by Y, followed by X.

    Were we to add a Maya-style scalePivot to the above example, it might 
    look like the following:
    \\code
    float3 xformOp:rotateXYZ = (30, 60, 90)
    float3 xformOp:scale = (2, 2, 2)
    double3 xformOp:translate = (0, 100, 0)
    double3 xformOp:translate:scalePivot
    uniform token[] xformOpOrder = [ \"xformOp:translate\", \"xformOp:rotateXYZ\", \"xformOp:translate:scalePivot\", \"xformOp:scale\" ]
    \\endcode

    <b>Paired \"Inverted\" Ops</b>

    We have been claiming that the ordered list of ops serves as a set
    of instructions to a transform stack, but you may have noticed in the last
    example that there is a missing operation - the pivot for the scale op
    needs to be applied in its inverse-form as a final (most local) op!  In the 
    AbcGeom::Xform schema, we would have encoded an actual \"final\" translation
    op whose value was authored by the exporter as the negation of the pivot's
    value.  However, doing so would be brittle in USD, given that each op can
    be independently overridden, and the constraint that one attribute must be
    maintained as the negation of the other in order for successful
    re-importation of the schema cannot be expressed in USD.
    
    Our solution leverages the **xformOpOrder** member of the schema, which,
    in addition to ordering the ops, may also contain one of two special
    tokens that address the paired op and \"stack resetting\" behavior.

    The \"paired op\" behavior is encoded as an \"!invert!\" prefix in 
    \\b xformOpOrder, as the result of an AddXformOp(isInverseOp=True) call.  
    The \\b xformOpOrder for the last example would look like:
    \\code
    uniform token[] xformOpOrder = [ \"xformOp:translate\", \"xformOp:rotateXYZ\", \"xformOp:translate:scalePivot\", \"xformOp:scale\", \"!invert!xformOp:translate:scalePivot\" ]
    \\endcode
    
    When asked for its value via UsdGeomXformOp::GetOpTransform(), an
    \"inverted\" Op (i.e. the \"inverted\" half of a set of paired Ops) will fetch 
    the value of its paired attribute and return its negation.  This works for 
    all op types - an error will be issued if a \"transform\" type op is singular 
    and cannot be inverted. When getting the authored value of an inverted op 
    via UsdGeomXformOp::Get(), the raw, uninverted value of the associated
    attribute is returned.

    For the sake of robustness, <b>setting a value on an inverted op is disallowed.</b>
    Attempting to set a value on an inverted op will result in a coding error 
    and no value being set. 
    
    <b>Resetting the Transform Stack</b>

    The other special op/token that can appear in xformOpOrder is
    \"!resetXformStack!\", which, appearing as the first element of 
    xformOpOrder, indicates this prim should not inherit the transformation
    of its namespace parent.  See SetResetXformStack()

    <b>Expected Behavior for \"Missing\" Ops</b>
    
    If an importer expects Scale-Rotate-Translate operations, but a prim
    has only translate and rotate ops authored, the importer should assume
    an identity scale.  This allows us to optimize the data a bit, if only
    a few components of a very rich schema (like Maya's) are authored in the
    app.
    
    \\anchor usdGeom_xformableExamples
    <b>Using the C++ API</b>
    
    #1. Creating a simple transform matrix encoding
    \\snippet examples.cpp CreateMatrixWithDefault
    
    #2. Creating the simple SRT from the example above
    \\snippet examples.cpp CreateExampleSRT
    
    #3. Creating a parameterized SRT with pivot using UsdGeomXformCommonAPI
    \\snippet examples.cpp CreateSRTWithDefaults
    
    #4. Creating a rotate-only pivot transform with animated
    rotation and translation
    \\snippet examples.cpp CreateAnimatedTransform
    
"""
)
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Scope "Scope" (
    doc = """Scope is the simplest grouping primitive, and does not carry the
    baggage of transformability.  Note that transforms should inherit down
    through a Scope successfully - it is just a guaranteed no-op from a
    transformability perspective."""
)
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class Xform "Xform" (
    doc = "Concrete prim schema for a transform, which implements Xformable "
)
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "Boundable" (
    doc = """Boundable introduces the ability for a prim to persistently
    cache a rectilinear, local-space, extent.
    
    Why Extent and not Bounds ?
    Boundable introduces the notion of \"extent\", which is a cached computation
    of a prim's local-space 3D range for its resolved attributes <b>at the
    layer and time in which extent is authored</b>.  We have found that with
    composed scene description, attempting to cache pre-computed bounds at
    interior prims in a scene graph is very fragile, given the ease with which
    one can author a single attribute in a stronger layer that can invalidate
    many authored caches - or with which a re-published, referenced asset can
    do the same.
    
    Therefore, we limit to precomputing (generally) leaf-prim extent, which
    avoids the need to read in large point arrays to compute bounds, and
    provides UsdGeomBBoxCache the means to efficiently compute and
    (session-only) cache intermediate bounds.  You are free to compute and
    author intermediate bounds into your scenes, of course, which may work
    well if you have sufficient locks on your pipeline to guarantee that once
    authored, the geometry and transforms upon which they are based will
    remain unchanged, or if accuracy of the bounds is not an ironclad
    requisite. 
    
    When intermediate bounds are authored on Boundable parents, the child prims
    will be pruned from BBox computation; the authored extent is expected to
    incorporate all child bounds."""
)
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "Gprim" (
    doc = '''Base class for all geometric primitives.  
    
    Gprim encodes basic graphical properties such as doubleSided and
    orientation, and provides primvars for "display color" and "display
    opacity" that travel with geometry to be used as shader overrides.  '''
)
{
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Cube "Cube" (
    doc = """Defines a primitive rectilinear cube centered at the origin.
    
    The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
    they all pack into the same volume/bounds."""
)
{
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent = [(-1, -1, -1), (1, 1, 1)] (
        doc = """Extent is re-defined on Cube only to provide a fallback value.
        \\sa UsdGeomGprim::GetExtentAttr()."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    double size = 2 (
        doc = """Indicates the length of each edge of the cube.  If you
        author size you must also author extent.
        
        \\sa GetExtentAttr()"""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Sphere "Sphere" (
    doc = """Defines a primitive sphere centered at the origin.
    
    The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
    they all pack into the same volume/bounds."""
)
{
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent = [(-1, -1, -1), (1, 1, 1)] (
        doc = """Extent is re-defined on Sphere only to provide a fallback
        value. \\sa UsdGeomGprim::GetExtentAttr()."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    double radius = 1 (
        doc = """Indicates the sphere's radius.  If you
        author radius you must also author extent.
        
        \\sa GetExtentAttr()"""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Cylinder "Cylinder" (
    doc = """Defines a primitive cylinder with closed ends, centered at the 
    origin, whose spine is along the specified axis.
    
    The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
    they all pack into the same volume/bounds."""
)
{
    uniform token axis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        doc = "The axis along which the spine of the cylinder is aligned"
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent = [(-1, -1, -1), (1, 1, 1)] (
        doc = """Extent is re-defined on Cylinder only to provide a fallback
        value. \\sa UsdGeomGprim::GetExtentAttr()."""
    )
    double height = 2 (
        doc = """The size of the cylinder's spine along the specified
        axis.  If you author height you must also author extent.
        
        \\sa GetExtentAttr()"""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    double radius = 1 (
        doc = """The radius of the cylinder. If you author radius
        you must also author extent.
        
        \\sa GetExtentAttr()"""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Capsule "Capsule" (
    doc = """Defines a primitive capsule, i.e. a cylinder capped by two half
    spheres, centered at the origin, whose spine is along the specified
    axis."""
)
{
    uniform token axis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        doc = "The axis along which the spine of the capsule is aligned"
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent = [(-0.5, -0.5, -1), (0.5, 0.5, 1)] (
        doc = """Extent is re-defined on Capsule only to provide a fallback
        value. \\sa UsdGeomGprim::GetExtentAttr()."""
    )
    double height = 1 (
        doc = """The size of the capsule's spine along the specified
        axis excluding the size of the two half spheres, i.e.
        the size of the cylinder portion of the capsule.
        If you author height you must also author extent.
        \\sa GetExtentAttr()"""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    double radius = 0.5 (
        doc = """The radius of the capsule.  If you
        author radius you must also author extent.
        
        \\sa GetExtentAttr()"""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Cone "Cone" (
    doc = """Defines a primitive cone, centered at the origin, whose spine
    is along the specified axis, with the apex of the cone pointing
    in the direction of the positive axis.
    
    The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
    they all pack into the same volume/bounds."""
)
{
    uniform token axis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        doc = "The axis along which the spine of the cone is aligned"
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent = [(-1, -1, -1), (1, 1, 1)] (
        doc = """Extent is re-defined on Cone only to provide a fallback
        value. \\sa UsdGeomGprim::GetExtentAttr()."""
    )
    double height = 2 (
        doc = """The size of the cone's spine along the specified
        axis.  If you author height you must also author extent.
        
        \\sa GetExtentAttr()"""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    double radius = 1 (
        doc = """The radius of the cone.  If you
        author radius you must also author extent.
        
        \\sa GetExtentAttr()"""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "PointBased" (
    doc = """Base class for all UsdGeomGprims that possess points,
    providing common attributes such as normals and velocities."""
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Mesh "Mesh" (
    doc = """Encodes a mesh with optional subdivision properties and features.

    As a point-based primitive, meshes are defined in terms of points that 
    are connected into edges and faces. Many references to meshes use the
    term 'vertex' in place of or interchangeably with 'points', while some
    use 'vertex' to refer to the 'face-vertices' that define a face.  To
    avoid confusion, the term 'vertex' is intentionally avoided in favor of
    'points' or 'face-vertices'.

    The connectivity between points, edges and faces is encoded using a
    common minimal topological description of the faces of the mesh.  Each
    face is defined by a set of face-vertices using indices into the Mesh's
    _points_ array (inherited from UsdGeomPointBased) and laid out in a
    single linear _faceVertexIndices_ array for efficiency.  A companion
    _faceVertexCounts_ array provides, for each face, the number of
    consecutive face-vertices in _faceVertexIndices_ that define the face.
    No additional connectivity information is required or constructed, so
    no adjacency or neighborhood queries are available.

    A key property of this mesh schema is that it encodes both subdivision
    surfaces and simpler polygonal meshes. This is achieved by varying the
    _subdivisionScheme_ attribute, which is set to specify Catmull-Clark
    subdivision by default, so polygonal meshes must always be explicitly
    declared. The available subdivision schemes and additional subdivision
    features encoded in optional attributes conform to the feature set of
    OpenSubdiv
    (https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html).

    \\anchor UsdGeom_Mesh_Primvars
    __A Note About Primvars__

    The following list clarifies the number of elements for and the
    interpolation behavior of the different primvar interpolation types
    for meshes:

    - __constant__: One element for the entire mesh; no interpolation.
    - __uniform__: One element for each face of the mesh; elements are
      typically not interpolated but are inherited by other faces derived
      from a given face (via subdivision, tessellation, etc.).
    - __varying__: One element for each point of the mesh;
      interpolation of point data is always linear.
    - __vertex__: One element for each point of the mesh;
      interpolation of point data is applied according to the
      _subdivisionScheme_ attribute.
    - __faceVarying__: One element for each of the face-vertices that
      define the mesh topology; interpolation of face-vertex data may
      be smooth or linear, according to the _subdivisionScheme_ and
      _faceVaryingLinearInterpolation_ attributes.

    Primvar interpolation types and related utilities are described more
    generally in \\ref Usd_InterpolationVals.

    \\anchor UsdGeom_Mesh_Normals
    __A Note About Normals__

    Normals should not be authored on a subdivision mesh, since subdivision
    algorithms define their own normals. They should only be authored for
    polygonal meshes (_subdivisionScheme_ = \"none\").

    The _normals_ attribute inherited from UsdGeomPointBased is not a generic
    primvar, but the number of elements in this attribute will be determined by
    its _interpolation_.  See .
    If _normals_ and _primvars:normals_ are both specified, the latter has
    precedence.  If a polygonal mesh specifies __neither__ _normals_ nor
    _primvars:normals_, then it should be treated and rendered as faceted,
    with no attempt to compute smooth normals.

    The normals generated for smooth subdivision schemes, e.g. Catmull-Clark
    and Loop, will likewise be smooth, but others, e.g. Bilinear, may be
    discontinuous between faces and/or within non-planar irregular faces."""
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    int[] cornerIndices = [] (
        doc = """The indices of points for which a corresponding sharpness
        value is specified in _cornerSharpnesses_ (so the size of this array
        must match that of _cornerSharpnesses_)."""
    )
    float[] cornerSharpnesses = [] (
        doc = """The sharpness values associated with a corresponding set of
        points specified in _cornerIndices_ (so the size of this array must
        match that of _cornerIndices_). Use the constant `SHARPNESS_INFINITE`
        for a perfectly sharp corner."""
    )
    int[] creaseIndices = [] (
        doc = """The indices of points grouped into sets of successive pairs
        that identify edges to be creased. The size of this array must be
        equal to the sum of all elements of the _creaseLengths_ attribute."""
    )
    int[] creaseLengths = [] (
        doc = """The length of this array specifies the number of creases
        (sets of adjacent sharpened edges) on the mesh. Each element gives
        the number of points of each crease, whose indices are successively
        laid out in the _creaseIndices_ attribute. Since each crease must
        be at least one edge long, each element of this array must be at
        least two."""
    )
    float[] creaseSharpnesses = [] (
        doc = """The per-crease or per-edge sharpness values for all creases.
        Since _creaseLengths_ encodes the number of points in each crease,
        the number of elements in this array will be either len(creaseLengths)
        or the sum over all X of (creaseLengths[X] - 1). Note that while
        the RI spec allows each crease to have either a single sharpness
        or a value per-edge, USD will encode either a single sharpness
        per crease on a mesh, or sharpnesses for all edges making up
        the creases on a mesh.  Use the constant `SHARPNESS_INFINITE` for a
        perfectly sharp crease."""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    token faceVaryingLinearInterpolation = "cornersPlus1" (
        allowedTokens = ["none", "cornersOnly", "cornersPlus1", "cornersPlus2", "boundaries", "all"]
        doc = '''Specifies how elements of a primvar of interpolation type
        "faceVarying" are interpolated for subdivision surfaces. Interpolation
        can be as smooth as a "vertex" primvar or constrained to be linear at
        features specified by several options.  Valid values correspond to
        choices available in OpenSubdiv:

        - __none__: No linear constraints or sharpening, smooth everywhere
        - __cornersOnly__: Sharpen corners of discontinuous boundaries only,
          smooth everywhere else
        - __cornersPlus1__: The default, same as "cornersOnly" plus additional
          sharpening at points where three or more distinct face-varying
          values occur
        - __cornersPlus2__: Same as "cornersPlus1" plus additional sharpening
          at points with at least one discontinuous boundary corner or
          only one discontinuous boundary edge (a dart)
        - __boundaries__: Piecewise linear along discontinuous boundaries,
          smooth interior
        - __all__: Piecewise linear everywhere

        These are illustrated and described in more detail in the OpenSubdiv
        documentation:
        https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html#face-varying-interpolation-rules'''
    )
    int[] faceVertexCounts (
        doc = """Provides the number of vertices in each face of the mesh, 
        which is also the number of consecutive indices in _faceVertexIndices_
        that define the face.  The length of this attribute is the number of
        faces in the mesh.  If this attribute has more than
        one timeSample, the mesh is considered to be topologically varying."""
    )
    int[] faceVertexIndices (
        doc = """Flat list of the index (into the _points_ attribute) of each
        vertex of each face in the mesh.  If this attribute has more than
        one timeSample, the mesh is considered to be topologically varying."""
    )
    int[] holeIndices = [] (
        doc = """The indices of all faces that should be treated as holes,
        i.e. made invisible. This is traditionally a feature of subdivision
        surfaces and not generally applied to polygonal meshes."""
    )
    token interpolateBoundary = "edgeAndCorner" (
        allowedTokens = ["none", "edgeOnly", "edgeAndCorner"]
        doc = '''Specifies how subdivision is applied for faces adjacent to
        boundary edges and boundary points. Valid values correspond to choices
        available in OpenSubdiv:

        - __none__: No boundary interpolation is applied and boundary faces are
          effectively treated as holes
        - __edgeOnly__: A sequence of boundary edges defines a smooth curve to
          which the edges of subdivided boundary faces converge
        - __edgeAndCorner__: The default, similar to "edgeOnly" but the smooth
          boundary curve is made sharp at corner points

        These are illustrated and described in more detail in the OpenSubdiv
        documentation:
        https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html#boundary-interpolation-rules'''
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    uniform token subdivisionScheme = "catmullClark" (
        allowedTokens = ["catmullClark", "loop", "bilinear", "none"]
        doc = '''The subdivision scheme to be applied to the surface.
        Valid values are:

        - __catmullClark__: The default, Catmull-Clark subdivision; preferred
          for quad-dominant meshes (generalizes B-splines); interpolation
          of point data is smooth (non-linear)
        - __loop__: Loop subdivision; preferred for purely triangular meshes;
          interpolation of point data is smooth (non-linear)
        - __bilinear__: Subdivision reduces all faces to quads (topologically
          similar to "catmullClark"); interpolation of point data is bilinear
        - __none__: No subdivision, i.e. a simple polygonal mesh; interpolation
          of point data is linear

        Polygonal meshes are typically lighter weight and faster to render,
        depending on renderer and render mode.  Use of "bilinear" will produce
        a similar shape to a polygonal mesh and may offer additional guarantees
        of watertightness and additional subdivision features (e.g. holes) but
        may also not respect authored normals.'''
    )
    token triangleSubdivisionRule = "catmullClark" (
        allowedTokens = ["catmullClark", "smooth"]
        doc = '''Specifies an option to the subdivision rules for the
        Catmull-Clark scheme to try and improve undesirable artifacts when
        subdividing triangles.  Valid values are "catmullClark" for the
        standard rules (the default) and "smooth" for the improvement.

        See https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html#triangle-subdivision-rule'''
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class GeomSubset "GeomSubset" (
    doc = """Encodes a subset of a piece of geometry (i.e. a UsdGeomImageable) 
    as a set of indices. Currently only supports encoding of face-subsets, but 
    could be extended in the future to support subsets representing edges, 
    segments, points etc.

    To apply to a geometric prim, a GeomSubset prim must be defined as a 
    child of it in namespace. This restriction makes it easy and efficient 
    to discover subsets of a prim. We might want to relax this restriction if 
    it's common to have multiple <b>families</b> of subsets on a gprim and if 
    it's useful to be able to organize subsets belonging to a </b>family</b> 
    under a common scope. See 'familyName' attribute for more info on defining 
    a family of subsets.

    Note that a GeomSubset isn't an imageable (i.e. doesn't derive from
    UsdGeomImageable). So, you can't author <b>visibility</b> for it or 
    override its <b>purpose</b>.

    Materials are bound to GeomSubsets just as they are for regular 
    geometry using API available in UsdShade (UsdShadeMaterial::Bind).
"""
)
{
    uniform token elementType = "face" (
        allowedTokens = ["face"]
        doc = '''The type of element that the indices target. Currently only 
        allows "face" and defaults to it.'''
    )
    uniform token familyName = "" (
        doc = '''The name of the family of subsets that this subset belongs to. 
        This is optional and is primarily useful when there are multiple 
        families of subsets under a geometric prim. In some cases, this could 
        also be used for achieving proper roundtripping of subset data between 
        DCC apps.
        When multiple subsets belonging to a prim have the same familyName, they 
        are said to belong to the family. A <i>familyType</i> value can be 
        encoded on the owner of a family of subsets as a token using the static 
        method UsdGeomSubset::SetFamilyType(). "familyType" can have one of the 
        following values:
        <ul><li><b>UsdGeomTokens->partition</b>: implies that every element of 
        the whole geometry appears exactly once in only one of the subsets
        belonging to the family.</li>
        <li><b>UsdGeomTokens->nonOverlapping</b>: an element that appears in one 
        subset may not appear in any other subset belonging to the family.</li>
        <li><b>UsdGeomTokens->unrestricted</b>: implies that there are no
        restrictions w.r.t. the membership of elements in the subsets. They 
        could be overlapping and the union of all subsets in the family may 
        not represent the whole.</li>
        </ul>
        \\note The validity of subset data is not enforced by the authoring 
        APIs, however they can be checked using UsdGeomSubset::ValidateFamily().
        '''
    )
    int[] indices = [] (
        doc = """The set of indices included in this subset. The indices need not 
        be sorted, but the same index should not appear more than once."""
    )
}

class NurbsPatch "NurbsPatch" (
    doc = """Encodes a rational or polynomial non-uniform B-spline
    surface, with optional trim curves.
    
    The encoding mostly follows that of RiNuPatch and RiTrimCurve: 
    https://renderman.pixar.com/resources/current/RenderMan/geometricPrimitives.html#rinupatch , with some minor renaming and coalescing for clarity.
    
    The layout of control vertices in the points attribute inherited
    from UsdGeomPointBased is row-major with U considered rows, and V columns.
    
    \\anchor UsdGeom_NurbsPatch_Form
    <b>NurbsPatch Form</b>
    
    The authored points, orders, knots, weights, and ranges are all that is
    required to render the nurbs patch.  However, the only way to model closed
    surfaces with nurbs is to ensure that the first and last control points
    along the given axis are coincident.  Similarly, to ensure the surface is
    not only closed but also C2 continuous, the last order - 1 control
    points must be (correspondingly) coincident with the first order - 1
    control points, and also the spacing of the last corresponding knots
    must be the same as the first corresponding knots.
    
    <b>Form</b> is provided as an aid to interchange between modeling and
    animation applications so that they can robustly identify the intent with
    which the surface was modelled, and take measures (if they are able) to
    preserve the continuity/concidence constraints as the surface may be rigged
    or deformed.  
    - An open-form NurbsPatch has no continuity constraints.
    - A closed-form NurbsPatch expects the first and last control points
    to overlap
    - A periodic-form NurbsPatch expects the first and last
    order - 1 control points to overlap.
    
    <b>Nurbs vs Subdivision Surfaces</b>
    
    Nurbs are an important modeling primitive in CAD/CAM tools and early
    computer graphics DCC's.  Because they have a natural UV parameterization
    they easily support \"trim curves\", which allow smooth shapes to be
    carved out of the surface.
    
    However, the topology of the patch is always rectangular, and joining two 
    nurbs patches together (especially when they have differing numbers of
    spans) is difficult to do smoothly.  Also, nurbs are not supported by
    the Ptex texturing technology (http://ptex.us).
    
    Neither of these limitations are shared by subdivision surfaces; therefore,
    although they do not subscribe to trim-curve-based shaping, subdivs are
    often considered a more flexible modeling primitive.
    """
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    double[] pointWeights (
        doc = """Optionally provides \"w\" components for each control point,
        thus must be the same length as the points attribute.  If authored,
        the patch will be rational.  If unauthored, the patch will be
        polynomial, i.e. weight for all points is 1.0.
        \\note Some DCC's pre-weight the points, but in this schema, 
        points are not pre-weighted."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    int[] trimCurve:counts (
        doc = '''Each element specifies how many curves are present in each
        "loop" of the trimCurve, and the length of the array determines how
        many loops the trimCurve contains.  The sum of all elements is the
        total nuber of curves in the trim, to which we will refer as 
        nCurves in describing the other trim attributes.'''
    )
    double[] trimCurve:knots (
        doc = """Flat list of parametric values for each of the
        nCurves curves.  There will be as many knots as the sum over
        all elements of vertexCounts plus the sum over all elements of
        orders."""
    )
    int[] trimCurve:orders (
        doc = "Flat list of orders for each of the nCurves curves."
    )
    double3[] trimCurve:points (
        doc = """Flat list of homogeneous 2D points (u, v, w) that comprise
        the nCurves curves.  The number of points should be equal to the
        um over all elements of vertexCounts."""
    )
    double2[] trimCurve:ranges (
        doc = """Flat list of minimum and maximum parametric values 
        (as defined by knots) for each of the nCurves curves."""
    )
    int[] trimCurve:vertexCounts (
        doc = """Flat list of number of vertices for each of the
         nCurves curves."""
    )
    uniform token uForm = "open" (
        allowedTokens = ["open", "closed", "periodic"]
        doc = '''Interpret the control grid and knot vectors as representing
        an open, geometrically closed, or geometrically closed and C2 continuous
        surface along the U dimension.
        \\sa "NurbsPatch Form" '''
    )
    double[] uKnots (
        doc = """Knot vector for U direction providing U parameterization.
        The length of this array must be ( uVertexCount + uOrder ), and its
        entries must take on monotonically increasing values."""
    )
    int uOrder (
        doc = """Order in the U direction.  Order must be positive and is
        equal to the degree of the polynomial basis to be evaluated, plus 1."""
    )
    double2 uRange (
        doc = """Provides the minimum and maximum parametric values (as defined
        by uKnots) over which the surface is actually defined.  The minimum
        must be less than the maximum, and greater than or equal to the
        value of uKnots[uOrder-1].  The maxium must be less than or equal
        to the last element's value in uKnots."""
    )
    int uVertexCount (
        doc = """Number of vertices in the U direction.  Should be at least as
        large as uOrder."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    uniform token vForm = "open" (
        allowedTokens = ["open", "closed", "periodic"]
        doc = '''Interpret the control grid and knot vectors as representing
        an open, geometrically closed, or geometrically closed and C2 continuous
        surface along the V dimension.
        \\sa "NurbsPatch Form" '''
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    double[] vKnots (
        doc = """Knot vector for V direction providing U parameterization.
        The length of this array must be ( vVertexCount + vOrder ), and its
        entries must take on monotonically increasing values."""
    )
    int vOrder (
        doc = """Order in the V direction.  Order must be positive and is
        equal to the degree of the polynomial basis to be evaluated, plus 1."""
    )
    double2 vRange (
        doc = """Provides the minimum and maximum parametric values (as defined
        by vKnots) over which the surface is actually defined.  The minimum
        must be less than the maximum, and greater than or equal to the
        value of vKnots[vOrder-1].  The maxium must be less than or equal
        to the last element's value in vKnots."""
    )
    int vVertexCount (
        doc = """Number of vertices in the V direction.  Should be at least as
        large as vOrder."""
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "Curves" (
    doc = """Base class for UsdGeomBasisCurves, UsdGeomNurbsCurves, and
             UsdGeomHermiteCurves.  The BasisCurves schema is designed to be
             analagous to offline renderers' notion of batched curves (such as
             the classical RIB definition via Basis and Curves statements),
             while the NurbsCurve schema is designed to be analgous to the
             NURBS curves found in packages like Maya and Houdini while
             retaining their consistency with the RenderMan specification for
             NURBS Patches. HermiteCurves are useful for the
             interchange of animation guides and paths.

             It is safe to use the length of the curve vertex count to derive
             the number of curves and the number and layout of curve vertices,
             but this schema should NOT be used to derive the number of curve
             points. While vertex indices are implicit in all shipped
             descendent types of this schema, one should not assume that all
             internal or future shipped schemas will follow this pattern. Be
             sure to key any indexing behavior off the concrete type, not this
             abstract type.
             """
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    int[] curveVertexCounts (
        doc = """Curves-derived primitives can represent multiple distinct,
        potentially disconnected curves.  The length of 'curveVertexCounts'
        gives the number of such curves, and each element describes the
        number of vertices in the corresponding curve"""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float[] widths (
        doc = """Provides width specification for the curves, whose application
        will depend on whether the curve is oriented (normals are defined for
        it), in which case widths are \"ribbon width\", or unoriented, in which
        case widths are cylinder width.  'widths' is not a generic Primvar,
        but the number of elements in this attribute will be determined by
        its 'interpolation'.  See .  If 'widths'
        and 'primvars:widths' are both specified, the latter has precedence."""
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class BasisCurves "BasisCurves" (
    doc = """BasisCurves are a batched curve representation analogous to the
    classic RIB definition via Basis and Curves statements. BasisCurves are
    often used to render dense aggregate geometry like hair or grass.

    A 'matrix' and 'vstep' associated with the basis are used to
    interpolate the vertices of a cubic BasisCurves. (The basis attribute
    is unused for linear BasisCurves.)
    
    A single prim may have many curves whose count is determined implicitly by
    the length of the curveVertexCounts vector.  Each individual curve is
    composed of one or more segments. Each segment is defined by four vertices
    for cubic curves and two vertices for linear curves. See the next section
    for more information on how to map curve vertex counts to segment counts.

    Segment Indexing
    Interpolating a curve requires knowing how to decompose it into its 
    individual segments.

    The segments of a cubic curve are determined by the vertex count,
    the wrap (periodicity), and the vstep of the basis. For linear
    curves, the basis token is ignored and only the vertex count and
    wrap are needed.
    
    cubic basis   | vstep
    ------------- | ------
    bezier        | 3
    catmullRom    | 1
    bspline       | 1
    
    The first segment of a cubic (nonperiodic) curve is always defined by its
    first four points. The vstep is the increment used to determine what
    vertex indices define the next segment.  For a two segment (nonperiodic)
    bspline basis curve (vstep = 1), the first segment will be defined by
    interpolating vertices [0, 1, 2, 3] and the second segment will be defined
    by [1, 2, 3, 4].  For a two segment bezier basis curve (vstep = 3), the
    first segment will be defined by interpolating vertices [0, 1, 2, 3] and
    the second segment will be defined by [3, 4, 5, 6].  If the vstep is not
    one, then you must take special care to make sure that the number of cvs
    properly divides by your vstep. (The indices described are relative to
    the initial vertex index for a batched curve.)

    For periodic curves, at least one of the curve's initial vertices are
    repeated to close the curve. For cubic curves, the number of vertices
    repeated is '4 - vstep'. For linear curves, only one vertex is repeated
    to close the loop.
    
    Pinned curves are a special case of nonperiodic curves that only affects
    the behavior of cubic Bspline and Catmull-Rom curves. To evaluate or render
    pinned curves, a client must effectively add 'phantom points' at the 
    beginning and end of every curve in a batch.  These phantom points
    are injected to ensure that the interpolated curve begins at P[0] and
    ends at P[n-1].
    
    For a curve with initial point P[0] and last point P[n-1], the phantom
    points are defined as.
    P[-1]  = 2 * P[0] - P[1]
    P[n] = 2 * P[n-1] - P[n-2]

    Pinned cubic curves will (usually) have to be unpacked into the standard
    nonperiodic representation before rendering. This unpacking can add some 
    additional overhead. However, using pinned curves reduces the amount of
    data recorded in a scene and (more importantly) better records the
    authors' intent for interchange.

    \\note The additional phantom points mean that the minimum curve vertex
    count for cubic bspline and catmullRom curves is 2.

    Linear curve segments are defined by two vertices.
    A two segment linear curve's first segment would be defined by
    interpolating vertices [0, 1]. The second segment would be defined by 
    vertices [1, 2]. (Again, for a batched curve, indices are relative to
    the initial vertex index.)

    When validating curve topology, each renderable entry in the
    curveVertexCounts vector must pass this check.

    type    | wrap                        | validitity
    ------- | --------------------------- | ----------------
    linear  | nonperiodic                 | curveVertexCounts[i] > 2
    linear  | periodic                    | curveVertexCounts[i] > 3
    cubic   | nonperiodic                 | (curveVertexCounts[i] - 4) % vstep == 0
    cubic   | periodic                    | (curveVertexCounts[i]) % vstep == 0
    cubic   | pinned (catmullRom/bspline) | (curveVertexCounts[i] - 2) >= 0

    Cubic Vertex Interpolation
 
    \\image html USDCurveBasisMatrix.png width=750
        
    Linear Vertex Interpolation
 
    Linear interpolation is always used on curves of type linear.
    't' with domain [0, 1], the curve is defined by the equation 
    P0 * (1-t) + P1 * t. t at 0 describes the first point and t at 1 describes
    the end point.

    Primvar Interpolation
        
    For cubic curves, primvar data can be either interpolated cubically between 
    vertices or linearly across segments.  The corresponding token
    for cubic interpolation is 'vertex' and for linear interpolation is
    'varying'.  Per vertex data should be the same size as the number
    of vertices in your curve.  Segment varying data is dependent on the 
    wrap (periodicity) and number of segments in your curve.  For linear curves,
    varying and vertex data would be interpolated the same way.  By convention 
    varying is the preferred interpolation because of the association of 
    varying with linear interpolation.
    
    \\image html USDCurvePrimvars.png 

    To convert an entry in the curveVertexCounts vector into a segment count 
    for an individual curve, apply these rules.  Sum up all the results in
    order to compute how many total segments all curves have.

    The following tables describe the expected segment count for the 'i'th
    curve in a curve batch as well as the entire batch. Python syntax
    like '[:]' (to describe all members of an array) and 'len(...)' 
    (to describe the length of an array) are used.

    type    | wrap                        | curve segment count                    | batch segment count                                                       
    ------- | --------------------------- | -------------------------------------- | --------------------------
    linear  | nonperiodic                 | curveVertexCounts[i] - 1               | sum(curveVertexCounts[:]) - len(curveVertexCounts)
    linear  | periodic                    | curveVertexCounts[i]                   | sum(curveVertexCounts[:])
    cubic   | nonperiodic                 | (curveVertexCounts[i] - 4) / vstep + 1 | sum(curveVertexCounts[:] - 4) / vstep + len(curveVertexCounts)
    cubic   | periodic                    | curveVertexCounts[i] / vstep           | sum(curveVertexCounts[:]) / vstep
    cubic   | pinned (catmullRom/bspline) | (curveVertexCounts[i] - 2) + 1         | sum(curveVertexCounts[:] - 2) + len(curveVertexCounts)
 
    The following table descrives the expected size of varying
    (linearly interpolated) data, derived from the segment counts computed
    above.

    wrap                | curve varying count          | batch varying count
    ------------------- | ---------------------------- | ------------------------------------------------
    nonperiodic/pinned  | segmentCounts[i] + 1         | sum(segmentCounts[:]) + len(curveVertexCounts)
    periodic            | segmentCounts[i]             | sum(segmentCounts[:])

    Both curve types additionally define 'constant' interpolation for the
    entire prim and 'uniform' interpolation as per curve data.

 
    \\note Take care when providing support for linearly interpolated data for
    cubic curves. Its shape doesn't provide a one to one mapping with either
    the number of curves (like 'uniform') or the number of vertices (like
    'vertex') and so it is often overlooked. This is the only primitive in
    UsdGeom (as of this writing) where this is true. For meshes, while they
    use different interpolation methods, 'varying' and 'vertex' are both
    specified per point. It's common to assume that curves follow a similar
    pattern and build in structures and language for per primitive, per
    element, and per point data only to come upon these arrays that don't 
    quite fit into either of those categories. It is
    also common to conflate 'varying' with being per segment data and use the
    segmentCount rules table instead of its neighboring varying data table
    rules. We suspect that this is because for the common case of
    nonperiodic cubic curves, both the provided segment count and varying data
    size formula end with '+ 1'. While debugging, users may look at the double
    '+ 1' as a mistake and try to remove it.  We take this time to enumerate
    these issues because we've fallen into them before and hope that we save
    others time in their own implementations.

    As an example of deriving per curve segment and varying primvar data counts from
    the wrap, type, basis, and curveVertexCount, the following table is provided.

    wrap          | type    | basis   | curveVertexCount  | curveSegmentCount  | varyingDataCount
    ------------- | ------- | ------- | ----------------- | ------------------ | -------------------------
    nonperiodic   | linear  | N/A     | [2 3 2 5]         | [1 2 1 4]          | [2 3 2 5]
    nonperiodic   | cubic   | bezier  | [4 7 10 4 7]      | [1 2 3 1 2]        | [2 3 4 2 3]
    nonperiodic   | cubic   | bspline | [5 4 6 7]         | [2 1 3 4]          | [3 2 4 5]
    periodic      | cubic   | bezier  | [6 9 6]           | [2 3 2]            | [2 3 2]
    periodic      | linear  | N/A     | [3 7]             | [3 7]              | [3 7]

    Tubes and Ribbons
    
    The strictest definition of a curve as an infinitely thin wire is not 
    particularly useful for describing production scenes. The additional
    widths and normals attributes can be used to describe cylindrical
    tubes and or flat oriented ribbons.

    Curves with only widths defined are imaged as tubes with radius
    'width / 2'. Curves with both widths and normals are imaged as ribbons
    oriented in the direction of the interpolated normal vectors.

    While not technically UsdGeomPrimvars, widths and normals
    also have interpolation metadata. It's common for authored widths to have
    constant, varying, or vertex interpolation 
    (see UsdGeomCurves::GetWidthsInterpolation()).  It's common for
    authored normals to have varying interpolation 
    (see UsdGeomPointBased::GetNormalsInterpolation()).

    \\image html USDCurveHydra.png

    The file used to generate these curves can be found in
    pxr/extras/examples/usdGeomExamples/basisCurves.usda.  It's provided
    as a reference on how to properly image both tubes and ribbons. The first
    row of curves are linear; the second are cubic bezier. (We aim in future
    releases of HdSt to fix the discontinuity seen with broken tangents to
    better match offline renderers like RenderMan.) The yellow and violet
    cubic curves represent cubic vertex width interpolation for which there is
    no equivalent for linear curves.
    
    \\note How did this prim type get its name?  This prim is a portmanteau of
    two different statements in the original RenderMan specification:
    'Basis' and 'Curves'.
"""
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    uniform token basis = "bezier" (
        allowedTokens = ["bezier", "bspline", "catmullRom"]
        doc = """The basis specifies the vstep and matrix used for cubic 
        interpolation.  \\note The 'hermite' and 'power' tokens have been
        removed. We've provided UsdGeomHermiteCurves
        as an alternative for the 'hermite' basis."""
    )
    int[] curveVertexCounts (
        doc = """Curves-derived primitives can represent multiple distinct,
        potentially disconnected curves.  The length of 'curveVertexCounts'
        gives the number of such curves, and each element describes the
        number of vertices in the corresponding curve"""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    uniform token type = "cubic" (
        allowedTokens = ["linear", "cubic"]
        doc = """Linear curves interpolate linearly between two vertices.  
        Cubic curves use a basis matrix with four vertices to interpolate a segment."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float[] widths (
        doc = """Provides width specification for the curves, whose application
        will depend on whether the curve is oriented (normals are defined for
        it), in which case widths are \"ribbon width\", or unoriented, in which
        case widths are cylinder width.  'widths' is not a generic Primvar,
        but the number of elements in this attribute will be determined by
        its 'interpolation'.  See .  If 'widths'
        and 'primvars:widths' are both specified, the latter has precedence."""
    )
    uniform token wrap = "nonperiodic" (
        allowedTokens = ["nonperiodic", "periodic", "pinned"]
        doc = """If wrap is set to periodic, the curve when rendered will 
        repeat the initial vertices (dependent on the vstep) to close the
        curve. If wrap is set to 'pinned', phantom points may be created
        to ensure that the curve interpolation starts at P[0] and ends at P[n-1].
        """
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class NurbsCurves "NurbsCurves" (
    doc = """This schema is analagous to NURBS Curves in packages like Maya
    and Houdini, often used for interchange of rigging and modeling curves.  
    Unlike Maya, this curve spec supports batching of multiple curves into a 
    single prim, widths, and normals in the schema.  Additionally, we require 
    'numSegments + 2 * degree + 1' knots (2 more than maya does).  This is to
    be more consistent with RenderMan's NURBS patch specification.  
    
    To express a periodic curve:
    - knot[0] = knot[1] - (knots[-2] - knots[-3]; 
    - knot[-1] = knot[-2] + (knot[2] - knots[1]);
    
    To express a nonperiodic curve:
    - knot[0] = knot[1];
    - knot[-1] = knot[-2];
    
    In spite of these slight differences in the spec, curves generated in Maya
    should be preserved when roundtripping.
    
    order and range, when representing a batched NurbsCurve should be
    authored one value per curve.  knots should be the concatentation of
    all batched curves."""
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    int[] curveVertexCounts (
        doc = """Curves-derived primitives can represent multiple distinct,
        potentially disconnected curves.  The length of 'curveVertexCounts'
        gives the number of such curves, and each element describes the
        number of vertices in the corresponding curve"""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    double[] knots (
        doc = """Knot vector providing curve parameterization.
        The length of the slice of the array for the ith curve 
        must be ( curveVertexCount[i] + order[i] ), and its
        entries must take on monotonically increasing values."""
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    int[] order = [] (
        doc = """Order of the curve.  Order must be positive and is
        equal to the degree of the polynomial basis to be evaluated, plus 1.
        Its value for the 'i'th curve must be less than or equal to
        curveVertexCount[i]"""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    double2[] ranges (
        doc = """Provides the minimum and maximum parametric values (as defined
        by knots) over which the curve is actually defined.  The minimum must 
        be less than the maximum, and greater than or equal to the value of the 
        knots['i'th curve slice][order[i]-1]. The maxium must be less 
        than or equal to the last element's value in knots['i'th curve slice].
\tRange maps to (vmin, vmax) in the RenderMan spec."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float[] widths (
        doc = """Provides width specification for the curves, whose application
        will depend on whether the curve is oriented (normals are defined for
        it), in which case widths are \"ribbon width\", or unoriented, in which
        case widths are cylinder width.  'widths' is not a generic Primvar,
        but the number of elements in this attribute will be determined by
        its 'interpolation'.  See .  If 'widths'
        and 'primvars:widths' are both specified, the latter has precedence."""
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Points "Points" (
    doc = """Points are analogous to the <A HREF=\"https://renderman.pixar.com/resources/current/RenderMan/appnote.18.html\">RiPoints spec</A>.  
    
    Points can be an efficient means of storing and rendering particle
    effects comprised of thousands or millions of small particles.  Points
    generally receive a single shading sample each, which should take 
    normals into account, if present.

    While not technically UsdGeomPrimvars, the widths and normals also
    have interpolation metadata.  It's common for authored widths and normals
    to have constant or varying interpolation."""
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    int64[] ids (
        doc = """Ids are optional; if authored, the ids array should be the same
                 length as the points array, specifying (at each timesample if
                 point identities are changing) the id of each point. The
                 type is signed intentionally, so that clients can encode some
                 binary state on Id'd points without adding a separate 
                 primvar."""
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float[] widths (
        doc = """Widths are defined as the diameter of the points, in 
                 object space.  'widths' is not a generic Primvar, but
                 the number of elements in this attribute will be determined by
                 its 'interpolation'.  See .  If
                 'widths' and 'primvars:widths' are both specified, the latter
                 has precedence."""
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class PointInstancer "PointInstancer" (
    doc = """Encodes vectorized instancing of multiple, potentially
    animated, prototypes (object/instance masters), which can be arbitrary
    prims/subtrees on a UsdStage.
    
    PointInstancer is a \"multi instancer\", as it allows multiple prototypes
    to be scattered among its \"points\".  We use a UsdRelationship
    prototypes to identify and order all of the possible prototypes, by
    targeting the root prim of each prototype.  The ordering imparted by
    relationships associates a zero-based integer with each prototype, and
    it is these integers we use to identify the prototype of each instance,
    compactly, and allowing prototypes to be swapped out without needing to
    reauthor all of the per-instance data.
    
    The PointInstancer schema is designed to scale to billions of instances,
    which motivates the choice to split the per-instance transformation into
    position, (quaternion) orientation, and scales, rather than a
    4x4 matrix per-instance.  In addition to requiring fewer bytes even if
    all elements are authored (32 bytes vs 64 for a single-precision 4x4
    matrix), we can also be selective about which attributes need to animate
    over time, for substantial data reduction in many cases.
    
    Note that PointInstancer is not a Gprim, since it is not a graphical
    primitive by any stretch of the imagination. It is, however,
    Boundable, since we will sometimes want to treat the entire PointInstancer
    similarly to a procedural, from the perspective of inclusion or framing.

    Varying Instance Identity over Time
    
    PointInstancers originating from simulations often have the characteristic
    that points/instances are \"born\", move around for some time period, and then
    die (or leave the area of interest). In such cases, billions of instances
    may be birthed over time, while at any specific time, only a much
    smaller number are actually alive.  To encode this situation efficiently,
    the simulator may re-use indices in the instance arrays, when a particle
    dies, its index will be taken over by a new particle that may be birthed in
    a much different location.  This presents challenges both for 
    identity-tracking, and for motion-blur.
    
    We facilitate identity tracking by providing an optional, animatable
    ids attribute, that specifies the 64 bit integer ID of the particle
    at each index, at each point in time.  If the simulator keeps monotonically
    increasing a particle-count each time a new particle is birthed, it will
    serve perfectly as particle ids.
    
    We facilitate motion blur for varying-topology particle streams by
    optionally allowing per-instance velocities and angularVelocities
    to be authored.  If instance transforms are requested at a time between
    samples and either of the velocity attributes is authored, then we will
    not attempt to interpolate samples of positions or orientations.
    If not authored, and the bracketing samples have the same length, then we
    will interpolate.

    Computing an Instance Transform
    
    Each instance's transformation is a combination of the SRT affine transform
    described by its scale, orientation, and position, applied after
    (i.e. less locally) than the transformation computed at the root of the
    prototype it is instancing.  In other words, to put an instance of a 
    PointInstancer into the space of the PointInstancer's parent prim:
    
    1. Apply (most locally) the authored transformation for 
    <em>prototypes[protoIndices[i]]</em>
    2. If *scales* is authored, next apply the scaling matrix from *scales[i]*
    3. If *orientations* is authored: **if *angularVelocities* is authored**, 
    first multiply *orientations[i]* by the unit quaternion derived by scaling 
    *angularVelocities[i]* by the \"time differential\" 
    from the left-bracketing timeSample for *orientation* to the requested 
    evaluation time *t*, storing the result in *R*, **else** assign *R* 
    directly from *orientations[i]*.  Apply the rotation matrix derived 
    from *R*.
    4. Apply the translation derived from *positions[i]*. If *velocities* is 
    authored, apply the translation deriving from *velocities[i]* scaled by 
    the time differential from the left-bracketing timeSample for *positions* 
    to the requested evaluation time *t*.
    5. Least locally, apply the transformation authored on the PointInstancer 
    prim itself (or the UsdGeomImageable::ComputeLocalToWorldTransform() of the 
    PointInstancer to put the instance directly into world space)

    If neither *velocities* nor *angularVelocities* are authored, we fallback to
    standard position and orientation computation logic (using linear
    interpolation between timeSamples) as described by
    .

    \\anchor UsdGeom_PITimeScaling
    <b>Scaling Velocities for Interpolation</b>
    
    When computing time-differentials by which to apply velocity or
    angularVelocity to positions or orientations, we must scale by
    ( 1.0 / UsdStage::GetTimeCodesPerSecond() ), because velocities are recorded
    in units/second, while we are interpolating in UsdTimeCode ordinates.
    
    Additionally, if *motion:velocityScale* is authored or inherited (see
    UsdGeomMotionAPI::ComputeVelocityScale()), it is used to scale both the
    velocity and angular velocity by a constant value during computation. The
    *motion:velocityScale* attribute is encoded by UsdGeomMotionAPI.

    We provide both high and low-level API's for dealing with the
    transformation as a matrix, both will compute the instance matrices using
    multiple threads; the low-level API allows the client to cache unvarying
    inputs so that they need not be read duplicately when computing over
    time.

    See also .
    
    Primvars on PointInstancer
    
    \"Primvars\" authored on a PointInstancer prim should
    always be applied to each instance with constant interpolation at
    the root of the instance.  When you are authoring primvars on a 
    PointInstancer, think about it as if you were authoring them on a 
    point-cloud (e.g. a UsdGeomPoints gprim).  The same 
    <A HREF=\"http://renderman.pixar.com/resources/current/rps/appnote.22.html#classSpecifiers\">interpolation rules for points</A> apply here, substituting
    \"instance\" for \"point\".
    
    In other words, the (constant) value extracted for each instance
    from the authored primvar value depends on the authored interpolation
    and elementSize of the primvar, as follows:
    - <b>constant</b> or <b>uniform</b> : the entire authored value of the
    primvar should be applied exactly to each instance.
    - <b>varying</b>, <b>vertex</b>, or <b>faceVarying</b>: the first
    elementSize elements of the authored primvar array should be assigned to
    instance zero, the second elementSize elements should be assigned to
    instance one, and so forth.

    
    Masking Instances: \"Deactivating\" and Invising

    Often a PointInstancer is created \"upstream\" in a graphics pipeline, and
    the needs of \"downstream\" clients necessitate eliminating some of the 
    instances from further consideration.  Accomplishing this pruning by 
    re-authoring all of the per-instance attributes is not very attractive,
    since it may mean destructively editing a large quantity of data.  We
    therefore provide means of \"masking\" instances by ID, such that the 
    instance data is unmolested, but per-instance transform and primvar data
    can be retrieved with the no-longer-desired instances eliminated from the
    (smaller) arrays.  PointInstancer allows two independent means of masking
    instances by ID, each with different features that meet the needs of
    various clients in a pipeline.  Both pruning features' lists of ID's are
    combined to produce the mask returned by ComputeMaskAtTime().
    
    \\note If a PointInstancer has no authored ids attribute, the masking
    features will still be available, with the integers specifying element
    position in the protoIndices array rather than ID.

    \\subsection UsdGeomPointInstancer_inactiveIds InactiveIds: List-edited, Unvarying Masking

    The first masking feature encodes a list of IDs in a list-editable metadatum
    called inactiveIds, which, although it does not have any similar 
    impact to stage population as \"prim activation\",
    it shares with that feature that its application is uniform over all time.
    Because it is list-editable, we can sparsely add and remove instances
    from it in many layers.
    
    This sparse application pattern makes inactiveIds a good choice when
    further downstream clients may need to reverse masking decisions made
    upstream, in a manner that is robust to many kinds of future changes to
    the upstream data.
    
    See ActivateId(), ActivateIds(), DeactivateId(), DeactivateIds(), 
    ActivateAllIds()

    \\subsection UsdGeomPointInstancer_invisibleIds invisibleIds: Animatable Masking

    The second masking feature encodes a list of IDs in a time-varying
    Int64Array-valued UsdAttribute called invisibleIds , since it shares
    with \"Imageable visibility\"
    the ability to animate object visibility.
    
    Unlike inactiveIds, overriding a set of opinions for invisibleIds
    is not at all straightforward, because one will, in general need to
    reauthor (in the overriding layer) **all** timeSamples for the attribute
    just to change one Id's visibility state, so it cannot be authored
    sparsely.  But it can be a very useful tool for situations like encoding
    pre-computed camera-frustum culling of geometry when either or both of
    the instances or the camera is animated.
    
    See VisId(), VisIds(), InvisId(), InvisIds(), VisAllIds()
     
    Processing and Not Processing Prototypes
    
    Any prim in the scenegraph can be targeted as a prototype by the
    prototypes relationship.  We do not, however, provide a specific
    mechanism for identifying prototypes as geometry that should not be drawn
    (or processed) in their own, local spaces in the scenegraph.  We
    encourage organizing all prototypes as children of the PointInstancer
    prim that consumes them, and pruning \"raw\" processing and drawing
    traversals when they encounter a PointInstancer prim; this is what the
    UsdGeomBBoxCache and UsdImaging engines do.
    
    There is a pattern one can deploy for organizing the prototypes
    such that they will automatically be skipped by basic UsdPrim::GetChildren()
    or UsdPrimRange traversals.  Usd prims each have a 
    \"specifier\" of \"def\", \"over\", or \"class\".  The
    default traversals skip over prims that are \"pure overs\" or classes.  So
    to protect prototypes from all generic traversals and processing, place
    them under a prim that is just an \"over\".  For example,
    \\code
    01 def PointInstancer \"Crowd_Mid\"
    02 {
    03     rel prototypes = [ </Crowd_Mid/Prototypes/MaleThin_Business>, </Crowd_Mid/Prototypes/MaleTine_Casual> ]
    04     
    05     over \"Prototypes\" 
    06     {
    07          def \"MaleThin_Business\" (
    08              references = [@MaleGroupA/usd/MaleGroupA.usd@</MaleGroupA>]
    09              variants = {
    10                  string modelingVariant = \"Thin\"
    11                  string costumeVariant = \"BusinessAttire\"
    12              }
    13          )
    14          { ... }
    15          
    16          def \"MaleThin_Casual\"
    17          ...
    18     }
    19 }
    \\endcode
    """
)
{
    vector3f[] accelerations (
        doc = """If authored, per-instance 'accelerations' will be used with
        velocities to compute positions between samples for the 'positions'
        attribute rather than interpolating between neighboring 'positions'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    vector3f[] angularVelocities (
        doc = """If authored, per-instance angular velocity vector to be used for
      interoplating orientations.  Angular velocities should be considered
      mandatory if both protoIndices and orientations are animated.
      Angular velocity is measured in <b>degrees</b> per second. To convert
      to degrees per UsdTimeCode, divide by
      UsdStage::GetTimeCodesPerSecond().
      
      See also ."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    int64[] ids (
        doc = """Ids are optional; if authored, the ids array should be the same
      length as the protoIndices array, specifying (at each timeSample if
      instance identities are changing) the id of each instance. The
      type is signed intentionally, so that clients can encode some
      binary state on Id'd instances without adding a separate primvar.
      See also \\ref UsdGeomPointInstancer_varyingTopo"""
    )
    int64[] invisibleIds = [] (
        doc = """A list of id's to make invisible at the evaluation time.
      See ."""
    )
    quath[] orientations (
        doc = """If authored, per-instance orientation of each instance about its 
      prototype's origin, represented as a unit length quaternion, which
      allows us to encode it with sufficient precision in a compact GfQuath.
      
      It is client's responsibility to ensure that authored quaternions are
      unit length; the convenience API below for authoring orientations from
      rotation matrices will ensure that quaternions are unit length, though
      it will not make any attempt to select the \"better (for interpolation
      with respect to neighboring samples)\" of the two possible quaternions
      that encode the rotation. 
      
      See also ."""
    )
    point3f[] positions (
        doc = """<b>Required property</b>. Per-instance position.  See also 
      ."""
    )
    int[] protoIndices (
        doc = """<b>Required property</b>. Per-instance index into 
      prototypes relationship that identifies what geometry should be 
      drawn for each instance.  <b>Topology attribute</b> - can be animated, 
      but at a potential performance impact for streaming."""
    )
    rel prototypes (
        doc = """<b>Required property</b>. Orders and targets the prototype root 
      prims, which can be located anywhere in the scenegraph that is convenient,
      although we promote organizing prototypes as children of the 
      PointInstancer.  The position of a prototype in this relationship defines
      the value an instance would specify in the protoIndices attribute to 
      instance that prototype. Since relationships are uniform, this property
      cannot be animated."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    float3[] scales (
        doc = """If authored, per-instance scale to be applied to 
      each instance, before any rotation is applied.
      
      See also ."""
    )
    vector3f[] velocities (
        doc = """If provided, per-instance 'velocities' will be used to 
       compute positions between samples for the 'positions' attribute,
       rather than interpolating between neighboring 'positions' samples.
       Velocities should be considered mandatory if both protoIndices
       and positions are animated.  Velocity is measured in position
       units per second, as per most simulation software. To convert to
       position units per UsdTimeCode, divide by
       UsdStage::GetTimeCodesPerSecond().

       See also 
       ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Camera "Camera" (
    doc = """Transformable camera.
    
    Describes optical properties of a camera via a common set of attributes
    that provide control over the camera's frustum as well as its depth of
    field. For stereo, the left and right camera are individual prims tagged
    through the \"stereoRole attribute\".
    
    There is a corresponding class GfCamera, which can hold the state of a
    camera (at a particular time). and
    convert between a USD camera prim and
    a GfCamera.

    To obtain the camera's location in world space, call the following on a
    UsdGeomCamera 'camera':
    \\code
    GfMatrix4d camXform = camera.ComputeLocalToWorldTransform(time);
    \\endcode
    \\note
    <b>Cameras in USD are always \"Y up\", regardless of the stage's orientation
    (i.e. UsdGeomGetStageUpAxis()).</b>  This means that the inverse of 
    'camXform' (the VIEW half of the <A HREF=\"http://www.glprogramming.com/red/chapter03.html#name2\">MODELVIEW transform in OpenGL parlance</A>) 
    will transform the world such that the camera is at the origin, looking 
    down the -Z axis, with +Y as the up axis, and +X pointing to the right.
    This describes a __right handed coordinate system__. 

    Units of Measure for Camera Properties

    Despite the familiarity of millimeters for specifying some physical
    camera properties, UsdGeomCamera opts for greater consistency with all
    other UsdGeom schemas, which measure geometric properties in scene units,
    as determined by UsdGeomGetStageMetersPerUnit().  We do make a
    concession, however, in that lens and filmback properties are measured in
    __tenths of a scene unit__ rather than \"raw\" scene units.  This means
    that with the fallback value of .01 for _metersPerUnit_ - i.e. scene unit
    of centimeters - then these \"tenth of scene unit\" properties are
    effectively millimeters.

    \\note If one adds a Camera prim to a UsdStage whose scene unit is not
    centimeters, the fallback values for filmback properties will be
    incorrect (or at the least, unexpected) in an absolute sense; however,
    proper imaging through a \"default camera\" with focusing disabled depends
    only on ratios of the other properties, so the camera is still usable.
    However, it follows that if even one property is authored in the correct
    scene units, then they all must be.

    
    \\sa \\ref UsdGeom_LinAlgBasics
     """
)
{
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.
                 A vector (a,b,c,d) encodes a clipping plane that cuts off
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)
                 are the coordinates in the camera's space."""
    )
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in scene units; see 
                 ."""
    )
    float exposure = 0 (
        doc = """Exposure adjustment, as a log base-2 value.  The default
                 of 0.0 has no effect.  A value of 1.0 will double the
                 image-plane intensities in a rendered image; a value of
                 -1.0 will halve them."""
    )
    float focalLength = 50 (
        doc = """Perspective focal length in tenths of a scene unit; see 
                 ."""
    )
    float focusDistance = 0 (
        doc = """Distance from the camera to the focus plane in scene units; see 
                 ."""
    )
    float fStop = 0 (
        doc = "Lens aperture. Defaults to 0.0, which turns off focusing."
    )
    float horizontalAperture = 20.955 (
        doc = """Horizontal aperture in tenths of a scene unit; see 
                 . Default is the equivalent of 
                 the standard 35mm spherical projector aperture."""
    )
    float horizontalApertureOffset = 0 (
        doc = """Horizontal aperture offset in the same units as
                 horizontalAperture. Defaults to 0."""
    )
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"]
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    double shutter:close = 0 (
        doc = """Frame relative shutter close time, analogous comments from
                 shutter:open apply. A value greater or equal to shutter:open
                 should be authored, otherwise there is no exposure and a
                 renderer should produce a black image."""
    )
    double shutter:open = 0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative
                 value indicates that the shutter opens before the current
                 frame time). Used for motion blur."""
    )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left
                 or right camera of a stereo setup."""
    )
    float verticalAperture = 15.2908 (
        doc = """Vertical aperture in tenths of a scene unit; see 
                 . Default is the equivalent of 
                 the standard 35mm spherical projector aperture."""
    )
    float verticalApertureOffset = 0 (
        doc = """Vertical aperture offset in the same units as
                 verticalAperture. Defaults to 0."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "GeomModelAPI" (
    doc = """UsdGeomModelAPI extends the generic UsdModelAPI schema with
    geometry specific concepts such as cached extents for the entire model,
    constraint targets, and geometry-inspired extensions to the payload
    lofting process.
   
    As described in GetExtentsHint() below, it is useful to cache extents
    at the model level.  UsdGeomModelAPI provides schema for computing and
    storing these cached extents, which can be consumed by UsdGeomBBoxCache to
    provide fast access to precomputed extents that will be used as the model's
    bounds ( see UsdGeomBBoxCache::UsdGeomBBoxCache() ).

    Draw Modes

    Draw modes provide optional alternate imaging behavior for USD subtrees with
    kind model. model:drawMode (which is inheritable) and
    model:applyDrawMode (which is not) are resolved into a decision to stop
    traversing the scene graph at a certain point, and replace a USD subtree
    with proxy geometry.

    The value of model:drawMode determines the type of proxy geometry:
    - origin - Draw the model-space basis vectors of the replaced prim.
    - bounds - Draw the model-space bounding box of the replaced prim.
    - cards - Draw textured quads as a placeholder for the replaced prim.
    - default - An explicit opinion to draw the USD subtree as normal.
    - inherited - Defer to the parent opinion.

    model:drawMode falls back to _inherited_ so that a whole scene,
    a large group, or all prototypes of a model hierarchy PointInstancer can
    be assigned a draw mode with a single attribute edit.  If no draw mode is
    explicitly set in a hierarchy, the resolved value is _default_.

    model:applyDrawMode is meant to be written when an asset is authored,
    and provides flexibility for different asset types. For example,
    a character assembly (composed of character, clothes, etc) might have
    model:applyDrawMode set at the top of the subtree so the whole group
    can be drawn as a single card object. An effects subtree might have
    model:applyDrawMode set at a lower level so each particle
    group draws individually.

    Models of kind component are treated as if model:applyDrawMode
    were true.  This means a prim is drawn with proxy geometry when: the
    prim has kind component, and/or model:applyDrawMode is set; and
    the prim's resolved value for model:drawMode is not _default_.

    Cards Geometry

    The specific geometry used in cards mode is controlled by the
    model:cardGeometry attribute:
    - cross - Generate a quad normal to each basis direction and negative.
                   Locate each quad so that it bisects the model extents.
    - box   - Generate a quad normal to each basis direction and negative.
                   Locate each quad on a face of the model extents, facing out.
    - fromTexture - Generate a quad for each supplied texture from
                         attributes stored in that texture's metadata.

    For cross and box mode, the extents are calculated for purposes
    default, proxy, and render, at their earliest authored time.
    If the model has no textures, all six card faces are rendered using
    model:drawModeColor. If one or more textures are present, only axes
    with one or more textures assigned are drawn.  For each axis, if both
    textures (positive and negative) are specified, they'll be used on the
    corresponding card faces; if only one texture is specified, it will be
    mapped to the opposite card face after being flipped on the texture's
    s-axis. Any card faces with invalid asset paths will be drawn with
    model:drawModeColor.

    Both model:cardGeometry and model:drawModeColor should be
    authored on the prim where the draw mode takes effect, since these
    attributes are not inherited.

    For fromTexture mode, only card faces with valid textures assigned
    are drawn. The geometry is generated by pulling the worldtoscreen
    attribute out of texture metadata.  This is expected to be a 4x4 matrix
    mapping the model-space position of the card quad to the clip-space quad
    with corners (-1,-1,0) and (1,1,0).  The card vertices are generated by
    transforming the clip-space corners by the inverse of worldtoscreen.
    Textures are mapped so that (s) and (t) map to (+x) and (+y) in clip space.
    If the metadata cannot be read in the right format, or the matrix can't
    be inverted, the card face is not drawn.

    All card faces are drawn and textured as single-sided.

    \\todo CreatePayload() """
)
{
    uniform bool model:applyDrawMode = 0 (
        doc = """If true, and the resolved value of model:drawMode is
                 non-default, apply an alternate imaging mode to this prim. See
                 \\ref UsdGeomModelAPI_drawMode."""
    )
    uniform token model:cardGeometry = "cross" (
        allowedTokens = ["cross", "box", "fromTexture"]
        doc = """The geometry to generate for imaging prims inserted for \\em
                 cards imaging mode. See for
                 geometry descriptions."""
    )
    asset model:cardTextureXNeg (
        doc = """In cards imaging mode, the texture applied to the X- quad.
                 The texture axes (s,t) are mapped to model-space axes (y, -z)."""
    )
    asset model:cardTextureXPos (
        doc = """In cards imaging mode, the texture applied to the X+ quad.
                 The texture axes (s,t) are mapped to model-space axes (-y, -z)."""
    )
    asset model:cardTextureYNeg (
        doc = """In cards imaging mode, the texture applied to the Y- quad.
                 The texture axes (s,t) are mapped to model-space axes (-x, -z)."""
    )
    asset model:cardTextureYPos (
        doc = """In cards imaging mode, the texture applied to the Y+ quad.
                 The texture axes (s,t) are mapped to model-space axes (x, -z)."""
    )
    asset model:cardTextureZNeg (
        doc = """In cards imaging mode, the texture applied to the Z- quad.
                 The texture axes (s,t) are mapped to model-space axes (-x, -y)."""
    )
    asset model:cardTextureZPos (
        doc = """In cards imaging mode, the texture applied to the Z+ quad.
                 The texture axes (s,t) are mapped to model-space axes (x, -y)."""
    )
    uniform token model:drawMode = "inherited" (
        allowedTokens = ["origin", "bounds", "cards", "default", "inherited"]
        doc = """Alternate imaging mode; applied to this prim or child prims
                 where model:applyDrawMode is true, or where the prim
                 has kind component. See \\ref UsdGeomModelAPI_drawMode
                 for mode descriptions."""
    )
    uniform float3 model:drawModeColor = (0.18, 0.18, 0.18) (
        doc = """The base color of imaging prims inserted for alternate
                 imaging modes. For origin and bounds modes, this
                 controls line color; for cards mode, this controls the
                 fallback quad color."""
    )
}

class "MotionAPI" (
    doc = """UsdGeomMotionAPI encodes data that can live on any prim that
    may affect computations involving:
    - computed motion for motion blur
    - sampling for motion blur
    
    For example, UsdGeomMotionAPI provides *velocityScale* 
    (GetVelocityScaleAttr()) for controlling how motion-blur samples should
    be computed by velocity-consuming schemas."""
)
{
    float motion:velocityScale = 1 (
        doc = """VelocityScale is an **inherited** float attribute that
        velocity-based schemas (e.g. PointBased, PointInstancer) can consume
        to compute interpolated positions and orientations by applying
        velocity and angularVelocity, which is required for interpolating 
        between samples when topology is varying over time.  Although these 
        quantities are generally physically computed by a simulator, sometimes 
        we require more or less motion-blur to achieve the desired look.  
        VelocityScale allows artists to dial-in, as a post-sim correction, 
        a scale factor to be applied to the velocity prior to computing 
        interpolated positions from it.
        
        See also ComputeVelocityScale()"""
    )
}

class "XformCommonAPI" (
    doc = """This class provides API for authoring and retrieving a standard set
    of component transformations which include a scale, a rotation, a 
    scale-rotate pivot and a translation. The goal of the API is to enhance 
    component-wise interchange. It achieves this by limiting the set of allowed 
    basic ops and by specifying the order in which they are applied. In addition
    to the basic set of ops, the 'resetXformStack' bit can also be set to 
    indicate whether the underlying xformable resets the parent transformation 
    (i.e. does not inherit it's parent's transformation). 

    \\sa UsdGeomXformCommonAPI::GetResetXformStack()
    \\sa UsdGeomXformCommonAPI::SetResetXformStack()

    The operator-bool for the class will inform you whether an existing 
    xformable is compatible with this API.

    The scale-rotate pivot is represented by a pair of (translate, 
    inverse-translate) xformOps around the scale and rotate operations.
    The rotation operation can be any of the six allowed Euler angle sets.
    \\sa UsdGeomXformOp::Type. 

    The xformOpOrder of an xformable that has all of the supported basic ops 
    is as follows:
    [\"xformOp:translate\", \"xformOp:translate:pivot\", \"xformOp:rotateXYZ\",
    \"xformOp:scale\", \"!invert!xformOp:translate:pivot\"].

    It is worth noting that all of the ops are optional. For example, an 
    xformable may have only a translate or a rotate. It would still be 
    considered as compatible with this API. Individual SetTranslate(), 
    SetRotate(), SetScale() and SetPivot() methods are provided by this API 
    to allow such sparse authoring."""
)
{
}

class HermiteCurves "HermiteCurves" (
    doc = """This schema specifies a cubic hermite interpolated curve batch as
    sometimes used for defining guides for animation. While hermite curves can
    be useful because they interpolate through their control points, they are
    not well supported by high-end renderers for imaging. Therefore, while we
    include this schema for interchange, we strongly recommend the use of
    UsdGeomBasisCurves as the representation of curves intended to be rendered
    (ie. hair or grass). Hermite curves can be converted to a Bezier
    representation (though not from Bezier back to Hermite in general).

    Point Interpolation
    
    The initial cubic curve segment is defined by the first two points and
    first two tangents. Additional segments are defined by additional 
    point / tangent pairs.  The number of segments for each non-batched hermite
    curve would be len(curve.points) - 1.  The total number of segments
    for the batched UsdGeomHermiteCurves representation is
    len(points) - len(curveVertexCounts).

    Primvar, Width, and Normal Interpolation

    Primvar interpolation is not well specified for this type as it is not
    intended as a rendering representation. We suggest that per point
    primvars would be linearly interpolated across each segment and should 
    be tagged as 'varying'.

    It is not immediately clear how to specify cubic or 'vertex' interpolation
    for this type, as we lack a specification for primvar tangents. This
    also means that width and normal interpolation should be restricted to
    varying (linear), uniform (per curve element), or constant (per prim).
    """
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    int[] curveVertexCounts (
        doc = """Curves-derived primitives can represent multiple distinct,
        potentially disconnected curves.  The length of 'curveVertexCounts'
        gives the number of such curves, and each element describes the
        number of vertices in the corresponding curve"""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    vector3f[] tangents = [] (
        doc = """Defines the outgoing trajectory tangent for each point. 
                 Tangents should be the same size as the points attribute."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float[] widths (
        doc = """Provides width specification for the curves, whose application
        will depend on whether the curve is oriented (normals are defined for
        it), in which case widths are \"ribbon width\", or unoriented, in which
        case widths are cylinder width.  'widths' is not a generic Primvar,
        but the number of elements in this attribute will be determined by
        its 'interpolation'.  See .  If 'widths'
        and 'primvars:widths' are both specified, the latter has precedence."""
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

#usda 1.0
(
    "This file describes the USD Geometric schemata for code generation."
    subLayers = [
        @usd/schema.usda@
    ]
)

over "GLOBAL" (
    customData = {
        string libraryName           = "usdGeom"
        string libraryPath           = "pxr/usd/usdGeom"
        # string libraryPrefix       = "UsdGeom"
        # string tokensPrefix        = "UsdGeom"
        dictionary libraryTokens = {
            dictionary interpolation = {
                string doc = """UsdGeomPrimvar - How a Primvar interpolates
                across a primitive; equivalent to RenderMan's \\ref Usd_InterpolationVals "class specifier" """
            }
            dictionary elementSize = {
                string doc = """UsdGeomPrimvar - The number of values in the
                value array that must be aggregated for each element on the 
                primitive."""
            }
            dictionary unauthoredValuesIndex = {
                string doc = """UsdGeomPrimvar - The index that represents 
                unauthored values in the indices array of an indexed primvar."""
            }
            dictionary constant ={
                string doc = """Possible value for UsdGeomPrimvar::SetInterpolation.
                Default value for UsdGeomPrimvar::GetInterpolation. One value
                remains constant over the entire surface primitive."""
            }
            dictionary uniform = {
                string doc = """Possible value for UsdGeomPrimvar::SetInterpolation.
                One value remains constant for each uv patch segment of the
                surface primitive (which is a \\em face for meshes)."""
            }
            dictionary varying = {
                string doc = """Possible value for UsdGeomPrimvar::SetInterpolation.
                Four values are interpolated over each uv patch segment of the 
                surface. Bilinear interpolation is used for interpolation 
                between the four values."""
            }
            dictionary vertex = {
                string doc = """Possible value for UsdGeomPrimvar::SetInterpolation.
                Values are interpolated between each vertex in the surface
                primitive. The basis function of the surface is used for 
                interpolation between vertices."""
            }
            dictionary faceVarying = {
                string doc = """Possible value for UsdGeomPrimvar::SetInterpolation.
                For polygons and subdivision surfaces, four values are
                interpolated over each face of the mesh. Bilinear interpolation 
                is used for interpolation between the four values."""
            }
            dictionary upAxis = {
                string doc = """Stage-level metadata that encodes a scene's
                orientation as a token whose value can be "Y" or "Z"."""
            }
            dictionary metersPerUnit = {
                string doc = """Stage-level metadata that encodes a scene's
                linear unit of measure as meters per encoded unit."""
            }
            dictionary partition = {
                string doc = """A type of family of GeomSubsets. It implies 
                that every element appears exacly once in only one of the 
                subsets in the family."""
            }
            dictionary nonOverlapping = {
                string doc = """A type of family of GeomSubsets. It implies that 
                the elements in the various subsets belonging to the family are 
                mutually exclusive, i.e., an element that appears in one 
                subset may not belong to any other subset in the family."""
            }
            dictionary unrestricted = {
                string doc = """A type of family of GeomSubsets. It implies that
                there are no restrictions w.r.t. the membership of elements in 
                the subsets. There could be overlapping members in subsets 
                belonging to the family and the union of all subsets in the 
                family may not contain all the elements."""
            }
            dictionary hermite = {
                string doc = """A deprecated basis token for
                UsdGeomBasisCurves. Consumers of USD should transition
                to using the UsdGeomHermiteCurves schema."""
            }
            dictionary power = {
                string doc = """A deprecated basis token for
                UsdGeomBasisCurves."""
            }
        }
    }
)
{
}

class "Imageable" (
    inherits = </Typed>
    doc = """Base class for all prims that may require rendering or 
    visualization of some sort. The primary attributes of Imageable 
    are \\em visibility and \\em purpose, which each provide instructions for
    what geometry should be included for processing by rendering and other
    computations.

    \\deprecated Imageable also provides API for accessing primvars, which
    has been moved to the UsdGeomPrimvarsAPI schema, because primvars can now
    be applied on non-Imageable prim types.  This API is planned
    to be removed, UsdGeomPrimvarsAPI should be used directly instead."""
    customData = {
        string extraIncludes = """
#include "pxr/base/gf/bbox3d.h"
#include "pxr/usd/usdGeom/primvar.h" """
    }
) {
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = """Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc."""
    )
    
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See \\ref UsdGeom_ImageablePurpose for more detail about how 
        \\em purpose is computed and used.""" 
    )
    rel proxyPrim (
        doc = """The \\em proxyPrim relationship allows us to link a
        prim whose \\em purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        \\li In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        \\li DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        \\li With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render"."""
    )
}

class "VisibilityAPI"
(
    inherits = </APISchemaBase>
    customData = {
        token[] apiSchemaCanOnlyApplyTo = [
            "Imageable"
        ]
    }
    doc = """
    UsdGeomVisibilityAPI introduces properties that can be used to author
    visibility opinions.
   
    \\note
    Currently, this schema only introduces the attributes that are used to
    control purpose visibility. Later, this schema will define _all_
    visibility-related properties and UsdGeomImageable will no longer define
    those properties.
   
    The purpose visibility attributes added by this schema,
    _guideVisibility_, _proxyVisibility_, and _renderVisibility_ can each be
    used to control visibility for geometry of the corresponding purpose
    values, with the overall _visibility_ attribute acting as an
    override. I.e., if _visibility_ evaluates to "invisible", purpose
    visibility is invisible; otherwise, purpose visibility is determined by
    the corresponding purpose visibility attribute.

    Note that the behavior of _guideVisibility_ is subtly different from the
    _proxyVisibility_ and _renderVisibility_ attributes, in that "guide"
    purpose visibility always evaluates to either "invisible" or "visible",
    whereas the other attributes may yield computed values of "inherited" if
    there is no authored opinion on the attribute or inherited from an
    ancestor. This is motivated by the fact that, in Pixar"s user workflows,
    we have never found a need to have all guides visible in a scene by
    default, whereas we do find that flexibility useful for "proxy" and
    "render" geometry.

    This schema can only be applied to UsdGeomImageable prims. The
    UseGeomImageable schema provides API for computing the purpose visibility
    values that result from the attributes introduced by this schema.
    """
)
{
    uniform token guideVisibility = "invisible" (
        allowedTokens = ["inherited", "invisible", "visible"]
        doc = """
        This attribute controls visibility for geometry with purpose "guide".

        Unlike overall _visibility_, _guideVisibility_ is uniform, and
        therefore cannot be animated.

        Also unlike overall _visibility_, _guideVisibility_ is tri-state, in
        that a descendant with an opinion of "visible" overrides an ancestor
        opinion of "invisible".

        The _guideVisibility_ attribute works in concert with the overall
        _visibility_ attribute: The visibility of a prim with purpose "guide"
        is determined by the inherited values it receives for the _visibility_
        and _guideVisibility_ attributes. If _visibility_ evaluates to
        "invisible", the prim is invisible. If _visibility_ evaluates to
        "inherited" and _guideVisibility_ evaluates to "visible", then the
        prim is visible. __Otherwise, it is invisible.__
        """
    )

    uniform token proxyVisibility = "inherited" (
        allowedTokens = ["inherited", "invisible", "visible"]
        doc = """
        This attribute controls visibility for geometry with purpose "proxy".

        Unlike overall _visibility_, _proxyVisibility_ is uniform, and
        therefore cannot be animated.

        Also unlike overall _visibility_, _proxyVisibility_ is tri-state, in
        that a descendant with an opinion of "visible" overrides an ancestor
        opinion of "invisible".

        The _proxyVisibility_ attribute works in concert with the overall
        _visibility_ attribute: The visibility of a prim with purpose "proxy"
        is determined by the inherited values it receives for the _visibility_
        and _proxyVisibility_ attributes. If _visibility_ evaluates to
        "invisible", the prim is invisible. If _visibility_ evaluates to
        "inherited" then: If _proxyVisibility_ evaluates to "visible", then
        the prim is visible; if _proxyVisibility_ evaluates to "invisible",
        then the prim is invisible; if _proxyVisibility_ evaluates to
        "inherited", then the prim may either be visible or invisible,
        depending on a fallback value determined by the calling context.
        """
    )

    uniform token renderVisibility = "inherited" (
        allowedTokens = ["inherited", "invisible", "visible"]
        doc = """
        This attribute controls visibility for geometry with purpose
        "render".

        Unlike overall _visibility_, _renderVisibility_ is uniform, and
        therefore cannot be animated.

        Also unlike overall _visibility_, _renderVisibility_ is tri-state, in
        that a descendant with an opinion of "visible" overrides an ancestor
        opinion of "invisible".

        The _renderVisibility_ attribute works in concert with the overall
        _visibility_ attribute: The visibility of a prim with purpose "render"
        is determined by the inherited values it receives for the _visibility_
        and _renderVisibility_ attributes. If _visibility_ evaluates to
        "invisible", the prim is invisible. If _visibility_ evaluates to
        "inherited" then: If _renderVisibility_ evaluates to "visible", then
        the prim is visible; if _renderVisibility_ evaluates to "invisible",
        then the prim is invisible; if _renderVisibility_ evaluates to
        "inherited", then the prim may either be visible or invisible,
        depending on a fallback value determined by the calling context.
        """
    )
}

class "PrimvarsAPI" (
    inherits = </APISchemaBase>
    doc = """UsdGeomPrimvarsAPI encodes geometric "primitive variables",
    as UsdGeomPrimvar, which interpolate across a primitive's topology,
    can override shader inputs, and inherit down namespace.
    
    \\section usdGeom_PrimvarFetchingAPI Which Method to Use to Retrieve Primvars
     
     While creating primvars is unambiguous (CreatePrimvar()), there are quite
     a few methods available for retrieving primvars, making it potentially
     confusing knowing which one to use.  Here are some guidelines:
     
     \\li If you are populating a GUI with the primvars already available for 
     authoring values on a prim, use GetPrimvars().
     \\li If you want all of the "useful" (e.g. to a renderer) primvars
     available at a prim, including those inherited from ancestor prims, use
     FindPrimvarsWithInheritance().  Note that doing so individually for many
     prims will be inefficient.
     \\li To find a particular primvar defined directly on a prim, which may
     or may not provide a value, use GetPrimvar().
     \\li To find a particular primvar defined on a prim or inherited from
     ancestors, which may or may not provide a value, use 
     FindPrimvarWithInheritance().
     \\li To *efficiently* query for primvars using the overloads of
     FindPrimvarWithInheritance() and FindPrimvarsWithInheritance(), one
     must first cache the results of FindIncrementallyInheritablePrimvars() for
     each non-leaf prim on the stage. """ 
    customData = {
        token apiSchemaType = "nonApplied"
        string extraIncludes = """
#include "pxr/usd/usdGeom/primvar.h" """
    }
) {
}

class "Xformable" (
    inherits = </Imageable>
    customData = {
        string extraIncludes = """
#include "pxr/usd/usdGeom/xformOp.h" 
#include <vector> """
    }
    doc = """Base class for all transformable prims, which allows arbitrary
    sequences of component affine transformations to be encoded.

    \\note 
    You may find it useful to review \\ref UsdGeom_LinAlgBasics while reading
    this class description.
    
    <b>Supported Component Transformation Operations</b>
    
    UsdGeomXformable currently supports arbitrary sequences of the following
    operations, each of which can be encoded in an attribute of the proper
    shape in any supported precision:
    \\li translate - 3D
    \\li scale     - 3D
    \\li rotateX   - 1D angle in degrees
    \\li rotateY   - 1D angle in degrees
    \\li rotateZ   - 1D angle in degrees
    \\li rotateABC - 3D where ABC can be any combination of the six principle
                        Euler Angle sets: XYZ, XZY, YXZ, YZX, ZXY, ZYX.  See
                        \\ref usdGeom_rotationPackingOrder "note on rotation packing order"
    \\li orient    - 4D (quaternion)
    \\li transform - 4x4D 
    
    <b>Creating a Component Transformation</b>
    
    To add components to a UsdGeomXformable prim, simply call AddXformOp()
    with the desired op type, as enumerated in \\ref UsdGeomXformOp::Type,
    and the desired precision, which is one of \\ref UsdGeomXformOp::Precision.
    Optionally, you can also provide an "op suffix" for the operator that 
    disambiguates it from other components of the same type on the same prim.  
    Application-specific transform schemas can use the suffixes to fill a role 
    similar to that played by AbcGeom::XformOp's "Hint" enums for their own 
    round-tripping logic.
    
    We also provide specific "Add" API for each type, for clarity and 
    conciseness, e.g. AddTranslateOp(), AddRotateXYZOp() etc.
    
    AddXformOp() will return a UsdGeomXformOp object, which is a schema on a 
    newly created UsdAttribute that provides convenience API for authoring
    and computing the component transformations.  The UsdGeomXformOp can then
    be used to author any number of timesamples and default for the op.
    
    Each successive call to AddXformOp() adds an operator that will be applied
    "more locally" than the preceding operator, just as if we were pushing
    transforms onto a transformation stack - which is precisely what should
    happen when the operators are consumed by a reader.
    
    \\note
    If you can, please try to use the UsdGeomXformCommonAPI, which wraps
    the UsdGeomXformable with an interface in which Op creation is taken
    care of for you, and there is a much higher chance that the data you
    author will be importable without flattening into other DCC's, as it
    conforms to a fixed set of Scale-Rotate-Translate Ops.
    
    \\sa \\ref usdGeom_xformableExamples "Using the Authoring API"
    
    <b>Data Encoding and Op Ordering</b>
    
    Because there is no "fixed schema" of operations, all of the attributes
    that encode transform operations are dynamic, and are scoped in 
    the namespace "xformOp". The second component of an attribute's name provides
    the \\em type of operation, as listed above.  An "xformOp" attribute can 
    have additional namespace components derived from the \\em opSuffix argument 
    to the AddXformOp() suite of methods, which provides a preferred way of 
    naming the ops such that we can have multiple "translate" ops with unique
    attribute names. For example, in the attribute named 
    "xformOp:translate:maya:pivot", "translate" is the type of operation and
    "maya:pivot" is the suffix.
    
    The following ordered list of attribute declarations in usda
    define a basic Scale-Rotate-Translate with XYZ Euler angles, wherein the
    translation is double-precision, and the remainder of the ops are single,
    in which we will:

    <ol>
    <li> Scale by 2.0 in each dimension
    <li> Rotate about the X, Y, and Z axes by 30, 60, and 90 degrees, respectively
    <li> Translate by 100 units in the Y direction
    </ol>

    \\code
    float3 xformOp:rotateXYZ = (30, 60, 90)
    float3 xformOp:scale = (2, 2, 2)
    double3 xformOp:translate = (0, 100, 0)
    uniform token[] xformOpOrder = [ "xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale" ]
    \\endcode

    The attributes appear in the dictionary order in which USD, by default,
    sorts them.  To ensure the ops are recovered and evaluated in the correct
    order, the schema introduces the **xformOpOrder** attribute, which
    contains the names of the op attributes, in the precise sequence in which
    they should be pushed onto a transform stack. **Note** that the order is
    opposite to what you might expect, given the matrix algebra described in
    \\ref UsdGeom_LinAlgBasics.  This also dictates order of op creation,
    since each call to AddXformOp() adds a new op to the end of the
    \\b xformOpOrder array, as a new "most-local" operation.  See 
    \\ref usdGeom_xformableExamples "Example 2 below" for C++ code that could
    have produced this USD.
    
    If it were important for the prim's rotations to be independently 
    overridable, we could equivalently (at some performance cost) encode
    the transformation also like so:
    \\code
    float xformOp:rotateX = 30
    float xformOp:rotateY = 60
    float xformOp:rotateZ = 90
    float3 xformOp:scale = (2, 2, 2)
    double3 xformOp:translate = (0, 100, 0)
    uniform token[] xformOpOrder = [ "xformOp:translate", "xformOp:rotateZ", "xformOp:rotateY", "xformOp:rotateX", "xformOp:scale" ]
    \\endcode
    
    Again, note that although we are encoding an XYZ rotation, the three
    rotations appear in the **xformOpOrder** in the opposite order, with Z,
    followed, by Y, followed by X.

    Were we to add a Maya-style scalePivot to the above example, it might 
    look like the following:
    \\code
    float3 xformOp:rotateXYZ = (30, 60, 90)
    float3 xformOp:scale = (2, 2, 2)
    double3 xformOp:translate = (0, 100, 0)
    double3 xformOp:translate:scalePivot
    uniform token[] xformOpOrder = [ "xformOp:translate", "xformOp:rotateXYZ", "xformOp:translate:scalePivot", "xformOp:scale" ]
    \\endcode

    <b>Paired "Inverted" Ops</b>

    We have been claiming that the ordered list of ops serves as a set
    of instructions to a transform stack, but you may have noticed in the last
    example that there is a missing operation - the pivot for the scale op
    needs to be applied in its inverse-form as a final (most local) op!  In the 
    AbcGeom::Xform schema, we would have encoded an actual "final" translation
    op whose value was authored by the exporter as the negation of the pivot's
    value.  However, doing so would be brittle in USD, given that each op can
    be independently overridden, and the constraint that one attribute must be
    maintained as the negation of the other in order for successful
    re-importation of the schema cannot be expressed in USD.
    
    Our solution leverages the **xformOpOrder** member of the schema, which,
    in addition to ordering the ops, may also contain one of two special
    tokens that address the paired op and "stack resetting" behavior.

    The "paired op" behavior is encoded as an "!invert!" prefix in 
    \\b xformOpOrder, as the result of an AddXformOp(isInverseOp=True) call.  
    The \\b xformOpOrder for the last example would look like:
    \\code
    uniform token[] xformOpOrder = [ "xformOp:translate", "xformOp:rotateXYZ", "xformOp:translate:scalePivot", "xformOp:scale", "!invert!xformOp:translate:scalePivot" ]
    \\endcode
    
    When asked for its value via UsdGeomXformOp::GetOpTransform(), an
    "inverted" Op (i.e. the "inverted" half of a set of paired Ops) will fetch 
    the value of its paired attribute and return its negation.  This works for 
    all op types - an error will be issued if a "transform" type op is singular 
    and cannot be inverted. When getting the authored value of an inverted op 
    via UsdGeomXformOp::Get(), the raw, uninverted value of the associated
    attribute is returned.

    For the sake of robustness, <b>setting a value on an inverted op is disallowed.</b>
    Attempting to set a value on an inverted op will result in a coding error 
    and no value being set. 
    
    <b>Resetting the Transform Stack</b>

    The other special op/token that can appear in \\em xformOpOrder is
    \\em "!resetXformStack!", which, appearing as the first element of 
    \\em xformOpOrder, indicates this prim should not inherit the transformation
    of its namespace parent.  See SetResetXformStack()

    <b>Expected Behavior for "Missing" Ops</b>
    
    If an importer expects Scale-Rotate-Translate operations, but a prim
    has only translate and rotate ops authored, the importer should assume
    an identity scale.  This allows us to optimize the data a bit, if only
    a few components of a very rich schema (like Maya's) are authored in the
    app.
    
    \\anchor usdGeom_xformableExamples
    <b>Using the C++ API</b>
    
    #1. Creating a simple transform matrix encoding
    \\snippet examples.cpp CreateMatrixWithDefault
    
    #2. Creating the simple SRT from the example above
    \\snippet examples.cpp CreateExampleSRT
    
    #3. Creating a parameterized SRT with pivot using UsdGeomXformCommonAPI
    \\snippet examples.cpp CreateSRTWithDefaults
    
    #4. Creating a rotate-only pivot transform with animated
    rotation and translation
    \\snippet examples.cpp CreateAnimatedTransform
    
"""
) {

    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class Scope "Scope" (
    inherits = </Imageable>
    doc = """Scope is the simplest grouping primitive, and does not carry the
    baggage of transformability.  Note that transforms should inherit down
    through a Scope successfully - it is just a guaranteed no-op from a
    transformability perspective."""
) {
}

class Xform "Xform" (
    inherits = </Xformable>
    doc = """Concrete prim schema for a transform, which implements Xformable """
) {
}

class "Boundable" (
    inherits = </Xformable>
    doc = """Boundable introduces the ability for a prim to persistently
    cache a rectilinear, local-space, extent.
    
    \\section UsdGeom_Boundable_Extent Why Extent and not Bounds ?
    Boundable introduces the notion of "extent", which is a cached computation
    of a prim's local-space 3D range for its resolved attributes <b>at the
    layer and time in which extent is authored</b>.  We have found that with
    composed scene description, attempting to cache pre-computed bounds at
    interior prims in a scene graph is very fragile, given the ease with which
    one can author a single attribute in a stronger layer that can invalidate
    many authored caches - or with which a re-published, referenced asset can
    do the same.
    
    Therefore, we limit to precomputing (generally) leaf-prim extent, which
    avoids the need to read in large point arrays to compute bounds, and
    provides UsdGeomBBoxCache the means to efficiently compute and
    (session-only) cache intermediate bounds.  You are free to compute and
    author intermediate bounds into your scenes, of course, which may work
    well if you have sufficient locks on your pipeline to guarantee that once
    authored, the geometry and transforms upon which they are based will
    remain unchanged, or if accuracy of the bounds is not an ironclad
    requisite. 
    
    When intermediate bounds are authored on Boundable parents, the child prims
    will be pruned from BBox computation; the authored extent is expected to
    incorporate all child bounds."""  
)
{
    # XXX: Note this is really a GfRange3f, which is not fully supported
    # in Vt I/O.
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), \\em without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
}

class "Gprim" ( 
    inherits = </Boundable> 
    doc = """Base class for all geometric primitives.  
    
    Gprim encodes basic graphical properties such as \\em doubleSided and
    \\em orientation, and provides primvars for "display color" and "display
    opacity" that travel with geometry to be used as shader overrides.  """

) {
    color3f[] primvars:displayColor (
        customData = {
            string apiName = "displayColor"
        }
        doc = """It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a \\em displayColor parameter."""
    )
    
    float[] primvars:displayOpacity (
        customData = {
            string apiName = "displayOpacity"
        }
        doc = """Companion to \\em displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    
    uniform bool doubleSided = false (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        \\em orientation.  By doing so they can perform "backface culling" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's \\em doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see \\ref UsdGeom_WindingOrder for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
        )
}

class Cube "Cube" (
    inherits = </Gprim>
    doc = """Defines a primitive rectilinear cube centered at the origin.
    
    The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
    they all pack into the same volume/bounds."""
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = true
        }
    }
) {
    double size = 2.0 (
        doc = """Indicates the length of each edge of the cube.  If you
        author \\em size you must also author \\em extent.
        
        \\sa GetExtentAttr()"""
    )

    float3[] extent = [(-1.0, -1.0, -1.0), (1.0, 1.0, 1.0)] (
        doc = """Extent is re-defined on Cube only to provide a fallback value.
        \\sa UsdGeomGprim::GetExtentAttr()."""
    )

}

class Sphere "Sphere" (
    inherits = </Gprim>
    doc = """Defines a primitive sphere centered at the origin.
    
    The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
    they all pack into the same volume/bounds."""
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = true
        }
    }
) {
    double radius = 1.0 (
        doc = """Indicates the sphere's radius.  If you
        author \\em radius you must also author \\em extent.
        
        \\sa GetExtentAttr()"""
    )

    float3[] extent = [(-1.0, -1.0, -1.0), (1.0, 1.0, 1.0)] (
        doc = """Extent is re-defined on Sphere only to provide a fallback
        value. \\sa UsdGeomGprim::GetExtentAttr()."""
    )
}

class Cylinder "Cylinder" (
    inherits = </Gprim>
    doc = """Defines a primitive cylinder with closed ends, centered at the 
    origin, whose spine is along the specified \\em axis.
    
    The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
    they all pack into the same volume/bounds."""
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = true
        }
    }
) {
    double height = 2 (
        doc = """The size of the cylinder's spine along the specified
        \\em axis.  If you author \\em height you must also author \\em extent.
        
        \\sa GetExtentAttr()"""
    )
    double radius = 1.0 (
        doc = """The radius of the cylinder. If you author \\em radius
        you must also author \\em extent.
        
        \\sa GetExtentAttr()"""
    )
    uniform token axis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        doc = """The axis along which the spine of the cylinder is aligned"""
    )

    float3[] extent = [(-1.0, -1.0, -1.0), (1.0, 1.0, 1.0)] (
        doc = """Extent is re-defined on Cylinder only to provide a fallback
        value. \\sa UsdGeomGprim::GetExtentAttr()."""
    )
}

class Capsule "Capsule" (
    inherits = </Gprim>
    doc = """Defines a primitive capsule, i.e. a cylinder capped by two half
    spheres, centered at the origin, whose spine is along the specified
    \\em axis."""
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = true
        }
    }
) {
    double height = 1.0 (
        doc = """The size of the capsule's spine along the specified
        \\em axis excluding the size of the two half spheres, i.e.
        the size of the cylinder portion of the capsule.
        If you author \\em height you must also author \\em extent.
        \\sa GetExtentAttr()"""
    )
    double radius = 0.5 (
        doc = """The radius of the capsule.  If you
        author \\em radius you must also author \\em extent.
        
        \\sa GetExtentAttr()"""
    )
    uniform token axis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        doc = """The axis along which the spine of the capsule is aligned"""
    )

    float3[] extent = [(-0.5, -0.5, -1.0), (0.5, 0.5, 1.0)] (
        doc = """Extent is re-defined on Capsule only to provide a fallback
        value. \\sa UsdGeomGprim::GetExtentAttr()."""
    )
}

class Cone "Cone" (
    inherits = </Gprim>
    doc = """Defines a primitive cone, centered at the origin, whose spine
    is along the specified \\em axis, with the apex of the cone pointing
    in the direction of the positive axis.
    
    The fallback values for Cube, Sphere, Cone, and Cylinder are set so that
    they all pack into the same volume/bounds."""
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = true
        }
    }
) {
    double height = 2.0 (
        doc = """The size of the cone's spine along the specified
        \\em axis.  If you author \\em height you must also author \\em extent.
        
        \\sa GetExtentAttr()"""
    )
    double radius = 1.0 (
        doc = """The radius of the cone.  If you
        author \\em radius you must also author \\em extent.
        
        \\sa GetExtentAttr()"""
    )
    uniform token axis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        doc = """The axis along which the spine of the cone is aligned"""
    )

    float3[] extent = [(-1.0, -1.0, -1.0), (1.0, 1.0, 1.0)] (
        doc = """Extent is re-defined on Cone only to provide a fallback
        value. \\sa UsdGeomGprim::GetExtentAttr()."""
    )
}

class "PointBased" (
    doc = """Base class for all UsdGeomGprims that possess points,
    providing common attributes such as normals and velocities."""
    
    inherits = </Gprim>
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = true
        }
    }
) {
    # positional
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also \\ref UsdGeom_VelocityInterpolation .""" 
    )

    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )

    # shaping
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        \\ref SetNormalsInterpolation() . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
}

class Mesh "Mesh" (
    inherits = </PointBased>
    customData = {
        string extraIncludes = """
#include "pxr/usd/usd/timeCode.h" """
    }
    doc="""Encodes a mesh with optional subdivision properties and features.

    As a point-based primitive, meshes are defined in terms of points that 
    are connected into edges and faces. Many references to meshes use the
    term 'vertex' in place of or interchangeably with 'points', while some
    use 'vertex' to refer to the 'face-vertices' that define a face.  To
    avoid confusion, the term 'vertex' is intentionally avoided in favor of
    'points' or 'face-vertices'.

    The connectivity between points, edges and faces is encoded using a
    common minimal topological description of the faces of the mesh.  Each
    face is defined by a set of face-vertices using indices into the Mesh's
    _points_ array (inherited from UsdGeomPointBased) and laid out in a
    single linear _faceVertexIndices_ array for efficiency.  A companion
    _faceVertexCounts_ array provides, for each face, the number of
    consecutive face-vertices in _faceVertexIndices_ that define the face.
    No additional connectivity information is required or constructed, so
    no adjacency or neighborhood queries are available.

    A key property of this mesh schema is that it encodes both subdivision
    surfaces and simpler polygonal meshes. This is achieved by varying the
    _subdivisionScheme_ attribute, which is set to specify Catmull-Clark
    subdivision by default, so polygonal meshes must always be explicitly
    declared. The available subdivision schemes and additional subdivision
    features encoded in optional attributes conform to the feature set of
    OpenSubdiv
    (https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html).

    \\anchor UsdGeom_Mesh_Primvars
    __A Note About Primvars__

    The following list clarifies the number of elements for and the
    interpolation behavior of the different primvar interpolation types
    for meshes:

    - __constant__: One element for the entire mesh; no interpolation.
    - __uniform__: One element for each face of the mesh; elements are
      typically not interpolated but are inherited by other faces derived
      from a given face (via subdivision, tessellation, etc.).
    - __varying__: One element for each point of the mesh;
      interpolation of point data is always linear.
    - __vertex__: One element for each point of the mesh;
      interpolation of point data is applied according to the
      _subdivisionScheme_ attribute.
    - __faceVarying__: One element for each of the face-vertices that
      define the mesh topology; interpolation of face-vertex data may
      be smooth or linear, according to the _subdivisionScheme_ and
      _faceVaryingLinearInterpolation_ attributes.

    Primvar interpolation types and related utilities are described more
    generally in \\ref Usd_InterpolationVals.

    \\anchor UsdGeom_Mesh_Normals
    __A Note About Normals__

    Normals should not be authored on a subdivision mesh, since subdivision
    algorithms define their own normals. They should only be authored for
    polygonal meshes (_subdivisionScheme_ = "none").

    The _normals_ attribute inherited from UsdGeomPointBased is not a generic
    primvar, but the number of elements in this attribute will be determined by
    its _interpolation_.  See \\ref UsdGeomPointBased::GetNormalsInterpolation() .
    If _normals_ and _primvars:normals_ are both specified, the latter has
    precedence.  If a polygonal mesh specifies __neither__ _normals_ nor
    _primvars:normals_, then it should be treated and rendered as faceted,
    with no attempt to compute smooth normals.

    The normals generated for smooth subdivision schemes, e.g. Catmull-Clark
    and Loop, will likewise be smooth, but others, e.g. Bilinear, may be
    discontinuous between faces and/or within non-planar irregular faces."""
) {
    #
    # Common Properties
    #
    int[] faceVertexIndices (
        doc = """Flat list of the index (into the _points_ attribute) of each
        vertex of each face in the mesh.  If this attribute has more than
        one timeSample, the mesh is considered to be topologically varying."""
    )
    
    int[] faceVertexCounts (
        doc = """Provides the number of vertices in each face of the mesh, 
        which is also the number of consecutive indices in _faceVertexIndices_
        that define the face.  The length of this attribute is the number of
        faces in the mesh.  If this attribute has more than
        one timeSample, the mesh is considered to be topologically varying."""
    )

    #
    # Subdiv Properties
    #
    
    uniform token subdivisionScheme = "catmullClark" (
        allowedTokens = ["catmullClark", "loop", "bilinear", "none"]
        doc = """The subdivision scheme to be applied to the surface.
        Valid values are:

        - __catmullClark__: The default, Catmull-Clark subdivision; preferred
          for quad-dominant meshes (generalizes B-splines); interpolation
          of point data is smooth (non-linear)
        - __loop__: Loop subdivision; preferred for purely triangular meshes;
          interpolation of point data is smooth (non-linear)
        - __bilinear__: Subdivision reduces all faces to quads (topologically
          similar to "catmullClark"); interpolation of point data is bilinear
        - __none__: No subdivision, i.e. a simple polygonal mesh; interpolation
          of point data is linear

        Polygonal meshes are typically lighter weight and faster to render,
        depending on renderer and render mode.  Use of "bilinear" will produce
        a similar shape to a polygonal mesh and may offer additional guarantees
        of watertightness and additional subdivision features (e.g. holes) but
        may also not respect authored normals.""")

    token interpolateBoundary = "edgeAndCorner" (
        allowedTokens = ["none", "edgeOnly", "edgeAndCorner"]
        doc = """Specifies how subdivision is applied for faces adjacent to
        boundary edges and boundary points. Valid values correspond to choices
        available in OpenSubdiv:

        - __none__: No boundary interpolation is applied and boundary faces are
          effectively treated as holes
        - __edgeOnly__: A sequence of boundary edges defines a smooth curve to
          which the edges of subdivided boundary faces converge
        - __edgeAndCorner__: The default, similar to "edgeOnly" but the smooth
          boundary curve is made sharp at corner points

        These are illustrated and described in more detail in the OpenSubdiv
        documentation:
        https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html#boundary-interpolation-rules""")

    token faceVaryingLinearInterpolation = "cornersPlus1" (
        allowedTokens = ["none", "cornersOnly", "cornersPlus1",
                         "cornersPlus2", "boundaries", "all"]
        doc = """Specifies how elements of a primvar of interpolation type
        "faceVarying" are interpolated for subdivision surfaces. Interpolation
        can be as smooth as a "vertex" primvar or constrained to be linear at
        features specified by several options.  Valid values correspond to
        choices available in OpenSubdiv:

        - __none__: No linear constraints or sharpening, smooth everywhere
        - __cornersOnly__: Sharpen corners of discontinuous boundaries only,
          smooth everywhere else
        - __cornersPlus1__: The default, same as "cornersOnly" plus additional
          sharpening at points where three or more distinct face-varying
          values occur
        - __cornersPlus2__: Same as "cornersPlus1" plus additional sharpening
          at points with at least one discontinuous boundary corner or
          only one discontinuous boundary edge (a dart)
        - __boundaries__: Piecewise linear along discontinuous boundaries,
          smooth interior
        - __all__: Piecewise linear everywhere

        These are illustrated and described in more detail in the OpenSubdiv
        documentation:
        https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html#face-varying-interpolation-rules""")

    token triangleSubdivisionRule = "catmullClark" (
        allowedTokens = ["catmullClark", "smooth"]
        doc = """Specifies an option to the subdivision rules for the
        Catmull-Clark scheme to try and improve undesirable artifacts when
        subdividing triangles.  Valid values are "catmullClark" for the
        standard rules (the default) and "smooth" for the improvement.

        See https://graphics.pixar.com/opensubdiv/docs/subdivision_surfaces.html#triangle-subdivision-rule""")
    
    int[] holeIndices = [] (
        doc = """The indices of all faces that should be treated as holes,
        i.e. made invisible. This is traditionally a feature of subdivision
        surfaces and not generally applied to polygonal meshes.""")

    int[] cornerIndices = [] (
        doc = """The indices of points for which a corresponding sharpness
        value is specified in _cornerSharpnesses_ (so the size of this array
        must match that of _cornerSharpnesses_).""")

    float[] cornerSharpnesses = [] (
        doc = """The sharpness values associated with a corresponding set of
        points specified in _cornerIndices_ (so the size of this array must
        match that of _cornerIndices_). Use the constant `SHARPNESS_INFINITE`
        for a perfectly sharp corner.""")

    int[] creaseIndices = [] (
        doc = """The indices of points grouped into sets of successive pairs
        that identify edges to be creased. The size of this array must be
        equal to the sum of all elements of the _creaseLengths_ attribute.""")

    int[] creaseLengths = [] (
        doc = """The length of this array specifies the number of creases
        (sets of adjacent sharpened edges) on the mesh. Each element gives
        the number of points of each crease, whose indices are successively
        laid out in the _creaseIndices_ attribute. Since each crease must
        be at least one edge long, each element of this array must be at
        least two.""")

    float[] creaseSharpnesses = [] (
        doc = """The per-crease or per-edge sharpness values for all creases.
        Since _creaseLengths_ encodes the number of points in each crease,
        the number of elements in this array will be either len(creaseLengths)
        or the sum over all X of (creaseLengths[X] - 1). Note that while
        the RI spec allows each crease to have either a single sharpness
        or a value per-edge, USD will encode either a single sharpness
        per crease on a mesh, or sharpnesses for all edges making up
        the creases on a mesh.  Use the constant `SHARPNESS_INFINITE` for a
        perfectly sharp crease.""")
}

class GeomSubset "GeomSubset" (
    inherits = </Typed>
    doc = """Encodes a subset of a piece of geometry (i.e. a UsdGeomImageable) 
    as a set of indices. Currently only supports encoding of face-subsets, but 
    could be extended in the future to support subsets representing edges, 
    segments, points etc.

    To apply to a geometric prim, a GeomSubset prim must be defined as a 
    child of it in namespace. This restriction makes it easy and efficient 
    to discover subsets of a prim. We might want to relax this restriction if 
    it's common to have multiple <b>families</b> of subsets on a gprim and if 
    it's useful to be able to organize subsets belonging to a </b>family</b> 
    under a common scope. See 'familyName' attribute for more info on defining 
    a family of subsets.

    Note that a GeomSubset isn't an imageable (i.e. doesn't derive from
    UsdGeomImageable). So, you can't author <b>visibility</b> for it or 
    override its <b>purpose</b>.

    Materials are bound to GeomSubsets just as they are for regular 
    geometry using API available in UsdShade (UsdShadeMaterial::Bind).
"""
    customData = {
        string className = "Subset"
        string extraIncludes = """
#include "pxr/base/tf/token.h"
#include "pxr/usd/usdGeom/imageable.h"
"""
    }
)
{
    uniform token elementType = "face" (
        allowedTokens = ["face"]
        doc = """The type of element that the indices target. Currently only 
        allows "face" and defaults to it."""
    )
    int[] indices = [] (
        doc = """The set of indices included in this subset. The indices need not 
        be sorted, but the same index should not appear more than once."""
    )
    uniform token familyName = "" (
        doc = """The name of the family of subsets that this subset belongs to. 
        This is optional and is primarily useful when there are multiple 
        families of subsets under a geometric prim. In some cases, this could 
        also be used for achieving proper roundtripping of subset data between 
        DCC apps.
        When multiple subsets belonging to a prim have the same familyName, they 
        are said to belong to the family. A <i>familyType</i> value can be 
        encoded on the owner of a family of subsets as a token using the static 
        method UsdGeomSubset::SetFamilyType(). "familyType" can have one of the 
        following values:
        <ul><li><b>UsdGeomTokens->partition</b>: implies that every element of 
        the whole geometry appears exactly once in only one of the subsets
        belonging to the family.</li>
        <li><b>UsdGeomTokens->nonOverlapping</b>: an element that appears in one 
        subset may not appear in any other subset belonging to the family.</li>
        <li><b>UsdGeomTokens->unrestricted</b>: implies that there are no
        restrictions w.r.t. the membership of elements in the subsets. They 
        could be overlapping and the union of all subsets in the family may 
        not represent the whole.</li>
        </ul>
        \\note The validity of subset data is not enforced by the authoring 
        APIs, however they can be checked using UsdGeomSubset::ValidateFamily().
        """
    )
}

class NurbsPatch "NurbsPatch" (
    inherits = </PointBased>
    doc = """Encodes a rational or polynomial non-uniform B-spline
    surface, with optional trim curves.
    
    The encoding mostly follows that of RiNuPatch and RiTrimCurve: 
    https://renderman.pixar.com/resources/current/RenderMan/geometricPrimitives.html#rinupatch , with some minor renaming and coalescing for clarity.
    
    The layout of control vertices in the \\em points attribute inherited
    from UsdGeomPointBased is row-major with U considered rows, and V columns.
    
    \\anchor UsdGeom_NurbsPatch_Form
    <b>NurbsPatch Form</b>
    
    The authored points, orders, knots, weights, and ranges are all that is
    required to render the nurbs patch.  However, the only way to model closed
    surfaces with nurbs is to ensure that the first and last control points
    along the given axis are coincident.  Similarly, to ensure the surface is
    not only closed but also C2 continuous, the last \\em order - 1 control
    points must be (correspondingly) coincident with the first \\em order - 1
    control points, and also the spacing of the last corresponding knots
    must be the same as the first corresponding knots.
    
    <b>Form</b> is provided as an aid to interchange between modeling and
    animation applications so that they can robustly identify the intent with
    which the surface was modelled, and take measures (if they are able) to
    preserve the continuity/concidence constraints as the surface may be rigged
    or deformed.  
    \\li An \\em open-form NurbsPatch has no continuity constraints.
    \\li A \\em closed-form NurbsPatch expects the first and last control points
    to overlap
    \\li A \\em periodic-form NurbsPatch expects the first and last
    \\em order - 1 control points to overlap.
    
    <b>Nurbs vs Subdivision Surfaces</b>
    
    Nurbs are an important modeling primitive in CAD/CAM tools and early
    computer graphics DCC's.  Because they have a natural UV parameterization
    they easily support "trim curves", which allow smooth shapes to be
    carved out of the surface.
    
    However, the topology of the patch is always rectangular, and joining two 
    nurbs patches together (especially when they have differing numbers of
    spans) is difficult to do smoothly.  Also, nurbs are not supported by
    the Ptex texturing technology (http://ptex.us).
    
    Neither of these limitations are shared by subdivision surfaces; therefore,
    although they do not subscribe to trim-curve-based shaping, subdivs are
    often considered a more flexible modeling primitive.
    """
) {
    int uVertexCount (
        doc = """Number of vertices in the U direction.  Should be at least as
        large as uOrder."""
    )

    int vVertexCount (
        doc = """Number of vertices in the V direction.  Should be at least as
        large as vOrder."""
    )

    int uOrder (
        doc = """Order in the U direction.  Order must be positive and is
        equal to the degree of the polynomial basis to be evaluated, plus 1."""
    )

    int vOrder (
        doc = """Order in the V direction.  Order must be positive and is
        equal to the degree of the polynomial basis to be evaluated, plus 1."""
    )

    double[] uKnots (
        doc = """Knot vector for U direction providing U parameterization.
        The length of this array must be ( uVertexCount + uOrder ), and its
        entries must take on monotonically increasing values."""  
    )

    double[] vKnots (
        doc = """Knot vector for V direction providing U parameterization.
        The length of this array must be ( vVertexCount + vOrder ), and its
        entries must take on monotonically increasing values."""  
    )

    uniform token uForm = "open" (
        allowedTokens = ["open", "closed", "periodic"]
        doc = """Interpret the control grid and knot vectors as representing
        an open, geometrically closed, or geometrically closed and C2 continuous
        surface along the U dimension.
        \\sa \\ref UsdGeom_NurbsPatch_Form "NurbsPatch Form" """
    )
        
    uniform token vForm = "open" (
        allowedTokens = ["open", "closed", "periodic"]
        doc = """Interpret the control grid and knot vectors as representing
        an open, geometrically closed, or geometrically closed and C2 continuous
        surface along the V dimension.
        \\sa \\ref UsdGeom_NurbsPatch_Form "NurbsPatch Form" """
    )
        
    # Alembic's NuPatch does not encode these... wonder how they 
    # get away with that?  Just assume it's the full range, presumably.
    double2 uRange (
        doc = """Provides the minimum and maximum parametric values (as defined
        by uKnots) over which the surface is actually defined.  The minimum
        must be less than the maximum, and greater than or equal to the
        value of uKnots[uOrder-1].  The maxium must be less than or equal
        to the last element's value in uKnots."""
    )

    double2 vRange (
        doc = """Provides the minimum and maximum parametric values (as defined
        by vKnots) over which the surface is actually defined.  The minimum
        must be less than the maximum, and greater than or equal to the
        value of vKnots[vOrder-1].  The maxium must be less than or equal
        to the last element's value in vKnots."""
    )

    double[] pointWeights (
        doc = """Optionally provides "w" components for each control point,
        thus must be the same length as the points attribute.  If authored,
        the patch will be rational.  If unauthored, the patch will be
        polynomial, i.e. weight for all points is 1.0.
        \\note Some DCC's pre-weight the \\em points, but in this schema, 
        \\em points are not pre-weighted."""
    )

    int[] trimCurve:counts (
        doc = """Each element specifies how many curves are present in each
        "loop" of the trimCurve, and the length of the array determines how
        many loops the trimCurve contains.  The sum of all elements is the
        total nuber of curves in the trim, to which we will refer as 
        \\em nCurves in describing the other trim attributes."""
    )
    
    int[] trimCurve:orders (
        doc = """Flat list of orders for each of the \\em nCurves curves."""
    )
    
    int[] trimCurve:vertexCounts (
        doc = """Flat list of number of vertices for each of the
         \\em nCurves curves."""
    )

    double[] trimCurve:knots (
        doc = """Flat list of parametric values for each of the
        \\em nCurves curves.  There will be as many knots as the sum over
        all elements of \\em vertexCounts plus the sum over all elements of
        \\em orders."""
    )

    double2[] trimCurve:ranges (
        doc = """Flat list of minimum and maximum parametric values 
        (as defined by \\em knots) for each of the \\em nCurves curves."""
    )

    double3[] trimCurve:points (
        doc = """Flat list of homogeneous 2D points (u, v, w) that comprise
        the \\em nCurves curves.  The number of points should be equal to the
        um over all elements of \\em vertexCounts."""
    )

}

class "Curves" (
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = true
        }
    }
    inherits = </PointBased>
    doc = """Base class for UsdGeomBasisCurves, UsdGeomNurbsCurves, and
             UsdGeomHermiteCurves.  The BasisCurves schema is designed to be
             analagous to offline renderers' notion of batched curves (such as
             the classical RIB definition via Basis and Curves statements),
             while the NurbsCurve schema is designed to be analgous to the
             NURBS curves found in packages like Maya and Houdini while
             retaining their consistency with the RenderMan specification for
             NURBS Patches. HermiteCurves are useful for the
             interchange of animation guides and paths.

             It is safe to use the length of the curve vertex count to derive
             the number of curves and the number and layout of curve vertices,
             but this schema should NOT be used to derive the number of curve
             points. While vertex indices are implicit in all shipped
             descendent types of this schema, one should not assume that all
             internal or future shipped schemas will follow this pattern. Be
             sure to key any indexing behavior off the concrete type, not this
             abstract type.
             """
) {
    # topology attributes
    int[] curveVertexCounts (
        doc = """Curves-derived primitives can represent multiple distinct,
        potentially disconnected curves.  The length of 'curveVertexCounts'
        gives the number of such curves, and each element describes the
        number of vertices in the corresponding curve"""
    )
    
    # shaping attributes
    float[] widths (
        doc = """Provides width specification for the curves, whose application
        will depend on whether the curve is oriented (normals are defined for
        it), in which case widths are "ribbon width", or unoriented, in which
        case widths are cylinder width.  'widths' is not a generic Primvar,
        but the number of elements in this attribute will be determined by
        its 'interpolation'.  See \\ref SetWidthsInterpolation() .  If 'widths'
        and 'primvars:widths' are both specified, the latter has precedence."""
    )
}

class BasisCurves "BasisCurves" (
    inherits = </Curves>
    doc = """BasisCurves are a batched curve representation analogous to the
    classic RIB definition via Basis and Curves statements. BasisCurves are
    often used to render dense aggregate geometry like hair or grass.

    A 'matrix' and 'vstep' associated with the \\em basis are used to
    interpolate the vertices of a cubic BasisCurves. (The basis attribute
    is unused for linear BasisCurves.)
    
    A single prim may have many curves whose count is determined implicitly by
    the length of the \\em curveVertexCounts vector.  Each individual curve is
    composed of one or more segments. Each segment is defined by four vertices
    for cubic curves and two vertices for linear curves. See the next section
    for more information on how to map curve vertex counts to segment counts.

    \\section UsdGeomBasisCurves_Segment Segment Indexing
    Interpolating a curve requires knowing how to decompose it into its 
    individual segments.

    The segments of a cubic curve are determined by the vertex count,
    the \\em wrap (periodicity), and the vstep of the basis. For linear
    curves, the basis token is ignored and only the vertex count and
    wrap are needed.
    
    cubic basis   | vstep
    ------------- | ------
    bezier        | 3
    catmullRom    | 1
    bspline       | 1
    
    The first segment of a cubic (nonperiodic) curve is always defined by its
    first four points. The vstep is the increment used to determine what
    vertex indices define the next segment.  For a two segment (nonperiodic)
    bspline basis curve (vstep = 1), the first segment will be defined by
    interpolating vertices [0, 1, 2, 3] and the second segment will be defined
    by [1, 2, 3, 4].  For a two segment bezier basis curve (vstep = 3), the
    first segment will be defined by interpolating vertices [0, 1, 2, 3] and
    the second segment will be defined by [3, 4, 5, 6].  If the vstep is not
    one, then you must take special care to make sure that the number of cvs
    properly divides by your vstep. (The indices described are relative to
    the initial vertex index for a batched curve.)

    For periodic curves, at least one of the curve's initial vertices are
    repeated to close the curve. For cubic curves, the number of vertices
    repeated is '4 - vstep'. For linear curves, only one vertex is repeated
    to close the loop.
    
    Pinned curves are a special case of nonperiodic curves that only affects
    the behavior of cubic Bspline and Catmull-Rom curves. To evaluate or render
    pinned curves, a client must effectively add 'phantom points' at the 
    beginning and end of every curve in a batch.  These phantom points
    are injected to ensure that the interpolated curve begins at P[0] and
    ends at P[n-1].
    
    For a curve with initial point P[0] and last point P[n-1], the phantom
    points are defined as.
    P[-1]  = 2 * P[0] - P[1]
    P[n] = 2 * P[n-1] - P[n-2]

    Pinned cubic curves will (usually) have to be unpacked into the standard
    nonperiodic representation before rendering. This unpacking can add some 
    additional overhead. However, using pinned curves reduces the amount of
    data recorded in a scene and (more importantly) better records the
    authors' intent for interchange.

    \\note The additional phantom points mean that the minimum curve vertex
    count for cubic bspline and catmullRom curves is 2.

    Linear curve segments are defined by two vertices.
    A two segment linear curve's first segment would be defined by
    interpolating vertices [0, 1]. The second segment would be defined by 
    vertices [1, 2]. (Again, for a batched curve, indices are relative to
    the initial vertex index.)

    When validating curve topology, each renderable entry in the
    curveVertexCounts vector must pass this check.

    type    | wrap                        | validitity
    ------- | --------------------------- | ----------------
    linear  | nonperiodic                 | curveVertexCounts[i] > 2
    linear  | periodic                    | curveVertexCounts[i] > 3
    cubic   | nonperiodic                 | (curveVertexCounts[i] - 4) % vstep == 0
    cubic   | periodic                    | (curveVertexCounts[i]) % vstep == 0
    cubic   | pinned (catmullRom/bspline) | (curveVertexCounts[i] - 2) >= 0

    \\section UsdGeomBasisCurves_BasisMatrix Cubic Vertex Interpolation
 
    \\image html USDCurveBasisMatrix.png width=750
        
    \\section UsdGeomBasisCurves_Linear Linear Vertex Interpolation
 
    Linear interpolation is always used on curves of type linear.
    't' with domain [0, 1], the curve is defined by the equation 
    P0 * (1-t) + P1 * t. t at 0 describes the first point and t at 1 describes
    the end point.

    \\section UsdGeomBasisCurves_PrimvarInterpolation Primvar Interpolation
        
    For cubic curves, primvar data can be either interpolated cubically between 
    vertices or linearly across segments.  The corresponding token
    for cubic interpolation is 'vertex' and for linear interpolation is
    'varying'.  Per vertex data should be the same size as the number
    of vertices in your curve.  Segment varying data is dependent on the 
    wrap (periodicity) and number of segments in your curve.  For linear curves,
    varying and vertex data would be interpolated the same way.  By convention 
    varying is the preferred interpolation because of the association of 
    varying with linear interpolation.
    
    \\image html USDCurvePrimvars.png 

    To convert an entry in the curveVertexCounts vector into a segment count 
    for an individual curve, apply these rules.  Sum up all the results in
    order to compute how many total segments all curves have.

    The following tables describe the expected segment count for the 'i'th
    curve in a curve batch as well as the entire batch. Python syntax
    like '[:]' (to describe all members of an array) and 'len(...)' 
    (to describe the length of an array) are used.

    type    | wrap                        | curve segment count                    | batch segment count                                                       
    ------- | --------------------------- | -------------------------------------- | --------------------------
    linear  | nonperiodic                 | curveVertexCounts[i] - 1               | sum(curveVertexCounts[:]) - len(curveVertexCounts)
    linear  | periodic                    | curveVertexCounts[i]                   | sum(curveVertexCounts[:])
    cubic   | nonperiodic                 | (curveVertexCounts[i] - 4) / vstep + 1 | sum(curveVertexCounts[:] - 4) / vstep + len(curveVertexCounts)
    cubic   | periodic                    | curveVertexCounts[i] / vstep           | sum(curveVertexCounts[:]) / vstep
    cubic   | pinned (catmullRom/bspline) | (curveVertexCounts[i] - 2) + 1         | sum(curveVertexCounts[:] - 2) + len(curveVertexCounts)
 
    The following table descrives the expected size of varying
    (linearly interpolated) data, derived from the segment counts computed
    above.

    wrap                | curve varying count          | batch varying count
    ------------------- | ---------------------------- | ------------------------------------------------
    nonperiodic/pinned  | segmentCounts[i] + 1         | sum(segmentCounts[:]) + len(curveVertexCounts)
    periodic            | segmentCounts[i]             | sum(segmentCounts[:])

    Both curve types additionally define 'constant' interpolation for the
    entire prim and 'uniform' interpolation as per curve data.

 
    \\note Take care when providing support for linearly interpolated data for
    cubic curves. Its shape doesn't provide a one to one mapping with either
    the number of curves (like 'uniform') or the number of vertices (like
    'vertex') and so it is often overlooked. This is the only primitive in
    UsdGeom (as of this writing) where this is true. For meshes, while they
    use different interpolation methods, 'varying' and 'vertex' are both
    specified per point. It's common to assume that curves follow a similar
    pattern and build in structures and language for per primitive, per
    element, and per point data only to come upon these arrays that don't 
    quite fit into either of those categories. It is
    also common to conflate 'varying' with being per segment data and use the
    segmentCount rules table instead of its neighboring varying data table
    rules. We suspect that this is because for the common case of
    nonperiodic cubic curves, both the provided segment count and varying data
    size formula end with '+ 1'. While debugging, users may look at the double
    '+ 1' as a mistake and try to remove it.  We take this time to enumerate
    these issues because we've fallen into them before and hope that we save
    others time in their own implementations.

    As an example of deriving per curve segment and varying primvar data counts from
    the wrap, type, basis, and curveVertexCount, the following table is provided.

    wrap          | type    | basis   | curveVertexCount  | curveSegmentCount  | varyingDataCount
    ------------- | ------- | ------- | ----------------- | ------------------ | -------------------------
    nonperiodic   | linear  | N/A     | [2 3 2 5]         | [1 2 1 4]          | [2 3 2 5]
    nonperiodic   | cubic   | bezier  | [4 7 10 4 7]      | [1 2 3 1 2]        | [2 3 4 2 3]
    nonperiodic   | cubic   | bspline | [5 4 6 7]         | [2 1 3 4]          | [3 2 4 5]
    periodic      | cubic   | bezier  | [6 9 6]           | [2 3 2]            | [2 3 2]
    periodic      | linear  | N/A     | [3 7]             | [3 7]              | [3 7]

    \\section UsdGeomBasisCurves_TubesAndRibbons Tubes and Ribbons
    
    The strictest definition of a curve as an infinitely thin wire is not 
    particularly useful for describing production scenes. The additional
    \\em widths and \\em normals attributes can be used to describe cylindrical
    tubes and or flat oriented ribbons.

    Curves with only widths defined are imaged as tubes with radius
    'width / 2'. Curves with both widths and normals are imaged as ribbons
    oriented in the direction of the interpolated normal vectors.

    While not technically UsdGeomPrimvars, widths and normals
    also have interpolation metadata. It's common for authored widths to have
    constant, varying, or vertex interpolation 
    (see UsdGeomCurves::GetWidthsInterpolation()).  It's common for
    authored normals to have varying interpolation 
    (see UsdGeomPointBased::GetNormalsInterpolation()).

    \\image html USDCurveHydra.png

    The file used to generate these curves can be found in
    pxr/extras/examples/usdGeomExamples/basisCurves.usda.  It's provided
    as a reference on how to properly image both tubes and ribbons. The first
    row of curves are linear; the second are cubic bezier. (We aim in future
    releases of HdSt to fix the discontinuity seen with broken tangents to
    better match offline renderers like RenderMan.) The yellow and violet
    cubic curves represent cubic vertex width interpolation for which there is
    no equivalent for linear curves.
    
    \\note How did this prim type get its name?  This prim is a portmanteau of
    two different statements in the original RenderMan specification:
    'Basis' and 'Curves'.
"""
) {
    # interpolation attributes
    uniform token type  = "cubic" (
        allowedTokens = ["linear", "cubic"]
        doc = """Linear curves interpolate linearly between two vertices.  
        Cubic curves use a basis matrix with four vertices to interpolate a segment.""")

    uniform token basis = "bezier" (
        allowedTokens = ["bezier", "bspline", "catmullRom"]
        doc = """The basis specifies the vstep and matrix used for cubic 
        interpolation.  \\note The 'hermite' and 'power' tokens have been
        removed. We've provided UsdGeomHermiteCurves
        as an alternative for the 'hermite' basis.""")

    uniform token wrap = "nonperiodic" (
        allowedTokens = ["nonperiodic", "periodic", "pinned"]
        doc = """If wrap is set to periodic, the curve when rendered will 
        repeat the initial vertices (dependent on the vstep) to close the
        curve. If wrap is set to 'pinned', phantom points may be created
        to ensure that the curve interpolation starts at P[0] and ends at P[n-1].
        """)
}

class NurbsCurves "NurbsCurves" (
    inherits = </Curves>
    doc = """This schema is analagous to NURBS Curves in packages like Maya
    and Houdini, often used for interchange of rigging and modeling curves.  
    Unlike Maya, this curve spec supports batching of multiple curves into a 
    single prim, widths, and normals in the schema.  Additionally, we require 
    'numSegments + 2 * degree + 1' knots (2 more than maya does).  This is to
    be more consistent with RenderMan's NURBS patch specification.  
    
    To express a periodic curve:
    - knot[0] = knot[1] - (knots[-2] - knots[-3]; 
    - knot[-1] = knot[-2] + (knot[2] - knots[1]);
    
    To express a nonperiodic curve:
    - knot[0] = knot[1];
    - knot[-1] = knot[-2];
    
    In spite of these slight differences in the spec, curves generated in Maya
    should be preserved when roundtripping.
    
    \\em order and \\em range, when representing a batched NurbsCurve should be
    authored one value per curve.  \\em knots should be the concatentation of
    all batched curves."""
) {
    # topology attributes
    int[] order = [] (
        doc = """Order of the curve.  Order must be positive and is
        equal to the degree of the polynomial basis to be evaluated, plus 1.
        Its value for the 'i'th curve must be less than or equal to
        curveVertexCount[i]""")

    # interpolation attributes
    double[] knots (
        doc = """Knot vector providing curve parameterization.
        The length of the slice of the array for the ith curve 
        must be ( curveVertexCount[i] + order[i] ), and its
        entries must take on monotonically increasing values.""")
        
    double2[] ranges (
        doc = """Provides the minimum and maximum parametric values (as defined
        by knots) over which the curve is actually defined.  The minimum must 
        be less than the maximum, and greater than or equal to the value of the 
        knots['i'th curve slice][order[i]-1]. The maxium must be less 
        than or equal to the last element's value in knots['i'th curve slice].
	Range maps to (vmin, vmax) in the RenderMan spec.""")
}

class Points "Points" (
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = true
        }
    }
    inherits = </PointBased>
    doc = """Points are analogous to the <A HREF="https://renderman.pixar.com/resources/current/RenderMan/appnote.18.html">RiPoints spec</A>.  
    
    Points can be an efficient means of storing and rendering particle
    effects comprised of thousands or millions of small particles.  Points
    generally receive a single shading sample each, which should take 
    \\em normals into account, if present.

    While not technically UsdGeomPrimvars, the widths and normals also
    have interpolation metadata.  It's common for authored widths and normals
    to have constant or varying interpolation."""

) {
    # shaping attributes
    float[] widths (
        doc = """Widths are defined as the \\em diameter of the points, in 
                 object space.  'widths' is not a generic Primvar, but
                 the number of elements in this attribute will be determined by
                 its 'interpolation'.  See \\ref SetWidthsInterpolation() .  If
                 'widths' and 'primvars:widths' are both specified, the latter
                 has precedence."""
    )
    
    int64[] ids (
        doc = """Ids are optional; if authored, the ids array should be the same
                 length as the points array, specifying (at each timesample if
                 point identities are changing) the id of each point. The
                 type is signed intentionally, so that clients can encode some
                 binary state on Id'd points without adding a separate 
                 primvar."""
    )
}

class PointInstancer "PointInstancer" (
    doc = """Encodes vectorized instancing of multiple, potentially
    animated, prototypes (object/instance masters), which can be arbitrary
    prims/subtrees on a UsdStage.
    
    PointInstancer is a "multi instancer", as it allows multiple prototypes
    to be scattered among its "points".  We use a UsdRelationship
    \\em prototypes to identify and order all of the possible prototypes, by
    targeting the root prim of each prototype.  The ordering imparted by
    relationships associates a zero-based integer with each prototype, and
    it is these integers we use to identify the prototype of each instance,
    compactly, and allowing prototypes to be swapped out without needing to
    reauthor all of the per-instance data.
    
    The PointInstancer schema is designed to scale to billions of instances,
    which motivates the choice to split the per-instance transformation into
    position, (quaternion) orientation, and scales, rather than a
    4x4 matrix per-instance.  In addition to requiring fewer bytes even if
    all elements are authored (32 bytes vs 64 for a single-precision 4x4
    matrix), we can also be selective about which attributes need to animate
    over time, for substantial data reduction in many cases.
    
    Note that PointInstancer is \\em not a Gprim, since it is not a graphical
    primitive by any stretch of the imagination. It \\em is, however,
    Boundable, since we will sometimes want to treat the entire PointInstancer
    similarly to a procedural, from the perspective of inclusion or framing.

    \\section UsdGeomPointInstancer_varyingTopo Varying Instance Identity over Time
    
    PointInstancers originating from simulations often have the characteristic
    that points/instances are "born", move around for some time period, and then
    die (or leave the area of interest). In such cases, billions of instances
    may be birthed over time, while at any \\em specific time, only a much
    smaller number are actually alive.  To encode this situation efficiently,
    the simulator may re-use indices in the instance arrays, when a particle
    dies, its index will be taken over by a new particle that may be birthed in
    a much different location.  This presents challenges both for 
    identity-tracking, and for motion-blur.
    
    We facilitate identity tracking by providing an optional, animatable
    \\em ids attribute, that specifies the 64 bit integer ID of the particle
    at each index, at each point in time.  If the simulator keeps monotonically
    increasing a particle-count each time a new particle is birthed, it will
    serve perfectly as particle \\em ids.
    
    We facilitate motion blur for varying-topology particle streams by
    optionally allowing per-instance \\em velocities and \\em angularVelocities
    to be authored.  If instance transforms are requested at a time between
    samples and either of the velocity attributes is authored, then we will
    not attempt to interpolate samples of \\em positions or \\em orientations.
    If not authored, and the bracketing samples have the same length, then we
    will interpolate.

    \\section UsdGeomPointInstancer_transform Computing an Instance Transform
    
    Each instance's transformation is a combination of the SRT affine transform
    described by its scale, orientation, and position, applied \\em after
    (i.e. less locally) than the transformation computed at the root of the
    prototype it is instancing.  In other words, to put an instance of a 
    PointInstancer into the space of the PointInstancer's parent prim:
    
    1. Apply (most locally) the authored transformation for 
    <em>prototypes[protoIndices[i]]</em>
    2. If *scales* is authored, next apply the scaling matrix from *scales[i]*
    3. If *orientations* is authored: **if *angularVelocities* is authored**, 
    first multiply *orientations[i]* by the unit quaternion derived by scaling 
    *angularVelocities[i]* by the \\ref UsdGeom_PITimeScaling "time differential" 
    from the left-bracketing timeSample for *orientation* to the requested 
    evaluation time *t*, storing the result in *R*, **else** assign *R* 
    directly from *orientations[i]*.  Apply the rotation matrix derived 
    from *R*.
    4. Apply the translation derived from *positions[i]*. If *velocities* is 
    authored, apply the translation deriving from *velocities[i]* scaled by 
    the time differential from the left-bracketing timeSample for *positions* 
    to the requested evaluation time *t*.
    5. Least locally, apply the transformation authored on the PointInstancer 
    prim itself (or the UsdGeomImageable::ComputeLocalToWorldTransform() of the 
    PointInstancer to put the instance directly into world space)

    If neither *velocities* nor *angularVelocities* are authored, we fallback to
    standard position and orientation computation logic (using linear
    interpolation between timeSamples) as described by
    \\ref UsdGeom_VelocityInterpolation .

    \\anchor UsdGeom_PITimeScaling
    <b>Scaling Velocities for Interpolation</b>
    
    When computing time-differentials by which to apply velocity or
    angularVelocity to positions or orientations, we must scale by
    ( 1.0 / UsdStage::GetTimeCodesPerSecond() ), because velocities are recorded
    in units/second, while we are interpolating in UsdTimeCode ordinates.
    
    Additionally, if *motion:velocityScale* is authored or inherited (see
    UsdGeomMotionAPI::ComputeVelocityScale()), it is used to scale both the
    velocity and angular velocity by a constant value during computation. The
    *motion:velocityScale* attribute is encoded by UsdGeomMotionAPI.

    We provide both high and low-level API's for dealing with the
    transformation as a matrix, both will compute the instance matrices using
    multiple threads; the low-level API allows the client to cache unvarying
    inputs so that they need not be read duplicately when computing over
    time.

    See also \\ref UsdGeom_VelocityInterpolation .
    
    \\section UsdGeomPointInstancer_primvars Primvars on PointInstancer
    
    \\ref UsdGeomPrimvar "Primvars" authored on a PointInstancer prim should
    always be applied to each instance with \\em constant interpolation at
    the root of the instance.  When you are authoring primvars on a 
    PointInstancer, think about it as if you were authoring them on a 
    point-cloud (e.g. a UsdGeomPoints gprim).  The same 
    <A HREF="http://renderman.pixar.com/resources/current/rps/appnote.22.html#classSpecifiers">interpolation rules for points</A> apply here, substituting
    "instance" for "point".
    
    In other words, the (constant) value extracted for each instance
    from the authored primvar value depends on the authored \\em interpolation
    and \\em elementSize of the primvar, as follows:
    \\li <b>constant</b> or <b>uniform</b> : the entire authored value of the
    primvar should be applied exactly to each instance.
    \\li <b>varying</b>, <b>vertex</b>, or <b>faceVarying</b>: the first
    \\em elementSize elements of the authored primvar array should be assigned to
    instance zero, the second \\em elementSize elements should be assigned to
    instance one, and so forth.

    
    \\section UsdGeomPointInstancer_masking Masking Instances: "Deactivating" and Invising

    Often a PointInstancer is created "upstream" in a graphics pipeline, and
    the needs of "downstream" clients necessitate eliminating some of the 
    instances from further consideration.  Accomplishing this pruning by 
    re-authoring all of the per-instance attributes is not very attractive,
    since it may mean destructively editing a large quantity of data.  We
    therefore provide means of "masking" instances by ID, such that the 
    instance data is unmolested, but per-instance transform and primvar data
    can be retrieved with the no-longer-desired instances eliminated from the
    (smaller) arrays.  PointInstancer allows two independent means of masking
    instances by ID, each with different features that meet the needs of
    various clients in a pipeline.  Both pruning features' lists of ID's are
    combined to produce the mask returned by ComputeMaskAtTime().
    
    \\note If a PointInstancer has no authored \\em ids attribute, the masking
    features will still be available, with the integers specifying element
    position in the \\em protoIndices array rather than ID.

    \\subsection UsdGeomPointInstancer_inactiveIds InactiveIds: List-edited, Unvarying Masking

    The first masking feature encodes a list of IDs in a list-editable metadatum
    called \\em inactiveIds, which, although it does not have any similar 
    impact to stage population as \\ref UsdPrim::SetActive() "prim activation",
    it shares with that feature that its application is uniform over all time.
    Because it is list-editable, we can \\em sparsely add and remove instances
    from it in many layers.
    
    This sparse application pattern makes \\em inactiveIds a good choice when
    further downstream clients may need to reverse masking decisions made
    upstream, in a manner that is robust to many kinds of future changes to
    the upstream data.
    
    See ActivateId(), ActivateIds(), DeactivateId(), DeactivateIds(), 
    ActivateAllIds()

    \\subsection UsdGeomPointInstancer_invisibleIds invisibleIds: Animatable Masking

    The second masking feature encodes a list of IDs in a time-varying
    Int64Array-valued UsdAttribute called \\em invisibleIds , since it shares
    with \\ref UsdGeomImageable::GetVisibilityAttr() "Imageable visibility"
    the ability to animate object visibility.
    
    Unlike \\em inactiveIds, overriding a set of opinions for \\em invisibleIds
    is not at all straightforward, because one will, in general need to
    reauthor (in the overriding layer) **all** timeSamples for the attribute
    just to change one Id's visibility state, so it cannot be authored
    sparsely.  But it can be a very useful tool for situations like encoding
    pre-computed camera-frustum culling of geometry when either or both of
    the instances or the camera is animated.
    
    See VisId(), VisIds(), InvisId(), InvisIds(), VisAllIds()
     
    \\section UsdGeomPointInstancer_protoProcessing Processing and Not Processing Prototypes
    
    Any prim in the scenegraph can be targeted as a prototype by the
    \\em prototypes relationship.  We do not, however, provide a specific
    mechanism for identifying prototypes as geometry that should not be drawn
    (or processed) in their own, local spaces in the scenegraph.  We
    encourage organizing all prototypes as children of the PointInstancer
    prim that consumes them, and pruning "raw" processing and drawing
    traversals when they encounter a PointInstancer prim; this is what the
    UsdGeomBBoxCache and UsdImaging engines do.
    
    There \\em is a pattern one can deploy for organizing the prototypes
    such that they will automatically be skipped by basic UsdPrim::GetChildren()
    or UsdPrimRange traversals.  Usd prims each have a 
    \\ref Usd_PrimSpecifiers "specifier" of "def", "over", or "class".  The
    default traversals skip over prims that are "pure overs" or classes.  So
    to protect prototypes from all generic traversals and processing, place
    them under a prim that is just an "over".  For example,
    \\code
    01 def PointInstancer "Crowd_Mid"
    02 {
    03     rel prototypes = [ </Crowd_Mid/Prototypes/MaleThin_Business>, </Crowd_Mid/Prototypes/MaleTine_Casual> ]
    04     
    05     over "Prototypes" 
    06     {
    07          def "MaleThin_Business" (
    08              references = [@MaleGroupA/usd/MaleGroupA.usd@</MaleGroupA>]
    09              variants = {
    10                  string modelingVariant = "Thin"
    11                  string costumeVariant = "BusinessAttire"
    12              }
    13          )
    14          { ... }
    15          
    16          def "MaleThin_Casual"
    17          ...
    18     }
    19 }
    \\endcode
    """

    inherits = </Boundable>
    customData = {
        dictionary extraPlugInfo = {
            bool implementsComputeExtent = true
        }
        dictionary schemaTokens = {
            dictionary inactiveIds = {
                string doc = """int64listop prim metadata that specifies
                the PointInstancer ids that should be masked (unrenderable)
                over all time."""
            }
        }
    }
) {
  rel prototypes (
      doc = """<b>Required property</b>. Orders and targets the prototype root 
      prims, which can be located anywhere in the scenegraph that is convenient,
      although we promote organizing prototypes as children of the 
      PointInstancer.  The position of a prototype in this relationship defines
      the value an instance would specify in the \\em protoIndices attribute to 
      instance that prototype. Since relationships are uniform, this property
      cannot be animated."""
  ) 

  int[] protoIndices (
      doc = """<b>Required property</b>. Per-instance index into 
      \\em prototypes relationship that identifies what geometry should be 
      drawn for each instance.  <b>Topology attribute</b> - can be animated, 
      but at a potential performance impact for streaming."""
  )

  int64[] ids (
      doc = """Ids are optional; if authored, the ids array should be the same
      length as the \\em protoIndices array, specifying (at each timeSample if
      instance identities are changing) the id of each instance. The
      type is signed intentionally, so that clients can encode some
      binary state on Id'd instances without adding a separate primvar.
      See also \\ref UsdGeomPointInstancer_varyingTopo"""
  )

  point3f[] positions (
      doc = """<b>Required property</b>. Per-instance position.  See also 
      \\ref UsdGeomPointInstancer_transform ."""
  )

  quath[] orientations (
      doc="""If authored, per-instance orientation of each instance about its 
      prototype's origin, represented as a unit length quaternion, which
      allows us to encode it with sufficient precision in a compact GfQuath.
      
      It is client's responsibility to ensure that authored quaternions are
      unit length; the convenience API below for authoring orientations from
      rotation matrices will ensure that quaternions are unit length, though
      it will not make any attempt to select the "better (for interpolation
      with respect to neighboring samples)" of the two possible quaternions
      that encode the rotation. 
      
      See also \\ref UsdGeomPointInstancer_transform ."""  )

  float3[] scales (
      doc="""If authored, per-instance scale to be applied to 
      each instance, before any rotation is applied.
      
      See also \\ref UsdGeomPointInstancer_transform ."""
  )

  vector3f[] velocities (
       doc = """If provided, per-instance 'velocities' will be used to 
       compute positions between samples for the 'positions' attribute,
       rather than interpolating between neighboring 'positions' samples.
       Velocities should be considered mandatory if both \\em protoIndices
       and \\em positions are animated.  Velocity is measured in position
       units per second, as per most simulation software. To convert to
       position units per UsdTimeCode, divide by
       UsdStage::GetTimeCodesPerSecond().

       See also \\ref UsdGeomPointInstancer_transform, 
       \\ref UsdGeom_VelocityInterpolation ."""
  )

  vector3f[] accelerations (
        doc = """If authored, per-instance 'accelerations' will be used with
        velocities to compute positions between samples for the 'positions'
        attribute rather than interpolating between neighboring 'positions'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
  )

  vector3f[] angularVelocities (
      doc="""If authored, per-instance angular velocity vector to be used for
      interoplating orientations.  Angular velocities should be considered
      mandatory if both \\em protoIndices and \\em orientations are animated.
      Angular velocity is measured in <b>degrees</b> per second. To convert
      to degrees per UsdTimeCode, divide by
      UsdStage::GetTimeCodesPerSecond().
      
      See also \\ref UsdGeomPointInstancer_transform ."""
  )
  
  int64[] invisibleIds = [] (
      doc="""A list of id's to make invisible at the evaluation time.
      See \\ref UsdGeomPointInstancer_invisibleIds ."""
  )
}


class Camera "Camera" (
    doc = """Transformable camera.
    
    Describes optical properties of a camera via a common set of attributes
    that provide control over the camera's frustum as well as its depth of
    field. For stereo, the left and right camera are individual prims tagged
    through the \\ref UsdGeomCamera::GetStereoRoleAttr() "stereoRole attribute".
    
    There is a corresponding class GfCamera, which can hold the state of a
    camera (at a particular time). \\ref UsdGeomCamera::GetCamera() and
    \\ref UsdGeomCamera::SetFromCamera() convert between a USD camera prim and
    a GfCamera.

    To obtain the camera's location in world space, call the following on a
    UsdGeomCamera 'camera':
    \\code
    GfMatrix4d camXform = camera.ComputeLocalToWorldTransform(time);
    \\endcode
    \\note
    <b>Cameras in USD are always "Y up", regardless of the stage's orientation
    (i.e. UsdGeomGetStageUpAxis()).</b>  This means that the inverse of 
    'camXform' (the VIEW half of the <A HREF="http://www.glprogramming.com/red/chapter03.html#name2">MODELVIEW transform in OpenGL parlance</A>) 
    will transform the world such that the camera is at the origin, looking 
    down the -Z axis, with +Y as the up axis, and +X pointing to the right.
    This describes a __right handed coordinate system__. 

    \\section UsdGeom_CameraUnits Units of Measure for Camera Properties

    Despite the familiarity of millimeters for specifying some physical
    camera properties, UsdGeomCamera opts for greater consistency with all
    other UsdGeom schemas, which measure geometric properties in scene units,
    as determined by UsdGeomGetStageMetersPerUnit().  We do make a
    concession, however, in that lens and filmback properties are measured in
    __tenths of a scene unit__ rather than "raw" scene units.  This means
    that with the fallback value of .01 for _metersPerUnit_ - i.e. scene unit
    of centimeters - then these "tenth of scene unit" properties are
    effectively millimeters.

    \\note If one adds a Camera prim to a UsdStage whose scene unit is not
    centimeters, the fallback values for filmback properties will be
    incorrect (or at the least, unexpected) in an absolute sense; however,
    proper imaging through a "default camera" with focusing disabled depends
    only on ratios of the other properties, so the camera is still usable.
    However, it follows that if even one property is authored in the correct
    scene units, then they all must be.

    
    \\sa \\ref UsdGeom_LinAlgBasics
     """
    inherits = </Xformable>
    customData = {
        string extraIncludes = """
#include "pxr/base/gf/camera.h" """
    }
) {
    # viewing frustum
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"])
    float horizontalAperture  = 20.9550 (
        doc = """Horizontal aperture in tenths of a scene unit; see 
                 \\ref UsdGeom_CameraUnits . Default is the equivalent of 
                 the standard 35mm spherical projector aperture.""")
    float verticalAperture  = 15.2908 (
        doc = """Vertical aperture in tenths of a scene unit; see 
                 \\ref UsdGeom_CameraUnits . Default is the equivalent of 
                 the standard 35mm spherical projector aperture.""")
    float horizontalApertureOffset = 0.0 (
        doc = """Horizontal aperture offset in the same units as
                 horizontalAperture. Defaults to 0.""")
    float verticalApertureOffset = 0.0 (
        doc = """Vertical aperture offset in the same units as
                 verticalAperture. Defaults to 0.""")
    float focalLength = 50.0 (
        doc = """Perspective focal length in tenths of a scene unit; see 
                 \\ref UsdGeom_CameraUnits .""")
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in scene units; see 
                 \\ref UsdGeom_CameraUnits .""")
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.
                 A vector (a,b,c,d) encodes a clipping plane that cuts off
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)
                 are the coordinates in the camera's space.""")

    # depth of field
    float fStop = 0.0 (
        doc = """Lens aperture. Defaults to 0.0, which turns off focusing.""")
    float focusDistance = 0.0 (
        doc = """Distance from the camera to the focus plane in scene units; see 
                 \\ref UsdGeom_CameraUnits .""")

    # stereoscopic 3D
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left
                 or right camera of a stereo setup.""")

    # Parameters for motion blur
    double shutter:open = 0.0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative
                 value indicates that the shutter opens before the current
                 frame time). Used for motion blur."""
    )
    double shutter:close = 0.0 (
        doc = """Frame relative shutter close time, analogous comments from
                 shutter:open apply. A value greater or equal to shutter:open
                 should be authored, otherwise there is no exposure and a
                 renderer should produce a black image."""
    )
    
    # exposure adjustment
    float exposure = 0.0 (
        doc = """Exposure adjustment, as a log base-2 value.  The default
                 of 0.0 has no effect.  A value of 1.0 will double the
                 image-plane intensities in a rendered image; a value of
                 -1.0 will halve them."""
    )
}

class "GeomModelAPI"
(
    inherits = </APISchemaBase>
    customData = {
        string className = "ModelAPI"
        string extraIncludes = """
#include "pxr/usd/usdGeom/bboxCache.h"
#include "pxr/usd/usdGeom/constraintTarget.h"
#include "pxr/usd/usdGeom/imageable.h" """
        dictionary schemaTokens = {
            dictionary extentsHint = {
                string doc = """Name of the attribute used to author extents
                hints at the root of leaf models. Extents hints are stored by purpose
                as a vector of GfVec3f values. They are ordered based on the order
                of purpose tokens returned by 
                UsdGeomImageable::GetOrderedPurposeTokens."""
            }
        }
    }
    doc = """UsdGeomModelAPI extends the generic UsdModelAPI schema with
    geometry specific concepts such as cached extents for the entire model,
    constraint targets, and geometry-inspired extensions to the payload
    lofting process.
   
    As described in GetExtentsHint() below, it is useful to cache extents
    at the model level.  UsdGeomModelAPI provides schema for computing and
    storing these cached extents, which can be consumed by UsdGeomBBoxCache to
    provide fast access to precomputed extents that will be used as the model's
    bounds ( see UsdGeomBBoxCache::UsdGeomBBoxCache() ).

    \\section UsdGeomModelAPI_drawMode Draw Modes

    Draw modes provide optional alternate imaging behavior for USD subtrees with
    kind model. \\em model:drawMode (which is inheritable) and
    \\em model:applyDrawMode (which is not) are resolved into a decision to stop
    traversing the scene graph at a certain point, and replace a USD subtree
    with proxy geometry.

    The value of \\em model:drawMode determines the type of proxy geometry:
    - \\em origin - Draw the model-space basis vectors of the replaced prim.
    - \\em bounds - Draw the model-space bounding box of the replaced prim.
    - \\em cards - Draw textured quads as a placeholder for the replaced prim.
    - \\em default - An explicit opinion to draw the USD subtree as normal.
    - \\em inherited - Defer to the parent opinion.

    \\em model:drawMode falls back to _inherited_ so that a whole scene,
    a large group, or all prototypes of a model hierarchy PointInstancer can
    be assigned a draw mode with a single attribute edit.  If no draw mode is
    explicitly set in a hierarchy, the resolved value is _default_.

    \\em model:applyDrawMode is meant to be written when an asset is authored,
    and provides flexibility for different asset types. For example,
    a character assembly (composed of character, clothes, etc) might have
    \\em model:applyDrawMode set at the top of the subtree so the whole group
    can be drawn as a single card object. An effects subtree might have
    \\em model:applyDrawMode set at a lower level so each particle
    group draws individually.

    Models of kind component are treated as if \\em model:applyDrawMode
    were true.  This means a prim is drawn with proxy geometry when: the
    prim has kind component, and/or \\em model:applyDrawMode is set; and
    the prim's resolved value for \\em model:drawMode is not _default_.

    \\section UsdGeomModelAPI_cardGeometry Cards Geometry

    The specific geometry used in cards mode is controlled by the
    \\em model:cardGeometry attribute:
    - \\em cross - Generate a quad normal to each basis direction and negative.
                   Locate each quad so that it bisects the model extents.
    - \\em box   - Generate a quad normal to each basis direction and negative.
                   Locate each quad on a face of the model extents, facing out.
    - \\em fromTexture - Generate a quad for each supplied texture from
                         attributes stored in that texture's metadata.

    For \\em cross and \\em box mode, the extents are calculated for purposes
    \\em default, \\em proxy, and \\em render, at their earliest authored time.
    If the model has no textures, all six card faces are rendered using
    \\em model:drawModeColor. If one or more textures are present, only axes
    with one or more textures assigned are drawn.  For each axis, if both
    textures (positive and negative) are specified, they'll be used on the
    corresponding card faces; if only one texture is specified, it will be
    mapped to the opposite card face after being flipped on the texture's
    s-axis. Any card faces with invalid asset paths will be drawn with
    \\em model:drawModeColor.

    Both \\em model:cardGeometry and \\em model:drawModeColor should be
    authored on the prim where the draw mode takes effect, since these
    attributes are not inherited.

    For \\em fromTexture mode, only card faces with valid textures assigned
    are drawn. The geometry is generated by pulling the \\em worldtoscreen
    attribute out of texture metadata.  This is expected to be a 4x4 matrix
    mapping the model-space position of the card quad to the clip-space quad
    with corners (-1,-1,0) and (1,1,0).  The card vertices are generated by
    transforming the clip-space corners by the inverse of \\em worldtoscreen.
    Textures are mapped so that (s) and (t) map to (+x) and (+y) in clip space.
    If the metadata cannot be read in the right format, or the matrix can't
    be inverted, the card face is not drawn.

    All card faces are drawn and textured as single-sided.

    \\todo CreatePayload() """
)
{
    uniform token model:drawMode = "inherited" (
        allowedTokens = ["origin", "bounds", "cards", "default", "inherited"]
        doc = """Alternate imaging mode; applied to this prim or child prims
                 where \\em model:applyDrawMode is true, or where the prim
                 has kind \\em component. See \\ref UsdGeomModelAPI_drawMode
                 for mode descriptions."""
    )
    uniform bool model:applyDrawMode = false (
        doc = """If true, and the resolved value of \\em model:drawMode is
                 non-default, apply an alternate imaging mode to this prim. See
                 \\ref UsdGeomModelAPI_drawMode."""
    )
    uniform float3 model:drawModeColor = (0.18, 0.18, 0.18) (
        doc = """The base color of imaging prims inserted for alternate
                 imaging modes. For \\em origin and \\em bounds modes, this
                 controls line color; for \\em cards mode, this controls the
                 fallback quad color."""
    )
    uniform token model:cardGeometry = "cross" (
        allowedTokens = ["cross", "box", "fromTexture"]
        doc = """The geometry to generate for imaging prims inserted for \\em
                 cards imaging mode. See \\ref UsdGeomModelAPI_cardGeometry for
                 geometry descriptions."""
    )
    asset model:cardTextureXPos (
        doc = """In \\em cards imaging mode, the texture applied to the X+ quad.
                 The texture axes (s,t) are mapped to model-space axes (-y, -z)."""
    )
    asset model:cardTextureYPos (
        doc = """In \\em cards imaging mode, the texture applied to the Y+ quad.
                 The texture axes (s,t) are mapped to model-space axes (x, -z)."""
    )
    asset model:cardTextureZPos (
        doc = """In \\em cards imaging mode, the texture applied to the Z+ quad.
                 The texture axes (s,t) are mapped to model-space axes (x, -y)."""
    )
    asset model:cardTextureXNeg (
        doc = """In \\em cards imaging mode, the texture applied to the X- quad.
                 The texture axes (s,t) are mapped to model-space axes (y, -z)."""
    )
    asset model:cardTextureYNeg (
        doc = """In \\em cards imaging mode, the texture applied to the Y- quad.
                 The texture axes (s,t) are mapped to model-space axes (-x, -z)."""
    )
    asset model:cardTextureZNeg (
        doc = """In \\em cards imaging mode, the texture applied to the Z- quad.
                 The texture axes (s,t) are mapped to model-space axes (-x, -y)."""
    )
}

class "MotionAPI"
(
    inherits = </APISchemaBase>
    doc = """UsdGeomMotionAPI encodes data that can live on any prim that
    may affect computations involving:
    - computed motion for motion blur
    - sampling for motion blur
    
    For example, UsdGeomMotionAPI provides *velocityScale* 
    (GetVelocityScaleAttr()) for controlling how motion-blur samples should
    be computed by velocity-consuming schemas."""
)
{
    float motion:velocityScale = 1.0 (
        customData = {
            string apiName = "velocityScale"
        }
        doc = """VelocityScale is an **inherited** float attribute that
        velocity-based schemas (e.g. PointBased, PointInstancer) can consume
        to compute interpolated positions and orientations by applying
        velocity and angularVelocity, which is required for interpolating 
        between samples when topology is varying over time.  Although these 
        quantities are generally physically computed by a simulator, sometimes 
        we require more or less motion-blur to achieve the desired look.  
        VelocityScale allows artists to dial-in, as a post-sim correction, 
        a scale factor to be applied to the velocity prior to computing 
        interpolated positions from it.
        
        See also ComputeVelocityScale()"""
    )
}

class "XformCommonAPI"
(
    inherits = </APISchemaBase>
    doc = """This class provides API for authoring and retrieving a standard set
    of component transformations which include a scale, a rotation, a 
    scale-rotate pivot and a translation. The goal of the API is to enhance 
    component-wise interchange. It achieves this by limiting the set of allowed 
    basic ops and by specifying the order in which they are applied. In addition
    to the basic set of ops, the 'resetXformStack' bit can also be set to 
    indicate whether the underlying xformable resets the parent transformation 
    (i.e. does not inherit it's parent's transformation). 

    \\sa UsdGeomXformCommonAPI::GetResetXformStack()
    \\sa UsdGeomXformCommonAPI::SetResetXformStack()

    The operator-bool for the class will inform you whether an existing 
    xformable is compatible with this API.

    The scale-rotate pivot is represented by a pair of (translate, 
    inverse-translate) xformOps around the scale and rotate operations.
    The rotation operation can be any of the six allowed Euler angle sets.
    \\sa UsdGeomXformOp::Type. 

    The xformOpOrder of an xformable that has all of the supported basic ops 
    is as follows:
    ["xformOp:translate", "xformOp:translate:pivot", "xformOp:rotateXYZ",
    "xformOp:scale", "!invert!xformOp:translate:pivot"].

    It is worth noting that all of the ops are optional. For example, an 
    xformable may have only a translate or a rotate. It would still be 
    considered as compatible with this API. Individual SetTranslate(), 
    SetRotate(), SetScale() and SetPivot() methods are provided by this API 
    to allow such sparse authoring."""
    customData = {
        string apiSchemaType = "nonApplied"
        string extraIncludes = """
#include "pxr/usd/usdGeom/xformable.h"
#include "pxr/usd/usdGeom/xformOp.h" """
        dictionary schemaTokens = {
            dictionary pivot = {
                string doc = """Op suffix for the standard scale-rotate pivot
                on a UsdGeomXformCommonAPI-compatible prim.
                """
            }
        }
    }
)
{
}

class HermiteCurves "HermiteCurves" (
    inherits = </Curves>
    doc = """This schema specifies a cubic hermite interpolated curve batch as
    sometimes used for defining guides for animation. While hermite curves can
    be useful because they interpolate through their control points, they are
    not well supported by high-end renderers for imaging. Therefore, while we
    include this schema for interchange, we strongly recommend the use of
    UsdGeomBasisCurves as the representation of curves intended to be rendered
    (ie. hair or grass). Hermite curves can be converted to a Bezier
    representation (though not from Bezier back to Hermite in general).

    \\section UsdGeomHermiteCurves_Interpolation Point Interpolation
    
    The initial cubic curve segment is defined by the first two points and
    first two tangents. Additional segments are defined by additional 
    point / tangent pairs.  The number of segments for each non-batched hermite
    curve would be len(curve.points) - 1.  The total number of segments
    for the batched UsdGeomHermiteCurves representation is
    len(points) - len(curveVertexCounts).

    \\section UsdGeomHermiteCurves_Primvars Primvar, Width, and Normal Interpolation

    Primvar interpolation is not well specified for this type as it is not
    intended as a rendering representation. We suggest that per point
    primvars would be linearly interpolated across each segment and should 
    be tagged as 'varying'.

    It is not immediately clear how to specify cubic or 'vertex' interpolation
    for this type, as we lack a specification for primvar tangents. This
    also means that width and normal interpolation should be restricted to
    varying (linear), uniform (per curve element), or constant (per prim).
    """
) {
    vector3f[] tangents = [] (
        doc = """Defines the outgoing trajectory tangent for each point. 
                 Tangents should be the same size as the points attribute.""")
}
{
    "Plugins": [
        {
            "Info": {
                "Types": {
                    "NdrDiscoveryPlugin": {},
                    "_NdrFilesystemDiscoveryPlugin" : {
                        "bases": ["NdrDiscoveryPlugin"],
                        "displayName": "Filesystem Discovery"
                    },
                    "NdrParserPlugin": {}
                }
            },
            "LibraryPath": "", 
            "Name": "ndr", 
            "ResourcePath": "resources", 
            "Root": "..", 
            "Type": "library"
        }
    ]
}
{
    "Includes": [
        "*/resources/"
    ]
}
